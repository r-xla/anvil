#' @title Graph Variable
#' @description
#' Variable in a [`Graph`].
#' @section Fields:
#' * `state` :: (`any`)\cr
#'   The state of the variable. Populated when the graph is executed.
GraphVariable <- mut(new_class(
  "GraphVariable",
  properties = list(
    aval = ShapedTensor
  )
))

is_graph_variable <- function(x) {
  inherits(x, "anvil::mut<GraphVariable>")
}


#' @title Primitive Call
#' @description
#' Call of a primitive in a [`Graph`].
#' @section Fields:
#' * `primitive` :: ([`Primitive`])\cr
#'   The function.
#' * `inputs` :: (`list(GraphVariable)`)\cr
#'   The (tensor) inputs to the primitive.
#' * `params` :: (`list(<any>)`)\cr
#'   The (static) parameters of the function call.
#' * `outputs` :: (`list(GraphVariable)`)\cr
#'   The (tensor) outputs of the primitive.
#' @export
PrimitiveCall <- new_class(
  "PrimitiveCall",
  properties = list(
    primitive = Primitive,
    # TODO: Params
    params = list_of(class_any),
    inputs = list_of(GraphVariable),
    outputs = list_of(GraphVariable)
  )
)

set_graph_outputs <- function(graph, outputs) {
  graph@outputs <- outputs
  maybe_restore_previous_graph(graph)
  graph
}

maybe_restore_previous_graph <- function(graph = NULL) {
  if (!is.null(graph) && !identical(graph, globals[["CURRENT_GRAPH"]])) {
    # graph has already been returned
    return()
  }

  stash_size <- length(globals[["GRAPH_STASH"]])
  if (stash_size) {
    globals[["CURRENT_GRAPH"]] <- globals[["GRAPH_STASH"]][[stash_size]]
    globals[["GRAPH_STASH"]] <- globals[["GRAPH_STASH"]][-stash_size]
  } else {
    globals[["CURRENT_GRAPH"]] <- NULL
  }
}

#' @title Get the current graph
#' @description
#' Get the current graph being built (via [`local_graph`]).
#' @return A [`Graph`] object.
#' @export
.current_graph <- function() {
  globals[["CURRENT_GRAPH"]] %??%
    cli_abort("No graph is currently being built")
}

#' @title Create a graph
#' @description
#' Creates a new [`Graph`] which is afterwards accessible via [`.current_graph()`].
#' The graph is automatically removed when exiting the current scope.
#' After the graph is either cleaned up automatically (by exiting the scope)
#' or finalized, the previously built graph is restored,
#' i.e., accessible via [`.current_graph()`].
#'
#' @param envir (`environment`)\cr
#'   Environment where exit handler will be registered for cleaning up the
#'   [`Graph`] if it was not returned yet.
#' @return A [`Graph`] object.
#' @export
local_graph <- function(envir = parent.frame()) {
  graph <- Graph()
  if (!is.null(globals[["CURRENT_GRAPH"]])) {
    globals[["GRAPH_STASH"]] <- c(
      globals[["GRAPH_STASH"]],
      list(globals[["CURRENT_GRAPH"]])
    )
  }
  globals[["CURRENT_GRAPH"]] <- graph

  withr::defer(
    envir = envir,
    {
      maybe_restore_previous_graph(graph)
    },
    priority = "first"
  )
  return(graph)
}

#' @title Graph of Primitive Calls
#'
#' @description
#' Computational graph consisting exclusively of primitive calls.
#'
#' @section Fields:
#' * `calls` :: (`list(PrimitiveCall)`)\cr
#'   The primitive calls that make up the graph.
#'   This can also be another call into a graph when the primitive is a `p_call`.
#' * `in_tree` :: (`NULL | Node`)\cr
#'   The tree of inputs.
#' * `out_tree` :: (`NULL | Node`)\cr
#'   The tree of outputs.
#' * `inputs` :: (`list(GraphVariable)`)\cr
#'   The inputs to the graph.
#' * `outputs` :: (`list(GraphVariable)`)\cr
#'   The outputs of the graph.
#'
#' @export
Graph <- new_class(
  "Graph",
  properties = list(
    # Primitive: list(GraphVariable) --[params]--> list(GraphVariable)
    # All the GraphVariables that are inputs will already have a binding.
    # Those that are constants as well
    calls = list_of(PrimitiveCall),
    # Used to (un-)flatten inputs and outputs
    in_tree = NULL | new_S3_class("Node"),
    out_tree = NULL | new_S3_class("Node"),
    inputs = list_of(GraphVariable),
    outputs = list_of(GraphVariable)
  )
)

eval_primitive_call <- function(.call) {
  outputs <- do.call(call@primitive[["graph"]], lapply(call@inputs, \(x) x@state))
  for (i in seq_along(outputs)) {
    call@outputs[[i]]@aval <- outputs[[i]]
  }
}

graph_reduce <- function(.graph, ...) {
  args <- list(...)
  args_flat <- flatten(args)

  if (length(args_flat) != length(.graph@inputs)) {
    cli_abort("Expected {length(.graph@inputs)} arguments, but got {length(args_flat)}")
  }

  # bind inputs
  for (i in seq_along(args_flat)) {
    .graph@inputs[[i]]@aval <- args_flat[[i]]
  }

  for (.call in .graph@calls) {
    eval_primitive_call(.call)
  }

  outs_flat <- lapply(.call@outputs, \(x) x@aval)

  unflatten(.graph@out_tree, outs_flat)
}

graph_to_function <- function(.graph, .class = NULL) {
  structure(function(...) {
    graph_reduce(.graph, list(...))
  }, class = c(.class, "anvil::GraphFunction"))
}


is_graph <- function(x) {
  inherits(x, "anvil::Graph")
}

#' @title Graph Transformation
#' @description
#' Abstract base class for a (chained) graph transformation.
#' To apply such a (chained) transformation, use [`apply_transform()`].
#' @export
GraphTransformation <- new_class("GraphTransformation",
  properties = list(
    input = class_function | new_S3_class("anvil::GraphTransformation")
  )
)

is_graph_transformation <- function(x) {
  inherits(x, "anvil::GraphTransformation")
}

#' @title Transform a graph
#' @description
#' Apply a given transformation using the provided inputs.
#'
#' @section Adding a new Transformation:
#' In order to create a new transformatin, you need to:
#' 1. Create a custom subclass of `GraphTransformation`.
#' 1. Create a transformation function (like `gradient()`) that returns this subclass.
#' 1. Implement the `apply_transform()` method for this subclass.
#'    This is where the real complexity lies.
#'    Here, you can assume that the `@inputs` field is a [`Graph`], as recursion and conversion
#'    from a `function` to a [`Graph`] is handled by the generic.
#'
#' **Modifying Inputs or Outputs**:
#' When implementing a new transformation that modified the inputs or outputs of the graph,
#' it's important to ensure that `in_tree` and `out_tree` are updated accordingly.
#'
#' TODO:
#' @param x (`GraphTransformation`)\cr
#'   The transformation to apply.
#' @param args (`list(<any>)`)\cr
#'   The inputs to the transformation.
#' @return (`list(GraphTransformation | Graph, list(<any>))`)\cr
#'   The transformed graph(-transformation) and (possibly transformed) input values.
#' @export
apply_transform <- new_generic("transform", "gt", function(gt, args) {
  if (is_graph_transformation(gt)) {
    Recall(do.call(apply_transform, gt@input), args)
  }
  if (!is_graph_transformation(gt)) {
    gt <- graphify(gt, args)
  }
  S7::S7_dispatch()
})

GraphInterpreter <- new_class(
  "GraphInterpreter",
  parent = Interpreter,
  properties = list(
    graph = Graph
  )
)

GraphBox <- new_class(
  "GraphBox",
  parent = Box,
  properties = list(
    gvar = GraphVariable,
    graph = Graph
  )
)

append_primitive_call <- function(graph, call) {
  graph@calls <- c(graph@calls, call)
  graph
}

method(process_primitive, GraphInterpreter) <- function(
  interpreter,
  prim,
  boxes,
  params
) {
  avals_in <- lapply(boxes, aval)
  outputs <- rlang::exec(prim[["graph"]], !!!c(avals_in, params))

  gvars_out <- lapply(outputs, GraphVariable)
  gvars_in <- lapply(boxes, \(b) b@gvar)

  # Here, we need to determine graph
  # Ideally, I would like to do this from the inputs.


  # in-place modification
  append_primitive_call(interpreter@main@global_data,
    PrimitiveCall(prim, params, gvars_in, gvars_out)
  )

  lapply(gvars_out, GraphBox, interpreter = interpreter)
}

# f <- function(x, y, type) {
#   if (type == "mul") {
#     x * y
#   } else {
#     x + y
#   }
# }
# Let's say we do jit(gradient(f, wrt = "x"), static = "type")
# The problem is that

graphify <- function(.f, ...) {
  # The output graph here still contains static inputs I think.
  # Maybe one does not even have to specify this explicitly but just treat all the
  # AnvilTensor inputs as non-static and everything else as static.
  # TODO: flattening
  args <- list(...)
  args_flat <- flatten(args)
  in_tree <- build_tree(args_flat)
  f_flat <- flatten_fun(.f, in_node = in_tree)

  graph <- Graph(in_tree = in_tree)

  gvars <- lapply(args_flat, \(x) {
    if (is_anvil_tensor(x)) {
      type <- ShapedTensor(dtype(x), Shape(shape(x)))
      GraphVariable(aval = type)
    } else {
      # this is a static input
      x
    }
  })

  main <- local_main(GraphInterpreter)
  interpreter <- GraphInterpreter(main = main)
  gboxes <- lapply(gvars, GraphBox, interpreter = interpreter)

  # TODO(maybe): remove 'static' argument from jit, as we assume here
  # that every non-AnvilTensor is static.
  graph@inputs <- gvars[vapply(gvars, is_graph_variable, logical(1L))]

  out <- do.call(f_flat, gboxes)

  out_tree <- out[[1L]]
  outputs <- out[[2L]]

  if (any(outputs, vapply(outputs, \(x) !is_graph_variable(x), logical(1L)))) {
    cli_abort("Function .f must return only `AnvilTensor`s")
  }

  graph@out_tree <- out_tree
  graph@outputs <- outputs


  inputs <- lapply(gvars, \(x) {
    if (is_anvil_tensor(x@type)) {
      x@aval
    } else {
      x
    }
  })

  list(graph, inputs)
}
# Boxing only happens during graphify.
# Afterwards, all variables that need to be boxed are the input(-constants)

# What happens in:
#
# g <- gradient(function(x, y) {
#   # this will be inlined
#   out <- gradient(f)(x, y)
#   f(out[[1]], out[[2]])
# })
# # What happens here?
# # 1. We start building the outer graph
# # 2. When we call into gradient(f)(x, y), x and y are already GraphVariables,
# #    but we will:
#      2.1 Create a new graph
#      2.2 Transform this new graph into a backward graph
#      2.3 Call into this backward graph with x and y just to embed the inner graph in the
#          outer graph
#      --> This does work twice.
# Therefore, what we should to is to skip 2.3 and just embed the inner graph into the outer graph.
# But, how can we do this?
# We can do this by creating a Primitive('call') and making
# gradient(f) return a function that calls into Primitive('call') and that has the
# inner graph as a parameter.
#
# But what do we do about
# g <- gradient(function(x, y) {
#   # this will be inlined
#   out <- gradient(f)()
#   f(out[[1]], out[[2]])
# })
#
method(box, list(GraphInterpreter, ShapedTensor)) <- function(interpreter, x) {
  GraphBox(interpreter, GraphVariable(aval = x))
}

method(box, list(GraphInterpreter, class_any)) <- function(interpreter, x) {
  box(interpreter, aval(x))
}

method(aval, GraphBox) <- function(x) {
  x@gvar@aval
}


method(format, GraphBox) <- function(x) {
  sprintf("GraphBox(%s)", format(x@gvar@aval))
}

method(print, GraphBox) <- function(x) {
  cat(format(x), "\n")
}
