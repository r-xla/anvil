> devtools::test()
i Testing anvil
Overwriting method platform(<anvil::ShapedTensor>)
Overwriting method platform(<anvil::ConcreteTensor>)
Overwriting method ==(<anvil::ShapedTensor>, <anvil::ShapedTensor>)
Overwriting method repr(<anvil::ShapedTensor>)
Overwriting method platform(<anvil::Box>)
v | F W  S  OK | Context

/ |          0 | api-jit                                                        
\ |          2 | api-jit                                                        
/ |          4 | api-jit                                                        
| | 1        6 | api-jit                                                        
x | 2        6 | api-jit
--------------------------------------------------------------------------------
Error ('test-api-jit.R:54:3'): constants can be lifted to the appropriate level
Error in `call@primitive[["backward"]]`: Rule backward not defined for primitive power
Backtrace:
     x
  1. \-jit(gradient(f, wrt = "x"))(nv_scalar(2)) at test-api-jit.R:54:3
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-anvil (local) `<fn>`(x = `<anvl::GB>`)
  7.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8.           +-rlang::exec(...) at anvil/R/pullback.R:45:5
  9.           +-call@primitive[["backward"]]
 10.           \-anvil (local) `[[.anvil::Primitive`(call@primitive, "backward")
 11.             \-cli::cli_abort("Rule {name} not defined for primitive {x@name}") at anvil/R/primitives.R:42:5
 12.               \-rlang::abort(...)

Error ('test-api-jit.R:61:3'): wrt non-existent argument
Error in `build_gradient_graph(fwd_graph, wrt)`: Pullback can only be computed for functions that return a scalar
Backtrace:
     x
  1. +-testthat::expect_error(...) at test-api-jit.R:61:3
  2. | \-testthat:::expect_condition_matching(...)
  3. |   \-testthat:::quasi_capture(...)
  4. |     +-testthat (local) .capture(...)
  5. |     | \-base::withCallingHandlers(...)
  6. |     \-rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  7. \-jit(gradient(f, wrt = "y"))(nv_tensor(2))
  8.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  9.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
 10.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
 11.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
 12.       \-anvil (local) `<fn>`(x = `<anvl::GB>`)
 13.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
 14.           \-cli::cli_abort("Pullback can only be computed for functions that return a scalar") at anvil/R/pullback.R:12:5
 15.             \-rlang::abort(...)
--------------------------------------------------------------------------------

/ |          0 | api-pullback                                                   
x | 1        0 | api-pullback
--------------------------------------------------------------------------------
Error ('test-api-pullback.R:8:3'): nv_mean
Error in `call@primitive[["backward"]]`: Rule backward not defined for primitive divide
Backtrace:
     x
  1. \-jit(gradient(f, wrt = "alpha"))(y, alpha) at test-api-pullback.R:8:3
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-anvil (local) `<fn>`(y = `<anvl::GB>`, alpha = `<anvl::GB>`)
  7.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8.           +-rlang::exec(...) at anvil/R/pullback.R:45:5
  9.           +-call@primitive[["backward"]] at anvil/R/pullback.R:45:5
 10.           \-anvil (local) `[[.anvil::Primitive`(call@primitive, "backward") at anvil/R/pullback.R:45:5
 11.             \-cli::cli_abort("Rule {name} not defined for primitive {x@name}") at anvil/R/primitives.R:42:5
 12.               \-rlang::abort(...)
--------------------------------------------------------------------------------

/ |          0 | flatten                                                        
v |         10 | flatten

/ |          0 | gradient                                                       
x | 3        0 | gradient
--------------------------------------------------------------------------------
Error ('test-gradient.R:6:3'): gradient: simple example
Error: <anvil::mut<Graph>>@outputs must only contain elements of class <anvil::mut<GraphVariable>> or <anvil::mut<GraphConstant>>
Backtrace:
     x
  1. +-anvil (local) g(nv_scalar(1), nv_scalar(2)) at test-gradient.R:6:3
  2. | \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3. |   +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4. |   \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5. |     +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6. |     \-anvil (local) `<fn>`(x = `<anvl::GB>`, y = `<anvl::GB>`)
  7. |       \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8. |         +-base::`@<-`(`*tmp*`, "outputs", value = input_grads) at anvil/R/pullback.R:68:3
  9. |         \-S7:::`@<-.S7_object`(`*tmp*`, "outputs", value = input_grads) at anvil/R/pullback.R:68:3
 10. \-anvil (local) `<fn>`(`<anv::<G>>`, `<list>`)
 11.   \-S7::`prop<-`(`*tmp*`, name, value = `<list>`) at anvil/R/mut.R:34:7

Error ('test-gradient.R:16:3'): gradient: does not depend on input
Error in `FUN(X[[i]], ...)`: All arguments must be FuncVariables
Backtrace:
    x
 1. \-anvil (local) g(nv_scalar(1), nv_scalar(2)) at test-gradient.R:16:3
 2.   \-anvil::stablehlo(graph) at anvil/R/jit.R:64:5
 3.     +-base::do.call(stablehlo::hlo_return, outputs) at anvil/R/stablehlo.R:44:3
 4.     \-stablehlo (local) `<fn>`(NULL)
 5.       \-stablehlo:::hlo_return_impl(values = dots)
 6.         \-base::lapply(...)
 7.           \-stablehlo (local) FUN(X[[i]], ...)
 8.             \-cli::cli_abort("All arguments must be FuncVariables")
 9.               \-rlang::abort(...)

Error ('test-gradient.R:35:1'): (code run outside of `test_that()`)
Error in `eval(code, test_env)`: '...' used in an incorrect context
--------------------------------------------------------------------------------

/ |          0 | graph                                                          
v |         31 | graph

/ |          0 | jit                                                            
/ |          4 | jit                                                            
- |          9 | jit                                                            
- |      1  16 | jit                                                            
/ |      2  22 | jit                                                            
x | 1    2  22 | jit
--------------------------------------------------------------------------------
Error ('test-jit.R:199:3'): HloBox printer
Error in `HloInterpreter(main = local_main(HloInterpreter, global_data = func))`: could not find function "HloInterpreter"
--------------------------------------------------------------------------------

/ |          0 | primitives-jit                                                 
/ |          4 | primitives-jit                                                 
| |          7 | primitives-jit                                                 
\ |         10 | primitives-jit                                                 
| | 2       13 | primitives-jit                                                 
| | 3       16 | primitives-jit                                                 
| | 3       20 | primitives-jit                                                 
| | 3       24 | primitives-jit                                                 
| | 4       27 | primitives-jit                                                 
| | 5       30 | primitives-jit                                                 
/ | 14       30 | primitives-jit                                                
- | 16       33 | primitives-jit                                                
x | 17       33 | primitives-jit [2.8s]
--------------------------------------------------------------------------------
Error ('test-primitives-jit.R:96:5'): p_if
Error in `graph@constants`: no applicable method for `@` applied to an object of class "anvil::FlattenedFunction"
Backtrace:
     x
  1. +-testthat::expect_equal(f(nv_scalar(TRUE), nv_scalar(2)), list(list(nv_scalar(2)))) at test-primitives-jit.R:98:3
  2. | \-testthat::quasi_label(enquo(object), label, arg = "object")
  3. |   \-rlang::eval_bare(expr, quo_get_env(quo))
  4. \-anvil (local) f(nv_scalar(TRUE), nv_scalar(2))
  5.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  6.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  7.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  8.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  9.       \-anvil (local) `<fn>`(pred = `<anvl::GB>`, x = `<anvl::GB>`)
 10.         \-anvil:::nvl_if(pred, list(list(x)), list(list(x * x))) at test-primitives-jit.R:96:5
 11.           \-anvil::stablehlo(true_fn, list()) at anvil/R/primitives.R:370:3

Error ('test-primitives-jit.R:118:5'): error when multiplying lists in if-statement
Error in `graph@constants`: no applicable method for `@` applied to an object of class "anvil::FlattenedFunction"
Backtrace:
     x
  1. +-testthat::expect_error(...) at test-primitives-jit.R:120:3
  2. | \-testthat:::expect_condition_matching(...)
  3. |   \-testthat:::quasi_capture(...)
  4. |     +-testthat (local) .capture(...)
  5. |     | \-base::withCallingHandlers(...)
  6. |     \-rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  7. \-anvil (local) f(nv_scalar(FALSE), list(nv_scalar(2)))
  8.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  9.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
 10.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
 11.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
 12.       \-anvil (local) `<fn>`(pred = `<anvl::GB>`, x = `<list>`)
 13.         \-anvil:::nvl_if(pred, x + x, x * x) at test-primitives-jit.R:118:5
 14.           \-anvil::stablehlo(true_fn, list()) at anvil/R/primitives.R:370:3

Error ('test-primitives-jit.R:131:3'): p_neg
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_neg, torch::torch_neg, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_neg, list(operand)) at anvil/R/primitives.R:67:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_not
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_not, function(x) !x, c(2, 3), dtype = "pred")
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_not, list(operand)) at anvil/R/primitives.R:248:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_abs
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_abs, torch::torch_abs, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_abs, list(operand)) at anvil/R/primitives.R:285:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_sqrt
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(...)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_sqrt, list(operand)) at anvil/R/primitives.R:290:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_rsqrt
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(...)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_rsqrt, list(operand)) at anvil/R/primitives.R:295:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_log
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_log, torch::torch_log, c(2, 3), non_negative = TRUE)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_log, list(operand)) at anvil/R/primitives.R:300:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_tanh
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_tanh, torch::torch_tanh, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_tanh, list(operand)) at anvil/R/primitives.R:305:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_tan
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_tan, torch::torch_tan, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_tan, list(operand)) at anvil/R/primitives.R:310:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_floor
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_floor, torch::torch_floor, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_floor, list(operand)) at anvil/R/primitives.R:315:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_ceil
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_ceil, torch::torch_ceil, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_ceil, list(operand)) at anvil/R/primitives.R:320:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_sign
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_sign, torch::torch_sign, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_sign, list(operand)) at anvil/R/primitives.R:325:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_exp
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_exp, torch::torch_exp, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_exp, list(operand)) at anvil/R/primitives.R:330:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_round
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nv_even, th_even, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-`<fn>`(`<anvl::GB>`)
 11.             \-anvil:::nvl_round(a, method = "nearest_even")
 12.               \-anvil:::graph_call(p_round, list(operand), list(method = method)) at anvil/R/primitives.R:338:3
 13.                 \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 14.                   \-anvil (local) FUN(X[[i]], ...)
 15.                     \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_convert
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nv_fun, th_fun, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-`<fn>`(`<anvl::GB>`)
 11.             \-anvil:::nvl_convert(a, "f64")
 12.               \-anvil:::graph_call(p_convert, list(operand), params = list(dtype = dtype)) at anvil/R/primitives.R:345:3
 13.                 \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 14.                   \-anvil (local) FUN(X[[i]], ...)
 15.                     \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_dot_general
Error in `stablehlo::infer_types_generic_biv(lhs, rhs)`: lhs@type == rhs@type is not TRUE
Backtrace:
     x
  1. \-jit(function(a, b) {...
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-`<fn>`(a = `<anvl::GB>`, b = `<anvl::GB>`)
  7.         \-anvil:::nvl_dot_general(...)
  8.           \-anvil:::graph_call(...) at anvil/R/primitives.R:93:3
  9.             +-rlang::exec(prim[["graph"]], !!!c(vts_in, params)) at anvil/R/graph.R:430:3
 10.             \-anvil (local) `<fn>`(...)
 11.               \-anvil:::graph_rule_binary(lhs, rhs) at anvil/R/rules-graph.R:197:3
 12.                 \-stablehlo::infer_types_generic_biv(lhs, rhs) at anvil/R/rules-graph.R:5:3
 13.                   \-base::stopifnot(lhs@type == rhs@type)
--------------------------------------------------------------------------------
Maximum number of failures exceeded; quitting at end of file.
i Increase this number with (e.g.) `testthat::set_max_fails(Inf)` 

== Results =====================================================================
Duration: 4.2 s

-- Skipped tests (2) -----------------------------------------------------------
* !is_metal() is TRUE (1): 'test-jit.R:185:3'
* empty test (1): 'test-jit.R:117:1'

-- Failed tests ----------------------------------------------------------------
Error ('test-api-jit.R:54:3'): constants can be lifted to the appropriate level
Error in `call@primitive[["backward"]]`: Rule backward not defined for primitive power
Backtrace:
     x
  1. \-jit(gradient(f, wrt = "x"))(nv_scalar(2)) at test-api-jit.R:54:3
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-anvil (local) `<fn>`(x = `<anvl::GB>`)
  7.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8.           +-rlang::exec(...) at anvil/R/pullback.R:45:5
  9.           +-call@primitive[["backward"]]
 10.           \-anvil (local) `[[.anvil::Primitive`(call@primitive, "backward")
 11.             \-cli::cli_abort("Rule {name} not defined for primitive {x@name}") at anvil/R/primitives.R:42:5
 12.               \-rlang::abort(...)

Error ('test-api-jit.R:61:3'): wrt non-existent argument
Error in `build_gradient_graph(fwd_graph, wrt)`: Pullback can only be computed for functions that return a scalar
Backtrace:
     x
  1. +-testthat::expect_error(...) at test-api-jit.R:61:3
  2. | \-testthat:::expect_condition_matching(...)
  3. |   \-testthat:::quasi_capture(...)
  4. |     +-testthat (local) .capture(...)
  5. |     | \-base::withCallingHandlers(...)
  6. |     \-rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  7. \-jit(gradient(f, wrt = "y"))(nv_tensor(2))
  8.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  9.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
 10.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
 11.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
 12.       \-anvil (local) `<fn>`(x = `<anvl::GB>`)
 13.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
 14.           \-cli::cli_abort("Pullback can only be computed for functions that return a scalar") at anvil/R/pullback.R:12:5
 15.             \-rlang::abort(...)

Error ('test-api-pullback.R:8:3'): nv_mean
Error in `call@primitive[["backward"]]`: Rule backward not defined for primitive divide
Backtrace:
     x
  1. \-jit(gradient(f, wrt = "alpha"))(y, alpha) at test-api-pullback.R:8:3
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-anvil (local) `<fn>`(y = `<anvl::GB>`, alpha = `<anvl::GB>`)
  7.         \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8.           +-rlang::exec(...) at anvil/R/pullback.R:45:5
  9.           +-call@primitive[["backward"]] at anvil/R/pullback.R:45:5
 10.           \-anvil (local) `[[.anvil::Primitive`(call@primitive, "backward") at anvil/R/pullback.R:45:5
 11.             \-cli::cli_abort("Rule {name} not defined for primitive {x@name}") at anvil/R/primitives.R:42:5
 12.               \-rlang::abort(...)

Error ('test-gradient.R:6:3'): gradient: simple example
Error: <anvil::mut<Graph>>@outputs must only contain elements of class <anvil::mut<GraphVariable>> or <anvil::mut<GraphConstant>>
Backtrace:
     x
  1. +-anvil (local) g(nv_scalar(1), nv_scalar(2)) at test-gradient.R:6:3
  2. | \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3. |   +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4. |   \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5. |     +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6. |     \-anvil (local) `<fn>`(x = `<anvl::GB>`, y = `<anvl::GB>`)
  7. |       \-anvil:::build_gradient_graph(fwd_graph, wrt) at anvil/R/pullback.R:92:5
  8. |         +-base::`@<-`(`*tmp*`, "outputs", value = input_grads) at anvil/R/pullback.R:68:3
  9. |         \-S7:::`@<-.S7_object`(`*tmp*`, "outputs", value = input_grads) at anvil/R/pullback.R:68:3
 10. \-anvil (local) `<fn>`(`<anv::<G>>`, `<list>`)
 11.   \-S7::`prop<-`(`*tmp*`, name, value = `<list>`) at anvil/R/mut.R:34:7

Error ('test-gradient.R:16:3'): gradient: does not depend on input
Error in `FUN(X[[i]], ...)`: All arguments must be FuncVariables
Backtrace:
    x
 1. \-anvil (local) g(nv_scalar(1), nv_scalar(2)) at test-gradient.R:16:3
 2.   \-anvil::stablehlo(graph) at anvil/R/jit.R:64:5
 3.     +-base::do.call(stablehlo::hlo_return, outputs) at anvil/R/stablehlo.R:44:3
 4.     \-stablehlo (local) `<fn>`(NULL)
 5.       \-stablehlo:::hlo_return_impl(values = dots)
 6.         \-base::lapply(...)
 7.           \-stablehlo (local) FUN(X[[i]], ...)
 8.             \-cli::cli_abort("All arguments must be FuncVariables")
 9.               \-rlang::abort(...)

Error ('test-gradient.R:35:1'): (code run outside of `test_that()`)
Error in `eval(code, test_env)`: '...' used in an incorrect context

Error ('test-jit.R:199:3'): HloBox printer
Error in `HloInterpreter(main = local_main(HloInterpreter, global_data = func))`: could not find function "HloInterpreter"

Error ('test-primitives-jit.R:96:5'): p_if
Error in `graph@constants`: no applicable method for `@` applied to an object of class "anvil::FlattenedFunction"
Backtrace:
     x
  1. +-testthat::expect_equal(f(nv_scalar(TRUE), nv_scalar(2)), list(list(nv_scalar(2)))) at test-primitives-jit.R:98:3
  2. | \-testthat::quasi_label(enquo(object), label, arg = "object")
  3. |   \-rlang::eval_bare(expr, quo_get_env(quo))
  4. \-anvil (local) f(nv_scalar(TRUE), nv_scalar(2))
  5.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  6.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  7.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  8.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  9.       \-anvil (local) `<fn>`(pred = `<anvl::GB>`, x = `<anvl::GB>`)
 10.         \-anvil:::nvl_if(pred, list(list(x)), list(list(x * x))) at test-primitives-jit.R:96:5
 11.           \-anvil::stablehlo(true_fn, list()) at anvil/R/primitives.R:370:3

Error ('test-primitives-jit.R:118:5'): error when multiplying lists in if-statement
Error in `graph@constants`: no applicable method for `@` applied to an object of class "anvil::FlattenedFunction"
Backtrace:
     x
  1. +-testthat::expect_error(...) at test-primitives-jit.R:120:3
  2. | \-testthat:::expect_condition_matching(...)
  3. |   \-testthat:::quasi_capture(...)
  4. |     +-testthat (local) .capture(...)
  5. |     | \-base::withCallingHandlers(...)
  6. |     \-rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  7. \-anvil (local) f(nv_scalar(FALSE), list(nv_scalar(2)))
  8.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  9.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
 10.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
 11.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
 12.       \-anvil (local) `<fn>`(pred = `<anvl::GB>`, x = `<list>`)
 13.         \-anvil:::nvl_if(pred, x + x, x * x) at test-primitives-jit.R:118:5
 14.           \-anvil::stablehlo(true_fn, list()) at anvil/R/primitives.R:370:3

Error ('test-primitives-jit.R:131:3'): p_neg
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_neg, torch::torch_neg, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_neg, list(operand)) at anvil/R/primitives.R:67:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_not
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_not, function(x) !x, c(2, 3), dtype = "pred")
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_not, list(operand)) at anvil/R/primitives.R:248:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_abs
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_abs, torch::torch_abs, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_abs, list(operand)) at anvil/R/primitives.R:285:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_sqrt
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(...)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_sqrt, list(operand)) at anvil/R/primitives.R:290:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_rsqrt
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(...)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_rsqrt, list(operand)) at anvil/R/primitives.R:295:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_log
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_log, torch::torch_log, c(2, 3), non_negative = TRUE)
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_log, list(operand)) at anvil/R/primitives.R:300:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_tanh
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_tanh, torch::torch_tanh, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_tanh, list(operand)) at anvil/R/primitives.R:305:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_tan
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_tan, torch::torch_tan, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_tan, list(operand)) at anvil/R/primitives.R:310:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_floor
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_floor, torch::torch_floor, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_floor, list(operand)) at anvil/R/primitives.R:315:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_ceil
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_ceil, torch::torch_ceil, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_ceil, list(operand)) at anvil/R/primitives.R:320:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_sign
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_sign, torch::torch_sign, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_sign, list(operand)) at anvil/R/primitives.R:325:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_exp
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nvl_exp, torch::torch_exp, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-anvil (local) `<fn>`(`<anvl::GB>`)
 11.             \-anvil:::graph_call(p_exp, list(operand)) at anvil/R/primitives.R:330:3
 12.               \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 13.                 \-anvil (local) FUN(X[[i]], ...)
 14.                   \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_round
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nv_even, th_even, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-`<fn>`(`<anvl::GB>`)
 11.             \-anvil:::nvl_round(a, method = "nearest_even")
 12.               \-anvil:::graph_call(p_round, list(operand), list(method = method)) at anvil/R/primitives.R:338:3
 13.                 \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 14.                   \-anvil (local) FUN(X[[i]], ...)
 15.                     \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_convert
Error in `FUN(X[[i]], ...)`: inherits(x, stablehlo::ValueType) is not TRUE
Backtrace:
     x
  1. \-global expect_jit_torch_unary(nv_fun, th_fun, c(2, 3))
  2.   +-base::do.call(f, c(list(x_nv), args_list))
  3.   \-anvil (local) `<fn>`(`<AnvlTnsr>`)
  4.     \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  5.       +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  6.       \-anvil (local) `<anvl::FF>`(`<anvl::GB>`)
  7.         +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  8.         \-`<fn>`(a = `<anvl::GB>`)
  9.           +-base::do.call(nv_fun, c(list(a), list(...)))
 10.           \-`<fn>`(`<anvl::GB>`)
 11.             \-anvil:::nvl_convert(a, "f64")
 12.               \-anvil:::graph_call(p_convert, list(operand), params = list(dtype = dtype)) at anvil/R/primitives.R:345:3
 13.                 \-base::lapply(outputs, vt2st) at anvil/R/graph.R:431:3
 14.                   \-anvil (local) FUN(X[[i]], ...)
 15.                     \-base::stopifnot(inherits(x, stablehlo::ValueType)) at anvil/R/type-converters.R:29:3

Error ('test-primitives-jit.R:131:3'): p_dot_general
Error in `stablehlo::infer_types_generic_biv(lhs, rhs)`: lhs@type == rhs@type is not TRUE
Backtrace:
     x
  1. \-jit(function(a, b) {...
  2.   \-anvil:::graphify(f, args) at anvil/R/jit.R:62:5
  3.     +-base::do.call(f_flat, inputs_flat) at anvil/R/graph.R:208:3
  4.     \-anvil (local) `<anvl::FF>`(`<anvl::GB>`, `<anvl::GB>`)
  5.       +-base::do.call(f_orig, args) at anvil/R/flatten.R:15:5
  6.       \-`<fn>`(a = `<anvl::GB>`, b = `<anvl::GB>`)
  7.         \-anvil:::nvl_dot_general(...)
  8.           \-anvil:::graph_call(...) at anvil/R/primitives.R:93:3
  9.             +-rlang::exec(prim[["graph"]], !!!c(vts_in, params)) at anvil/R/graph.R:430:3
 10.             \-anvil (local) `<fn>`(...)
 11.               \-anvil:::graph_rule_binary(lhs, rhs) at anvil/R/rules-graph.R:197:3
 12.                 \-stablehlo::infer_types_generic_biv(lhs, rhs) at anvil/R/rules-graph.R:5:3
 13.                   \-base::stopifnot(lhs@type == rhs@type)

[ FAIL 24 | WARN 0 | SKIP 2 | PASS 102 ]
== Terminated early ============================================================
> 
