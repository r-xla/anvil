% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/primitives.R
\name{nvl_scatter}
\alias{nvl_scatter}
\title{Primitive Scatter}
\usage{
nvl_scatter(
  input,
  scatter_indices,
  update,
  update_window_dims,
  inserted_window_dims,
  input_batching_dims,
  scatter_indices_batching_dims,
  scatter_dims_to_operand_dims,
  index_vector_dim,
  indices_are_sorted = FALSE,
  unique_indices = FALSE,
  update_computation = NULL
)
}
\arguments{
\item{input}{(\code{\link{tensorish}})\cr
Input tensor to scatter into.}

\item{scatter_indices}{(\code{\link{tensorish}} of integer type)\cr
Indices tensor.}

\item{update}{(\code{\link{tensorish}})\cr
Update values tensor.}

\item{update_window_dims}{(\code{integer()})\cr
Update window dimensions.}

\item{inserted_window_dims}{(\code{integer()})\cr
Inserted window dimensions.}

\item{input_batching_dims}{(\code{integer()})\cr
Input batching dimensions.}

\item{scatter_indices_batching_dims}{(\code{integer()})\cr
Scatter indices batching dimensions.}

\item{scatter_dims_to_operand_dims}{(\code{integer()})\cr
Mapping from scatter indices to operand dimensions.}

\item{index_vector_dim}{(\code{integer(1)})\cr
Dimension in scatter_indices containing the index vectors.}

\item{indices_are_sorted}{(\code{logical(1)})\cr
Whether indices are sorted.}

\item{unique_indices}{(\code{logical(1)})\cr
Whether indices are unique.}

\item{update_computation}{(\code{function})\cr
Binary function to combine existing and update values.}
}
\value{
\code{\link{tensorish}}
}
\description{
Produces a result tensor equal to the input tensor except that
slices specified by scatter_indices are updated with values from the update tensor.
}
\section{Shapes}{

Output has the same shape as \code{input}. See \code{\link[stablehlo:hlo_scatter]{stablehlo::hlo_scatter()}} for detailed dimension constraints on \code{scatter_indices}, \code{update}, and the dimension mapping parameters.
}

\section{StableHLO}{

Calls \code{\link[stablehlo:hlo_scatter]{stablehlo::hlo_scatter()}}.
}

\examples{
\dontrun{
jit_eval({
  input <- nv_tensor(c(0, 0, 0, 0, 0))
  indices <- nv_tensor(matrix(c(1L, 3L), ncol = 1))
  updates <- nv_tensor(c(10, 30))
  nvl_scatter(
    input, indices, updates,
    update_window_dims = integer(0),
    inserted_window_dims = 1L,
    input_batching_dims = integer(0),
    scatter_indices_batching_dims = integer(0),
    scatter_dims_to_operand_dims = 1L,
    index_vector_dim = 2L
  )
})
}
}
