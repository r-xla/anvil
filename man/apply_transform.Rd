% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph.R
\name{apply_transform}
\alias{apply_transform}
\title{Transform a graph}
\usage{
apply_transform(gt, args)
}
\arguments{
\item{args}{(\verb{list(<any>)})\cr
The inputs to the transformation.}

\item{x}{(\code{GraphTransformation})\cr
The transformation to apply.}
}
\value{
(\verb{list(GraphTransformation | Graph, list(<any>))})\cr
The transformed graph(-transformation) and (possibly transformed) input values.
}
\description{
Apply a given transformation using the provided inputs.
}
\section{Adding a new Transformation}{

In order to create a new transformatin, you need to:
\enumerate{
\item Create a custom subclass of \code{GraphTransformation}.
\item Create a transformation function (like \code{gradient()}) that returns this subclass.
\item Implement the \code{apply_transform()} method for this subclass.
This is where the real complexity lies.
Here, you can assume that the \verb{@inputs} field is a \code{\link{Graph}}, as recursion and conversion
from a \code{function} to a \code{\link{Graph}} is handled by the generic.
}

\strong{Modifying Inputs or Outputs}:
When implementing a new transformation that modified the inputs or outputs of the graph,
it's important to ensure that \code{in_tree} and \code{out_tree} are updated accordingly.

TODO:
}

