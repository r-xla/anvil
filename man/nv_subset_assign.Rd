% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api-subset.R
\name{nv_subset_assign}
\alias{nv_subset_assign}
\title{Update Subset}
\usage{
nv_subset_assign(x, ..., value)
}
\arguments{
\item{x}{(\code{\link{tensorish}})\cr
Input tensor to update.}

\item{...}{Subset specifications. Can be:
\itemize{
\item Ranges (e.g., \code{2:5}) for contiguous slices. Must be static.
\item Single integers (e.g., \code{3}) for single elements
\item \code{list(i, j, ...)} for multiple non-contiguous elements
\item Scalar tensors or 1D tensor indices for dynamic indexing
\item Missing (empty or \code{:}) to select all elements in that dimension
}}

\item{value}{(\code{\link{tensorish}})\cr
Values to write. Scalars are broadcast to the subset shape.
Non-scalar values must have a shape matching the subset shape.}
}
\value{
\code{\link{tensorish}} A new tensor with the subset updated.
}
\description{
Updates elements of a tensor at specified positions.
This has copy-on-write semantics just like for standard R arrays:
a new tensor is returned with the specified positions updated.

Unlike \code{\link[=nv_subset]{nv_subset()}}, single integer indices do \strong{not} drop dimensions here,
since the update value must match the subset's shape including all dimensions.
}
\examples{
\dontshow{if (pjrt::plugin_is_downloaded()) withAutoprint(\{ # examplesIf}
# Update a contiguous slice
jit_eval({
  x <- nv_tensor(1:10, dtype = "f32")
  nv_subset_assign(x, 2:4, value = nv_tensor(c(20, 30, 40), dtype = "f32"))
})

# Update with `[<-` syntax
jit_eval({
  x <- nv_tensor(1:10, dtype = "f32")
  x[1] <- nv_scalar(99, dtype = "f32")
  x
})
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=nv_subset]{nv_subset()}}
}
