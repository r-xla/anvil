% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api-subset.R
\name{nv_subset}
\alias{nv_subset}
\title{Subset a Tensor}
\usage{
nv_subset(x, ...)
}
\arguments{
\item{x}{(\code{\link{tensorish}})\cr
Input tensor to subset.}

\item{...}{Subset specifications. Can be:
\itemize{
\item Ranges (e.g., \code{2:5}) for contiguous slices. Must be static.
\item Single integers (e.g., \code{3}) for single elements (drops dimension)
\item \code{list(i)} for single element without dropping dimension
\item \code{list(i, j, ...)} for multiple non-contiguous elements
\item Scalar tensors for dynamic indexing (drops dimension)
\item Missing (empty or \code{:}) to select all elements in that dimension
}}
}
\value{
\code{\link{tensorish}}
}
\description{
Extracts a subset from a tensor using gather semantics.
Supports both static and dynamic indexing.

Dimension dropping behavior:
\itemize{
\item R literal indices (e.g., \code{x[1, ]}) automatically drop that dimension
\item Scalar tensor indices (0D tensors) also drop the dimension
\item To preserve a dimension when selecting a single element, use \code{list()}: \code{x[list(1), ]}
\item To select multiple non-contiguous elements, use \code{list()}: \code{x[list(1, 3, 5), ]}
\item Ranges (e.g., \code{x[1:3, ]}) never drop dimensions
\item 1D tensor indices never drop dimensions
}
}
\examples{
\dontshow{if (pjrt::plugin_is_downloaded()) withAutoprint(\{ # examplesIf}
# Scalar index drops dimension
jit_eval(nv_tensor(matrix(1:6, 2, 3))[1, ])

# Range preserves dimension
jit_eval(nv_tensor(1:10)[2:5])

# list() preserves dimension for single element
jit_eval(nv_tensor(1:10)[list(3)])

# list() selects non-contiguous elements
jit_eval(nv_tensor(1:10)[list(1, 5, 10)])
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=nv_subset_assign]{nv_subset_assign()}}
}
