% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/primitives.R
\name{nvl_dynamic_slice}
\alias{nvl_dynamic_slice}
\title{Primitive Dynamic Slice}
\usage{
nvl_dynamic_slice(operand, ..., slice_sizes)
}
\arguments{
\item{operand}{(\code{\link{tensorish}})\cr
Operand.}

\item{...}{(\code{\link{tensorish}} of integer type)\cr
Scalar start indices (1-based), one per dimension.}

\item{slice_sizes}{(\code{integer()})\cr
Size of the slice in each dimension.}
}
\value{
\code{\link{tensorish}}
}
\description{
Extracts a dynamically positioned slice from a tensor.
The start position is specified at runtime via tensor indices.
}
\section{Out Of Bounds Behavior}{

If the slice would extend beyond the bounds of the operand tensor,
the start indices are clamped so that the slice fits within the tensor.
This means that out-of-bounds indices will not cause an error, but
the effective start position may differ from the requested one.

For example, slicing a tensor of shape \code{c(10)} with \code{start_indices = 8}
and \code{slice_sizes = 5} will effectively use \code{start_indices = 6} to keep
the slice within bounds.
}

\section{Shapes}{

Each start index in \code{...} must be a scalar tensor. The number of
start indices must equal \code{rank(operand)}. \code{slice_sizes} must satisfy
\code{slice_sizes <= shape(operand)} per dimension. Output shape is
\code{slice_sizes}.
}

\section{StableHLO}{

Calls \code{\link[stablehlo:hlo_dynamic_slice]{stablehlo::hlo_dynamic_slice()}}.
}

\examples{
\dontshow{if (pjrt::plugin_is_downloaded()) withAutoprint(\{ # examplesIf}
jit_eval({
  x <- nv_tensor(1:10)
  start <- nv_scalar(3L)
  nvl_dynamic_slice(x, start, slice_sizes = 3L)
})
\dontshow{\}) # examplesIf}
}
