% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/primitives.R
\name{nvl_dynamic_update_slice}
\alias{nvl_dynamic_update_slice}
\title{Primitive Dynamic Update Slice}
\usage{
nvl_dynamic_update_slice(operand, update, ...)
}
\arguments{
\item{operand}{(\code{\link{tensorish}})\cr
Operand.}

\item{update}{(\code{\link{tensorish}})\cr
The values to write at the specified position.}

\item{...}{(\code{\link{tensorish}} of integer type)\cr
Scalar start indices (1-based), one per dimension.}
}
\value{
\code{\link{tensorish}}
}
\description{
Updates a dynamically positioned slice in a tensor.
The start position is specified at runtime via tensor indices.
}
\section{Shapes}{

\code{update} must have the same rank as \code{operand}, with \code{shape(update) <= shape(operand)} per dimension. Each start index in \code{...} must be a scalar tensor. The output has the same shape as \code{operand}.
}

\section{StableHLO}{

Calls \code{\link[stablehlo:hlo_dynamic_update_slice]{stablehlo::hlo_dynamic_update_slice()}}.
}

\section{Out Of Bounds Behavior}{

If the slice would extend beyond the bounds of the operand tensor,
the start indices are clamped so that the slice fits within the tensor.
This means that out-of-bounds indices will not cause an error, but
the effective start position may differ from the requested one.

For example, slicing a tensor of shape \code{c(10)} with \code{start_indices = 8}
and \code{slice_sizes = 5} will effectively use \code{start_indices = 6} to keep
the slice within bounds.
}

\examples{
\dontshow{if (pjrt::plugin_is_downloaded()) withAutoprint(\{ # examplesIf}
jit_eval({
  x <- nv_tensor(1:5)
  update <- nv_tensor(c(10L, 20L))
  start <- nv_scalar(2L)
  nvl_dynamic_update_slice(x, update, start)
})
\dontshow{\}) # examplesIf}
}
