[{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"NA","text":"anvil code transformation framework similar jax R. currently support jit compilation automatic differentiation.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"build-and-install","dir":"","previous_headings":"Development Commands","what":"Build and Install","title":"NA","text":"","code":"# Load the package for development devtools::load_all()  # Install the package devtools::install()  # Build the package (creates tar.gz file) devtools::build()"},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"NA","text":"","code":"# Run all tests devtools::test()  # Run a specific test file testthat::test_file(\"tests/testthat/test-constant.R\")"},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"testing-guidelines","dir":"","previous_headings":"Development Commands","what":"Testing Guidelines","title":"NA","text":"rule primitive tested. Many tests can implemented comparing corresponding torch function (inst/extra-tests/test-primitives-stablehlo-torch.R inst/extra-tests/test-primitives-backward-torch.R, …). sourced test-primitives-stablehlo.R test-primitives-backward.R, etc.. Implement test comparing torch, possible necessary. test simple, functionality covered torch, implement test manually. Implement either torch test manual test, .","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"documentation","dir":"","previous_headings":"Development Commands","what":"Documentation","title":"NA","text":"writing roxygen2 documentation primitives API functions: mention “1-based” indexing documentation. Since R package, 1-based indexing default stating redundant. Check man-roxygen/ directory existing templates (e.g. param_operand.R, param_shape.R, param_dtype.R, param_ambiguous.R, params_lhs_rhs.R, section_rules.R, section_shapes_binary.R, etc.). Use @template avoid duplicating common parameter descriptions. template generic specific primitive (e.g. operand specific dtype constraints), write @param inline instead using template. Use @templateVar primitive_id <name> @template section_rules auto-generate “Implemented Rules” section. Use @rdname @inheritParams inherit documentation related functions possible, avoiding duplication across nvl_* nv_* variants.","code":"# Generate documentation from roxygen comments devtools::document()"},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"check","dir":"","previous_headings":"Development Commands","what":"Check","title":"NA","text":"","code":"# Run checks for CRAN compliance devtools::check()"},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"development-practices","dir":"","previous_headings":"","what":"Development Practices","title":"NA","text":"Use S3 (object-oriented system) defining types classes. Follow established pattern adding new operations types Add tests tests/testthat/ Document functions roxygen2 comments","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"project-information","dir":"","previous_headings":"","what":"Project Information","title":"NA","text":"stablehlo (jit interpretation rules) uses 0-based indexing, anvil uses 1-based indexing. implementing jit interpretation rule, convert indices subtracting 1. rules-pullback.R file contains differentiation rules primitive operations. , grad gradient terminal output respect function’s output function return gradient terminal output respect inputs. tests file insts/extra-tests/test-primitives-pullback-torch.R","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"comments","dir":"","previous_headings":"","what":"Comments","title":"NA","text":"add comments code self-explanatory. length-1 vectors, don’t use c(). example, use 1L instead c(1L).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"adding-a-primitive","dir":"","previous_headings":"","what":"Adding a Primitive","title":"NA","text":"functions prefixed nvl_ primitives defined primitives.R. implementing primitive, make sure inference function propagates ambiguity inputs output. Also, check whether stablehlo package corresponding inference function can wrapped. Pay attention stablehlo uses 0-based indexing, anvil uses 1-based indexing.","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"adding-an-api-function","dir":"","previous_headings":"","what":"Adding an API function","title":"NA","text":"API functions prefixed nv_ defined files like api.R api-rng.R. Often, wrap primitives, make convenient use. accessing properties tensorish values, use shape_abstract, ndims_abstract, dtype_abstract. accessors currently available.","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"nse-and-tracing","dir":"","previous_headings":"","what":"NSE and Tracing","title":"NA","text":"Whenever combining non-standard evaluation (NSE) tracing sub-graphs, need force() tensorish inputs, accidentally embedded sub-graphdescriptor. can happen R, evaluation promises function calls delayed actually needed, causes hard--debug errors.","code":""},{"path":"https://r-xla.github.io/anvil/AGENTS.html","id":"pkgdown","dir":"","previous_headings":"","what":"Pkgdown","title":"NA","text":"adding new exported function, ensure ’s _pkgdown.yml file.","code":""},{"path":"https://r-xla.github.io/anvil/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 anvil authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"the-anviltensor","dir":"Articles","previous_headings":"","what":"The AnvilTensor","title":"Get Started","text":"start introducing main data structure, AnvilTensor. essentially like R array, differences: supports data types, different precisions, well unsigned integers. tensor can live different devices, CPU GPU. 0-dimensional tensors can used represent scalars. can create AnvilTensor R objects using nv_tensor. , create 0-dimensional tensor (.e., scalar) holds 16-bit integer CPU. Note creation scalars, can also use nv_scalar shorthand skip specifying shape omit specifying device, CPU default. can also create higher-dimensional tensors, example 2x3 tensor single-precision floating-point numbers. Without specifying data type, default \"f32\" R doubles \"i32\" integers. as_array() function allows convert AnvilTensors back R objects. Note 0-dimensional tensors, result R vector length 1, R arrays 0 dimensions. first, working AnvilTensors may feel bit cumbersome, directly apply functions like regular R arrays. add two anvil tensors, output type output instead actual result. Read debugging vignette. order actually perform addition, need jit-compile function, cover next section.","code":"library(anvil) set.seed(42) nv_tensor(1L, dtype = \"i16\", device = \"cpu\", shape = integer()) ## AnvilTensor ##  1 ## [ CPUi16{} ] nv_scalar(1L, dtype = \"i16\") ## AnvilTensor ##  1 ## [ CPUi16{} ] x <- array(1:6, dim = c(2, 3)) y <- nv_tensor(x) y ## AnvilTensor ##  1 3 5 ##  2 4 6 ## [ CPUi32{2,3} ] as_array(y) ##      [,1] [,2] [,3] ## [1,]    1    3    5 ## [2,]    2    4    6 x + x ##      [,1] [,2] [,3] ## [1,]    2    6   10 ## [2,]    4    8   12 y + y ## i32{2,3}"},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"jit-compilation","dir":"Articles","previous_headings":"","what":"JIT Compilation","title":"Get Started","text":"order work AnvilTensors, need convert function want apply jit-compiled version via jit(). result operation AnvilTensor. can also jit-compile complex functions. , define function takes data matrix X, weight vector beta, scalar bias alpha, computes linear model output \\(y = X \\times \\beta + \\alpha\\). One restriction {anvil} function re-compiled every unique combination input types, consisting specific shape data type. demonstrate , create slightly modified version previous linear predictor function: Next, create little helper function creates example inputs different numbers observations: , call function twice data shapes. can notice see \"compiling ...\" message first time, function first compiled XLA executable, cached, executed. second time, executable retrieved cache (inputs shapes data types) executed without recompilation. executable contains operations applied AnvilTensors, contain cat() call, don’t see second time. call function data different shapes (data types), function re-compiled message re-appears. compilation step can take time, {anvil} therefore gives best results function called many times (different) input types, computation sufficiently large amortize compilation overhead.","code":"plus_jit <- jit(`+`) plus_jit(y, y) ## AnvilTensor ##   2  6 10 ##   4  8 12 ## [ CPUi32{2,3} ] linear_model_r <- function(X, beta, alpha) {   X %*% beta + alpha }  linear_model <- jit(linear_model_r)  X <- nv_tensor(rnorm(6), dtype = \"f32\", shape = c(2, 3)) beta <- nv_tensor(rnorm(3), dtype = \"f32\", shape = c(3, 1)) alpha <- nv_scalar(rnorm(1), dtype = \"f32\")  linear_model(X, beta, alpha) ## AnvilTensor ##   2.7911 ##  -1.1904 ## [ CPUf32{2,1} ] linear_model2 <- jit(function(X, beta, alpha) {   cat(\"compiling ...\\n\")   X %*% beta + alpha }) simul_data <- function(n, p) {   list(     X = nv_tensor(rnorm(n * p), dtype = \"f32\", shape = c(n, p)),     beta = nv_tensor(rnorm(p), dtype = \"f32\", shape = c(p, 1)),     alpha = nv_scalar(rnorm(1), dtype = \"f32\")   ) } do.call(linear_model2, simul_data(2, 3)) ## compiling ... ## AnvilTensor ##   4.9640 ##  -0.1413 ## [ CPUf32{2,1} ] do.call(linear_model2, simul_data(2, 3)) ## AnvilTensor ##   0.6140 ##  -2.5214 ## [ CPUf32{2,1} ] y_hat <- do.call(linear_model2, simul_data(4, 3)) ## compiling ..."},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"static-arguments","dir":"Articles","previous_headings":"JIT Compilation","what":"Static Arguments","title":"Get Started","text":"Besides AnvilTensors, jit-compiled functions can also take regular R values arguments. example, might want linear model without bias term. , add logical(1) argument with_bias function. need mark argument static, {anvil} knows treat regular R value. can now call function without bias term: Static arguments work differently AnvilTensors function re-compiled new observed value static argument, unique input type combination.","code":"linear_model3 <- jit(function(X, beta, alpha = NULL, with_bias) {   if (with_bias) {     cat(\"Compiling with bias ...\\n\")     X %*% beta + alpha   } else {     cat(\"Compiling without bias ...\\n\")     X %*% beta   } }, static = \"with_bias\") linear_model3(X, beta, with_bias = FALSE) ## Compiling without bias ... ## AnvilTensor ##   2.8538 ##  -1.1277 ## [ CPUf32{2,1} ] linear_model3(X, beta, alpha, with_bias = TRUE) ## Compiling with bias ... ## AnvilTensor ##   2.7911 ##  -1.1904 ## [ CPUf32{2,1} ]"},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"nested-inputs-and-outputs","dir":"Articles","previous_headings":"JIT Compilation","what":"Nested Inputs and Outputs","title":"Get Started","text":"Inputs outputs can also nested data structures contain AnvilTensors, although currently support (named) lists. far, implemented prediction step linear model. One core applications {anvil} implement learning algorithms, often need gradients, well control flow. start gradients.","code":"linear_model4 <- jit(function(inputs) {   list(y_hat = inputs[[1]] %*% inputs[[2]] + inputs[[3]]) }) linear_model4(list(X, beta, alpha)) ## $y_hat ## AnvilTensor ##   2.7911 ##  -1.1904 ## [ CPUf32{2,1} ]"},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"automatic-differentiation","dir":"Articles","previous_headings":"","what":"Automatic Differentiation","title":"Get Started","text":"{anvil}, can easily obtain gradient function scalar-valued function via gradient(). Currently, don’t support jacobians hessians, hopefilly added future. , implement loss function linear model. now need target variables y, simulate data linear model:  Next, randomly initialize model parameters: can now define function prediction calculates loss. Note calling original R function prediction jit-compiled version. Using gradient() transformation, can automatically obtain gradient function model_loss respect arguments, specify. Finally, define update step weights using gradient descent. already allows us fit linear model  might seem like reasonable solution, continuously switches R interpreter XLA runtime. Moreover, allocate new tensors iteration weights. latter might big problem small models, can cause significant overhead working bigger tensors. Next, discuss control flow {anvil} address immutability.","code":"mse <- function(y_hat, y) {   mean((y_hat - y)^2.0) } beta <- rnorm(1) X <- matrix(rnorm(100), ncol = 1) alpha <- rnorm(1) y <- X %*% beta + alpha + rnorm(100, sd = 0.5) plot(X, y) X <- nv_tensor(X) y <- nv_tensor(y) beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") model_loss <- function(X, beta, alpha, y) {   y_hat <- linear_model_r(X, beta, alpha)   mse(y_hat, y) } model_loss_grad <- gradient(   model_loss,   wrt = c(\"beta\", \"alpha\") ) update_weights_r <- function(X, beta, alpha, y) {   lr <- 0.1   grads <- model_loss_grad(X, beta, alpha, y)   beta_new <- beta - lr * grads$beta   alpha_new <- alpha - lr * grads$alpha   list(beta = beta_new, alpha = alpha_new) } update_weights <- jit(update_weights_r) weights <- list(beta = beta_hat, alpha = alpha_hat) for (i in 1:100) {   weights <- update_weights(X, weights$beta, weights$alpha, y) }"},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"control-flow","dir":"Articles","previous_headings":"","what":"Control Flow","title":"Get Started","text":"principle, three ways implement control-flow {anvil}: Embed jit-compiled functions inside R control-flow constructs, seen earlier. Embed R control flow inside jit-compiled function (also seen earlier linear model allowed optionally include bias term). Use special control-flow primitives provided anvil, nv_while() nv_if(). solution best depends specific scenario, cover three cases, risk bit repetitive. illustrate linear model training example earlier. first implementation already seen earlier: jit-compile update step repeatedly call R loop: simple update steps, solution can inefficient every call jit-compiled function overhead. significant overhead depends expensive call loop – expensive functions overhead becomes negligible. second approach use R loop within jit-compiled function. , loop unrolled compilation step (conditionals, one branch included executable discussed earlier). rather slow example hand, also re-compute gradient function iteration. Moreover, parameter n_steps static, means every unique value n_steps, function re-compiled different executable. Finally, third approach use nv_while function. like standard loop, anvil purely functional. function takes : initial state, (nested) list AnvilTensors. cond function, takes input current state returns logical flag indicating whether continue loop. body function, takes input current state returns new state. approach works analogously -statements, {anvil} primitive nv_if available.","code":"n_steps <- 100L beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\")  weights <- list(beta = beta_hat, alpha = alpha_hat) for (i in seq_len(n_steps)) {   weights <- update_weights(X, weights$beta, weights$alpha, y) } weights ## $beta ## AnvilTensor ##  -0.9184 ## [ CPUf32{1,1} ]  ##  ## $alpha ## AnvilTensor ##  -0.4376 ## [ CPUf32{} ] train_unrolled <- jit(function(X, beta, alpha, y, n_steps) {   lr <- nv_scalar(0.1)   for (i in seq_len(n_steps)) {     grads <- model_loss_grad(X, beta, alpha, y)     beta <- beta - lr * grads$beta     alpha <- alpha - lr * grads$alpha   }   list(beta = beta, alpha = alpha) }, static = \"n_steps\")  beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") train_unrolled(X, beta_hat, alpha_hat, y, n_steps = 10L) ## $beta ## AnvilTensor ##  -0.9600 ## [ CPUf32{1,1} ]  ##  ## $alpha ## AnvilTensor ##  -0.3703 ## [ CPUf32{} ] train_while <- jit(function(X, beta, alpha, y, n_steps) {   lr <- 0.1   nv_while(     list(beta = beta, alpha = alpha, i = nv_scalar(0L)),     \\(beta, alpha, i) i < n_steps,     \\(beta, alpha, i) {       grads <- model_loss_grad(X, beta, alpha, y)       list(         beta = beta - lr * grads$beta,         alpha = alpha - lr * grads$alpha,         i = i + 1L       )     }   ) })  beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") train_while(X, beta_hat, alpha_hat, y, nv_scalar(100L)) ## $beta ## AnvilTensor ##  -0.9184 ## [ CPUf32{1,1} ]  ##  ## $alpha ## AnvilTensor ##  -0.4376 ## [ CPUf32{} ]  ##  ## $i ## AnvilTensor ##  100 ## [ CPUi32{} ]"},{"path":"https://r-xla.github.io/anvil/articles/anvil.html","id":"immutability","dir":"Articles","previous_headings":"","what":"Immutability","title":"Get Started","text":"AnvilTensor objects immutable, .e., created, value changed. words, conceptually -place updates like x[1] <- x[1] + 1. means {anvil} follows value semantics, .e., functions pure. Naturally, raises question impacts performance. need distinguish two scenarios: Updating AnvilTensor “lives within” jit-compiled function. Updating AnvilTensor “living R” jit-compiled function. first scenario, nothing worry . XLA compiler able optimize , ensuring unnecessary copies actually made. similar copy--write semantics R. evaluate x <- 1:10; y <- x, conceptually creating copy x assigning y, internally, optimized away copy created modifying y x. {anvil} uses compilation shapes known compile time, can make many optimizations, minimizing unnecessary copies much possible. However, also case one calls {anvil} function R code, done initial linear model example. assignment outputs {anvil} function R variables happen within executable, XLA compiler optimize . know inputs {anvil} function needed anymore function call (case “update-calls” like ), can mark “donatable” jit-compiling. tell XLA compiler longer need inputs alpha beta afterwards, underlying memory can reused. now print input weights, get error tensors deleted. new weights still .","code":"weights <- update_weights(X, weights$beta, weights$alpha, y) update_weights_donatable <- jit(update_weights_r, donate = c(\"beta\", \"alpha\")) weights_out <- update_weights_donatable(X, weights$beta, weights$alpha, y) weights ## $beta ## AnvilTensor ## Error: ## ! ToLiteral() called on deleted or donated buffer: INVALID_ARGUMENT: Buffer has been deleted or donated. weights_out ## $beta ## AnvilTensor ##  -0.9184 ## [ CPUf32{1,1} ]  ##  ## $alpha ## AnvilTensor ##  -0.4376 ## [ CPUf32{} ]"},{"path":"https://r-xla.github.io/anvil/articles/debugging.html","id":"debug-mode","dir":"Articles","previous_headings":"","what":"Debug Mode","title":"Debugging","text":"{anvil} functions executed without wrapped jit(), run debug mode output DebugBox object, essentially represents type output tensor. use debug mode, can pass AnvilTensor literals (1L, 1.0). want specify abstract types, can also directly pass DebugBox objects: can even evaluate transformations like gradients debug mode: happens R interpreter, can also add breakpoints code step identify bugs. However, subtleties aware using debug mode, cover next section. ## debug mode actually ? cases, debug mode work exactly expected. However, one subtlety aware . Consider function : run debug mode, even R literal, get expected type: However, wrap jit(), throws error, 1 AnvilTensor. , debug mode emulates happen function call within jit-compiled function: Note {anvil}, allow conversion R literals AnvilTensors passed primitive functions, input arguments jit-compiled functions, blur distinction literals 0-dimensional AnvilTensors. However, even program valid can compiled, might work expected, e.g. logical bugs invalid hyperparameters. , ’s important monitor (intermediate) values, cover next section.","code":"library(anvil) y <- nv_scalar(1) + nv_tensor(1:4, shape = c(2, 2)) y ## f32{2,2} mean(y) ## f32{} 1 + nv_scalar(1) ## f32{} debug_box(\"f32\", c(2, 3)) %*% debug_box(\"f32\", c(3, 1)) ## f32{2,1} gradient(mean)(debug_box(\"f32\", c(2, 2))) ## $x ## f32{2,2} f <- function(x) {   nv_negate(x) } f(1) ## f32?{} jit(f)(1) ## Error: ## ! Expected AnvilTensor, but got <numeric> jit(\\() f(1))() ## AnvilTensor ##  -1 ## [ CPUf32?{} ]"},{"path":"https://r-xla.github.io/anvil/articles/debugging.html","id":"printing-values","dir":"Articles","previous_headings":"","what":"Printing Values","title":"Debugging","text":"different ways print values {anvil} might confusing first. start naive way simply inserting print() statements code jit-compiled function. run function, see actual value printed, GraphBox object. GraphBox object passed around tracing can convert function AnvilGraph subsequently compiled. Furthermore, call function identical input types, won’t printed executable retrieved cache. want get actual content values execution, two options: Ensure value print returned jit-compiled function can printed execution. comes naturally jit-compiled function called within R loop. Using special nv_print() function print execution. useful value print naturally returned function. illustrative purposes, count 10 print intermediate results. first approach, jit-compile update function iteratively call R loop. second approach, use nv_while implement loop. provide formatting options future!","code":"f_jit <- jit(\\(x) {   y <- x^2 + x^2   print(y)   mean(y) }) f_jit(nv_tensor(1:4, shape = c(2, 2))) ## GraphBox(GraphValue(AbstractTensor(dtype=f32?, shape=2x2))) ## AnvilTensor ##  15 ## [ CPUf32?{} ] f_jit(nv_tensor(0:3, shape = c(2, 2))) ## AnvilTensor ##  7 ## [ CPUf32?{} ] add_one <- jit(\\(x) x + 1L) x <- nv_scalar(0L) for (i in 1:10) {   x <- add_one(x)   print(x) } ## AnvilTensor ##  1 ## [ CPUi32{} ]  ## AnvilTensor ##  2 ## [ CPUi32{} ]  ## AnvilTensor ##  3 ## [ CPUi32{} ]  ## AnvilTensor ##  4 ## [ CPUi32{} ]  ## AnvilTensor ##  5 ## [ CPUi32{} ]  ## AnvilTensor ##  6 ## [ CPUi32{} ]  ## AnvilTensor ##  7 ## [ CPUi32{} ]  ## AnvilTensor ##  8 ## [ CPUi32{} ]  ## AnvilTensor ##  9 ## [ CPUi32{} ]  ## AnvilTensor ##  10 ## [ CPUi32{} ] jit(\\() {   init <- nv_fill(1L, shape = c())   nv_while(     list(x = init),     \\(x) x <= 10,     \\(x) {       nv_print(x)       list(x = x + 1L)     }   ) }, device = \"cpu\")() ## AnvilTensor ##  1 ## [ i32{} ] ## AnvilTensor ##  2 ## [ i32{} ] ## AnvilTensor ##  3 ## [ i32{} ] ## AnvilTensor ##  4 ## [ i32{} ] ## AnvilTensor ##  5 ## [ i32{} ] ## AnvilTensor ##  6 ## [ i32{} ] ## AnvilTensor ##  7 ## [ i32{} ] ## AnvilTensor ##  8 ## [ i32{} ] ## AnvilTensor ##  9 ## [ i32{} ] ## AnvilTensor ##  10 ## [ i32{} ] ## $x ## AnvilTensor ##  11 ## [ CPUi32{} ]"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"transforming-code","dir":"Articles","previous_headings":"","what":"Transforming Code","title":"Internals","text":"real anvil made reshaping metal, package tool reshaping code. refer rewriting code transformation, three types: R \\(\\rightarrow\\) AnvilGraph: Generic R functions complicated handle, first step {anvil} always convert computational anvil::Graph object via tracing. AnvilGraph similar JAXExpr objects JAX. operates AnvilTensor objects applies anvil::Primitive operations . AnvilGraph \\(\\rightarrow\\) AnvilGraph: possible transform AnvilGraphs AnvilGraphs. purpose change functionality code. time writing, essentially one transformation, namely backward-mode automatic differentiation via gradient(). AnvilGraph \\(\\rightarrow\\) Executable: order perform actual computation, AnvilGraph needs converted executable. Currently, support XLA backend (via stablehlo pjrt), working experimental quickr backend.","code":""},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"tracing-r-functions-into-graphs","dir":"Articles","previous_headings":"Transforming Code","what":"Tracing R Functions into Graphs","title":"Internals","text":"functionality {anvil} package centered around anvil::Graph class. principle possible create AnvilGraphs hand, usually created tracing R functions. general, want convert code another form (case, R Code AnvilGraph), two approaches: Static analysis, require operating abstract syntax tree (AST) code. Dynamic analysis (aka “tracing”), executes code records selected operations. former approach followed {quickr} package, go tracing. start simple, yet illustrative example either adds multiplies two inputs x y depending value op. , use anvil::trace_fn(), takes R function list AbstractTensor inputs specify types inputs. output trace_fn() now AnvilGraph object represents computation. fields AnvilGraph : inputs, GraphNodes represent inputs function. outputs, GraphNodes represent outputs function. calls, PrimitiveCalls take GraphNodes (parameters) produce output GraphNodes. in_tree, out_tree, cover later (??) happens trace_fn() new GraphDescriptor created inputs x y converted anvil::GraphBox objects. , function f simply evaluated GraphBox objects inputs. evaluation, need distinguish two cases: “standard” R function called: , nothing special happens function simply evaluated. anvil function called: , operation underlies function recorded GraphDescriptor. evaluation statement example first category. set op = \"mul\", second branch executed. , calling nv_mul, attaches PrimitiveCall represents multiplication two tensors $calls GraphDescriptor. Note nv_mul primitive, performs type promotion broadcasting needed, calling primitive nvl_mul(). PrimitiveCall object consists following fields: primitive: primitive function called. inputs: inputs primitive function. params: parameters (non-tensors) primitive function. outputs: outputs primitive function. evaluation f complete, $outputs field GraphDescriptor set AnvilGraph subsequently created GraphDescriptor. difference AnvilGraph GraphDescriptor latter utility fields useful graph creation, purposes tutorial, can think .","code":"library(anvil) f <- function(x, y, op) {   if (op == \"add\") {     nv_add(x, y)   } else if (op == \"mul\") {     nv_mul(x, y)   } else {     stop(\"Unsupported operation\")   } } aten <- nv_aten(\"f32\", c()) aten ## AbstractTensor(dtype=f32, shape=) graph <- trace_fn(f, list(x = aten, y = aten, op = \"mul\")) graph ## <AnvilGraph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Body: ##     %1: f32[] = mul(%x1, %x2) ##   Outputs: ##     %1: f32[]"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"transforming-graphs-into-other-graphs","dir":"Articles","previous_headings":"Transforming Code","what":"Transforming Graphs into other Graphs","title":"Internals","text":"R function staged simpler format, ready transformed. {anvil} package way dictate AnvilGraph AnvilGraph transformation can implemented. interesting transformations, however, need store information {anvil} primitive function. case gradient, need store derivative rules. , anvil::Primitive objects $rules field can populated. derivative rules stored functions \"backward\" name. can access primitive ’s name via prim() function: anvil::transform_gradient function uses rules compute gradient function. specific transformation, walking graph backwards apply derivative rules, append “backward pass” graph. Besides forward graph, transformation takes wrt argument, specifies respect arguments compute gradient.","code":"prim(\"mul\")$rules[[\"backward\"]] ## function (inputs, outputs, grads, .required)  ## { ##     lhs <- inputs[[1L]] ##     rhs <- inputs[[2L]] ##     grad <- grads[[1L]] ##     list(if (.required[[1L]]) nvl_mul(grad, rhs), if (.required[[2L]]) nvl_mul(grad,  ##         lhs)) ## } ## <bytecode: 0x55bdc65a38c8> ## <environment: namespace:anvil> bwd_graph <- transform_gradient(graph, wrt = c(\"x\", \"y\")) bwd_graph ## <AnvilGraph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Constants: ##     %c1: f32[] ##   Body: ##     %1: f32[] = mul(%x1, %x2) ##     %2: f32[] = mul(%c1, %x2) ##     %3: f32[] = mul(%c1, %x1) ##   Outputs: ##     %2: f32[] ##     %3: f32[]"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"lowering-a-graph","dir":"Articles","previous_headings":"Transforming Code","what":"Lowering a Graph","title":"Internals","text":"order execute AnvilGraph, need convert – wait – executable. , show compile using XLA backend. First, translate AnvilGraph StableHLO representation via {stablehlo} package. , compile program using XLA compiler accessible via {pjrt} package. Like gradient transformation, rules transformation stored $rules fields primitives. anvil::stablehlo function create stablehlo::Func object sequentially translate PrimitiveCalls StableHLO operations. Now, can compile function via pjrt_compile(). run function, need extract underlying buffers tensors passing executable, output PJRTBuffer can easily convert AnvilTensor.","code":"prim(\"mul\")$rules[[\"stablehlo\"]] ## function (lhs, rhs)  ## { ##     list(stablehlo::hlo_multiply(lhs, rhs)) ## } ## <bytecode: 0x55bdc65a6a80> ## <environment: namespace:anvil> func <- stablehlo(graph)[[1L]] func ## func.func @main (%0: tensor<f32>, %1: tensor<f32>) -> tensor<f32> { ## %2 = \"stablehlo.multiply\" (%0, %1): (tensor<f32>, tensor<f32>) -> (tensor<f32>) ## \"func.return\"(%2): (tensor<f32>) -> () ## } hlo_str <- stablehlo::repr(func) program <- pjrt::pjrt_program(src = hlo_str, format = \"mlir\") exec <- pjrt::pjrt_compile(program) x <- nv_scalar(3, \"f32\") y <- nv_scalar(4, \"f32\") out <- pjrt::pjrt_execute(exec, x$tensor, y$tensor) out ## PJRTBuffer  ##  12 ## [ CPUf32{} ] nv_tensor(out) ## AnvilTensor ##  12 ## [ CPUf32{} ]"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"the-user-interface","dir":"Articles","previous_headings":"","what":"The User Interface","title":"Internals","text":"previous section, shown transformations implemented hood. actual user interface little convenient follows JAX interface.","code":""},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"jit","dir":"Articles","previous_headings":"The User Interface","what":"jit()","title":"Internals","text":"jit() function allows convert regular R function Just--Time compiled function can executed AnvilTensors. apply simple example function, mark non-tensor parameter op “static”. means value parameter needs known compile time. One might think jit() first calls trace_fn(), runs stablehlo(), followed pjrt_compile(). , however, happening, requires input types known. Instead, f_jit “lazy” function perform steps inputs provided. However, steps applied every time f_jit function called, inefficient, tracing compiling takes time. Therefore, function f_jit also contains cache (implemented xlamisc::LRUCache), check whether already compiled executable given inputs. , types AnvilTensors need match exactly (data type shape) static arguments need identical. example, run function AnvilTensors type, different values, function won’t recompiled, can see checking size cache, already 1, called x y . calling tensors types identical static argument values, size cache remains 1: execute function tensors different dtype shape, function recompiled: Also, provide different values static arguments, function recompiled:","code":"f_jit <-  jit(f, static = \"op\") f_jit(x, y, \"add\") ## AnvilTensor ##  7 ## [ CPUf32{} ] cache_size <- function(f) environment(f)$cache$size cache_size(f_jit) ## [1] 1 f_jit(nv_scalar(-99, \"f32\"), nv_scalar(2, \"f32\"), \"add\") ## AnvilTensor ##  -97 ## [ CPUf32{} ] cache_size(f_jit) ## [1] 1 f_jit(nv_scalar(1, \"i32\"), nv_scalar(2, \"i32\"), \"add\") ## AnvilTensor ##  3 ## [ CPUi32{} ] cache_size(f_jit) ## [1] 2 f_jit(nv_scalar(1, \"f32\"), nv_scalar(2, \"f32\"), \"mul\") ## AnvilTensor ##  2 ## [ CPUf32{} ] cache_size(f_jit) ## [1] 3"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"gradient","dir":"Articles","previous_headings":"The User Interface","what":"gradient()","title":"Internals","text":"Just like jit(), gradient() also returns function lazily create graph transform , inputs provided. Calling g() AnvilTensors actually compute gradient, instead just output output types, c.f. debugging vignette . want actually compute gradient, need wrap jit(). Moreover, can also use g another function: , happening ? inputs x y provided h_jit, new GraphDescriptor created inputs x y converted GraphBox objects. , addition x y recorded GraphDescriptor. call g() bit involved. First, new GraphDescriptor created forward computation g recorded. Subsequently, backward pass added descriptor, converted AnvilGraph. AnvilGraph inlined parent GraphDescriptor (representing whole function h), converted main AnvilGraph. can look graph , trace_fn internally converts AnvilTensors x y abstract representation. Afterwards, graph lowered stableHLO subsequently compiled.","code":"g <- gradient(f, wrt = c(\"x\", \"y\")) g(x, y, \"add\") ## $x ## DebugBox(ConcreteTensor) ##  1 ## [ CPUf32{} ]  ##  ## $y ## DebugBox(ConcreteTensor) ##  1 ## [ CPUf32{} ] g_jit <- jit(g, static = \"op\") g_jit(x, y, \"add\") ## $x ## AnvilTensor ##  1 ## [ CPUf32{} ]  ##  ## $y ## AnvilTensor ##  1 ## [ CPUf32{} ] h <- function(x, y) {   z <- nv_add(x, y)   g(z, x, \"mul\") } h_jit <- jit(h) h_jit(x, y) ## $x ## AnvilTensor ##  3 ## [ CPUf32{} ]  ##  ## $y ## AnvilTensor ##  7 ## [ CPUf32{} ] h_graph <- trace_fn(h, list(x = x, y = y)) h_graph ## <AnvilGraph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Constants: ##     %c1: f32[] ##   Body: ##     %1: f32[] = add(%x1, %x2) ##     %2: f32[] = mul(%1, %x1) ##     %3: f32[] = mul(%c1, %x1) ##     %4: f32[] = mul(%c1, %1) ##   Outputs: ##     %3: f32[] ##     %4: f32[]"},{"path":[]},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"debug-mode","dir":"Articles","previous_headings":"More Internals","what":"Debug Mode","title":"Internals","text":"use debug mode, see debugging vignette. Debug-mode different jit-mode, don’t context can initialize main GraphDescriptor. reason, every primitive initializes GraphDescriptor thrown away primitive returns DebugBox objects. DebugBox objects user-interaction nice printer. Whenever primitive evaluated, DebugBox converted GraphBox object used actual evaluation via maybe_box_tensorish. ensures don’t duplicate evaluation logic graph-building functions work GraphBox objects. gets lost debug mode identity values, GraphDescriptor thrown away. means say anything identity values, types. Unfortunately, current mode detecting debug mode whether GraphDescriptor active. reason, don’t allow calling local_descriptor() global environment. Maybe can improve future, now seems work.","code":""},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"constant-handling","dir":"Articles","previous_headings":"More Internals","what":"Constant Handling","title":"Internals","text":"Constants handled specially {anvil}. Consider program : , y closed-constant included $constants field graph, just like literal 1. compiling program stableHLO, constants treated differently depending shape (follow JAX’s approach ). , constants 1 element inlined program, whereas constants added inputs stableHLO program. inlining large constants executable inefficient. However, didn’t inline small scalars, compiler unable constant folding. Also, compiling, remove unused constants. Captured constants can become unused apply code transformations like , gradient function w.r.t. x depend captured y: principle, compiler able , pass constants inputs program, need handle . note : R Literals immediately embedded literals program. Currently, constants value (refer different AnvilTensors) deduplicated, might change future.","code":"y <- nv_tensor(rnorm(1000000L)) graph <- trace_fn(function(x) {   x + y + 1 }, list(x = nv_scalar(1L))) graph ## <AnvilGraph> ##   Inputs: ##     %x1: i32[] ##   Constants: ##     %c1: f32[1000000] ##   Body: ##     %1: f32[] = convert [dtype = f32, ambiguous = FALSE] (%x1) ##     %2: f32[1000000] = broadcast_in_dim [shape = 1000000, broadcast_dimensions = <any>] (%1) ##     %3: f32[1000000] = add(%2, %c1) ##     %4: f32?[1000000] = broadcast_in_dim [shape = 1000000, broadcast_dimensions = <any>] (1:f32?) ##     %5: f32[1000000] = add(%3, %4) ##   Outputs: ##     %5: f32[1000000] graph$constants ## [[1]] ## GraphValue(ConcreteTensor(f32, (1000000))) out <- stablehlo(graph) out[[1L]] ## func.func @main (%0: tensor<1000000xf32>, %1: tensor<i32>) -> tensor<1000000xf32> { ## %2 = \"stablehlo.convert\" (%1): (tensor<i32>) -> (tensor<f32>) ## %3 = \"stablehlo.broadcast_in_dim\" (%2) { ## broadcast_dimensions = array<i64> ## }: (tensor<f32>) -> (tensor<1000000xf32>) ## %4 = \"stablehlo.add\" (%3, %0): (tensor<1000000xf32>, tensor<1000000xf32>) -> (tensor<1000000xf32>) ## %5 = \"stablehlo.constant\" () { ## value = dense<1.00000000e+00> : tensor<f32> ## }: () -> (tensor<f32>) ## %6 = \"stablehlo.broadcast_in_dim\" (%5) { ## broadcast_dimensions = array<i64> ## }: (tensor<f32>) -> (tensor<1000000xf32>) ## %7 = \"stablehlo.add\" (%4, %6): (tensor<1000000xf32>, tensor<1000000xf32>) -> (tensor<1000000xf32>) ## \"func.return\"(%7): (tensor<1000000xf32>) -> () ## } out[[2L]] ## [[1]] ## GraphValue(ConcreteTensor(f32, (1000000))) f <- function(x) { x + y } transform_gradient(trace_fn(f, list(x = nv_scalar(1))))"},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"nested-inputs-and-outputs","dir":"Articles","previous_headings":"More Internals","what":"Nested Inputs and Outputs","title":"Internals","text":"TODO","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/articles/internals.html","id":"literal-handling","dir":"Articles","previous_headings":"Design Decisions","what":"Literal handling","title":"Internals","text":"appealing support conversion R literals (1L, 1.0 TRUE, etc.) AnvilTensors calling jit-ted functions, .e. allow following: jit(), principle , know arguments static expected AnvilTensors. However, gradient(), don’t know arguments static . example, can’t make following work: somewhat inconsistent hard reason . Furthermore, auto-converting literals passed non-static arguments jit-ted functions also entail various suble differences debug-mode jit-mode, former top-level hook conversion. Finally, requiring user think input data types also advantageous; want prioritize clarity minor convenience. Note primitive calls like nv_tensor(1)^2 auto-convert literals, know arguments expected AnvilTensors otherwise code just becomes much harder read.","code":"jit(nv_add, static = character())(1, 2) jit(\\() {   gradient(nv_add)(1, 2) })"},{"path":"https://r-xla.github.io/anvil/articles/logistic-regression.html","id":"problem","dir":"Articles","previous_headings":"","what":"Problem","title":"Logistic Regression","text":"Logistic regression models probability observation belongs particular class. Given feature matrix \\(X\\) weight vector \\(\\beta\\), predicted probability : \\[P(y = 1 | X) = \\sigma(X \\beta + \\alpha)\\] \\(\\sigma\\) logistic function \\(\\sigma(z) = \\frac{1}{1 + e^{-z}}\\) \\(\\alpha\\) bias term. practice, logistic regression typically fitted using Iteratively Reweighted Least Squares (IRLS), form Newton’s method. , use simple gradient descept algorithm didactic purposes.","code":""},{"path":"https://r-xla.github.io/anvil/articles/logistic-regression.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Logistic Regression","text":"’ll use classic Titanic dataset base R, contains survival data famous shipwreck history. Titanic object contingency table, first expand individual observations. dataset contains 2201 observations 5 predictor variables. goal predict survival (Survived) based three categorical features: Class: Passenger class (1st, 2nd, 3rd, Crew) - encoded dummy variables 1st class reference category Sex: Male Female - encoded Male reference category Age: Child Adult - encoded Child reference category general survival rate 32.30%. Now convert data AnvilTensors.","code":"library(anvil) set.seed(42)  # Expand contingency table to individual observations titanic_df <- as.data.frame(Titanic) titanic <- titanic_df[rep(seq_len(nrow(titanic_df)), titanic_df$Freq), 1:4] rownames(titanic) <- NULL  # Create design matrix with dummy variables X <- model.matrix(~ Class + Sex + Age, data = titanic)[, -1] y <- as.integer(titanic$Survived == \"Yes\")  # Standardize features for better gradient descent convergence X <- scale(X)  n <- nrow(X) p <- ncol(X) summary(titanic) ##   Class         Sex          Age       Survived   ##  1st :325   Male  :1731   Child: 109   No :1490   ##  2nd :285   Female: 470   Adult:2092   Yes: 711   ##  3rd :706                                         ##  Crew:885 X_tensor <- nv_tensor(X, dtype = \"f32\") y_tensor <- nv_tensor(y, dtype = \"f32\", shape = c(n, 1L))"},{"path":"https://r-xla.github.io/anvil/articles/logistic-regression.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"Logistic Regression","text":"logistic regression model consists computing linear combination features applying logistic function. binary classification, use binary cross-entropy loss: \\[\\mathcal{L} = -\\frac{1}{n} \\sum_{=1}^{n} \\left[ y_i \\log(p_i) + (1 - y_i) \\log(1 - p_i) \\right]\\] need careful numerical stability computing logarithm probabilities close 0 1. ’ll add small epsilon avoid taking log exactly 0. combine prediction loss computation single function. Using {anvil}’s automatic differentiation, can obtain gradients loss respect model parameters.","code":"predict_proba <- function(X, beta, alpha) {   logits <- X %*% beta + alpha   nv_logistic(logits) } binary_cross_entropy <- function(y_true, y_pred) {   eps <- 1e-7   y_pred_clipped <- nv_clamp(eps, y_pred, 1 - eps)   loss <- -(y_true * log(y_pred_clipped) + (1 - y_true) * log(1 - y_pred_clipped))   mean(loss) } model_loss <- function(X, y, beta, alpha) {   y_pred <- predict_proba(X, beta, alpha)   binary_cross_entropy(y, y_pred) } model_loss_grad <- gradient(model_loss, wrt = c(\"beta\", \"alpha\"))"},{"path":"https://r-xla.github.io/anvil/articles/logistic-regression.html","id":"training","dir":"Articles","previous_headings":"","what":"Training","title":"Logistic Regression","text":"implement training loop using nv_while(). keeps entire training loop within single compiled function, efficient repeatedly calling JIT-compiled function R, especially small models. initialize parameters train model single function call. Let’s verify implementation comparing R’s built-glm(). Now let’s compare coefficients: estimates close, confirming gradient descent implementation converges solution glm().","code":"fit_logreg <- jit(function(X, y, beta, alpha, n_epochs, lr) {   output <- nv_while(     list(beta = beta, alpha = alpha, epoch = nv_scalar(0L)),     \\(beta, alpha, epoch) epoch < n_epochs,     \\(beta, alpha, epoch) {       grads <- model_loss_grad(X, y, beta, alpha)       list(         beta = beta - lr * grads$beta,         alpha = alpha - lr * grads$alpha,         epoch = epoch + 1L       )     }   )   list(beta = output$beta, alpha = output$alpha) }) beta_init <- nv_tensor(rnorm(p), dtype = \"f32\", shape = c(p, 1L)) alpha_init <- nv_scalar(0, dtype = \"f32\")  result <- fit_logreg(   X_tensor, y_tensor,   beta_init, alpha_init,   nv_scalar(50000L),   nv_scalar(0.1) )  result ## $beta ## AnvilTensor ##  -0.3419 ##  -0.8300 ##  -0.4206 ##   0.9920 ##  -0.2304 ## [ CPUf32{5,1} ]  ##  ## $alpha ## AnvilTensor ##  -0.8538 ## [ CPUf32{} ] glm_fit <- glm(y ~ X, family = binomial) ##     Parameter      anvil        glm ## 1 (Intercept) -0.8538059 -0.8538077 ## 2    Class2nd -0.3418888 -0.3418906 ## 3    Class3rd -0.8299901 -0.8299946 ## 4   ClassCrew -0.4206346 -0.4206313 ## 5   SexFemale  0.9919737  0.9919786 ## 6    AgeAdult -0.2303528 -0.2303616"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"adding-a-primitive-practical-example","dir":"Articles","previous_headings":"","what":"Adding a Primitive: Practical Example","title":"Adding a Primitive","text":"Let’s add new primitive step step. ’ll implement nvl_repeat_along – primitive repeats tensor multiple times along specified dimension. example, repeating c(1, 2, 3) twice along dimension 1 gives c(1, 2, 3, 1, 2, 3). primitive dynamic input (tensor) two static parameters (many times repeat dimension).","code":""},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-1-create-the-anvilprimitive-object","dir":"Articles","previous_headings":"Adding a Primitive: Practical Example","what":"Step 1: Create the AnvilPrimitive Object","title":"Adding a Primitive","text":"simply primitive object identify operation AnvilGraph hold rules lower StableHLO compute gradients.","code":"library(anvil) p_repeat_along <- AnvilPrimitive(\"repeat_along\")"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-2-define-the-nvl_-function","dir":"Articles","previous_headings":"Adding a Primitive: Practical Example","what":"Step 2: Define the nvl_* Function","title":"Adding a Primitive","text":"nvl_* function two things: Defines inference function computes output types input types Calls graph_desc_add() record operation current GraphDescriptor. Key points: inference function receives abstract tensors (types, values) dynamic inputs, actual values static parameters. must verify arguments function valid. Also, throw clear error messages arguments invalid, {anvil} programs otherwise hard debug. graph_desc_add() returns list outputs; use [[1L]] single-output primitives. Propagate ambiguous flag inputs outputs, see type promotion means. primitive wrapper around stablehlo operation, possible use corresponding inference function stablehlo package (stablehlo::infer_types_concatenate). , need : Convert abstract tensors stablehlo ValueTypes using at2vt(). Call stablehlo inference function obtain list ValueTypes. Convert ValueTypes back abstract tensors using vt2at(). Set ambiguous flag output depending inputs (ambiguity strictly {anvil} concept, stablehlo concept).","code":"nvl_repeat_along <- function(operand, times, dim) {   # type of operand is checked by graph_desc_add()   infer_fn <- function(operand, times, dim) {     if (!checkmate::test_integerish(dim, lower = 1, upper = ndims(operand), len = 1L)) {       cli::cli_abort(\"{.arg dim} must be between 1 and {ndims(operand)}, but is {.val dim}\")     }     if (!checkmate::test_integerish(times, lower = 1, len = 1L)) {       cli_abort(\"times must be a positive integer, but is {times}\")     }     new_shape <- shape(operand)     new_shape[dim] <- new_shape[dim] * times     list(AbstractTensor(       dtype = dtype(operand),       shape = Shape(new_shape),       ambiguous = operand$ambiguous     ))   }    graph_desc_add(     p_repeat_along,             # The primitive     list(operand = operand),    # Dynamic inputs (tensors)     params = list(              # Static parameters       times = times,       dim = dim     ),     infer_fn = infer_fn   )[[1L]]  # Extract single output from list }"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-3-add-the-stablehlo-rule","dir":"Articles","previous_headings":"Adding a Primitive: Practical Example","what":"Step 3: Add the StableHLO Rule","title":"Adding a Primitive","text":"StableHLO rule defines lower primitive actual operations, used stablehlo() lowering pass. implement repeat_along using concatenation: rule receives: Dynamic inputs stablehlo::FuncValues. Static parameters R values. must return list stablehlo::FuncValues, even one output. Important: StableHLO uses 0-based indexing, {anvil} uses R’s 1-based indexing. Always convert dimension indices subtracting 1. Also note graph_desc_add() converting error messages stablehlo 1-based indexing, worry .","code":"p_repeat_along[[\"stablehlo\"]] <- function(operand, times, dim) {   operands <- rep(list(operand), times)   list(rlang::exec(stablehlo::hlo_concatenate, !!!operands, dimension = dim - 1L)) }"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-4-add-the-backward-rule","dir":"Articles","previous_headings":"Adding a Primitive: Practical Example","what":"Step 4: Add the Backward Rule","title":"Adding a Primitive","text":"operation support automatic differentiation, add backward rule. idea following, assume input operand shape (s_1, ..., s_n), means output (therefore ’s gradient) shape (s_1, ..., s_{dim-1}, s_dim * times, s_{dim+1}, ..., s_n). Reshape gradient (s_1, ..., s_{dim-1}, s_dim, times, s_{dim+1}, ..., s_n). Sum times dimension drop times dimension. backward rule receives: inputs: Input GraphValues forward pass outputs: Output GraphValues forward pass grads: Gradients flowing back downstream (one per output) Static parameters name (: dim, times) .required: Logical vector indicating input gradients needed returns list one gradient per input (NULL required).","code":"p_repeat_along[[\"backward\"]] <- function(inputs, outputs, grads, dim, times, .required) {   if (!.required[[1L]]) {     return(list(NULL))   }    grad <- grads[[1L]]   operand <- inputs[[1L]]    old_shape <- shape(operand)   grad_shape <- shape(grad)    new_shape <- grad_shape   new_shape[dim] <- old_shape[dim]   new_shape <- append(new_shape, times, after = dim - 1L)    grad_reshaped <- nvl_reshape(grad, new_shape)   grad_summed <- nvl_reduce_sum(grad_reshaped, dims = dim, drop = TRUE)   list(grad_summed) }"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-5-register-the-primitive","dir":"Articles","previous_headings":"","what":"Step 5: Register the Primitive","title":"Adding a Primitive","text":"pollute global namespace, primitive objects (p_repeat_along case) exported. Instead, can retrieved via prim(\"repeat_along\"). make work, need register primitive object:","code":"register_primitive(\"repeat_along\", p_repeat_along) prim(\"repeat_along\") #> <AnvilPrimitive:repeat_along>"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"step-6-add-an-nv_-api-function","dir":"Articles","previous_headings":"Step 5: Register the Primitive","what":"Step 6: Add an nv_ API Function","title":"Adding a Primitive","text":"{anvil}, also offer convenience wrappers around primitives. example nvl_add vs nv_add, latter calls former optionally broadcasting (scalar) inputs: case, convenience needed functionality low-level (generally useful), can just reassign nvl_* function nv_* function: Note nv_* wrapper function, can access certain properties input tensorish values via: shape_abstract() ndims_abstract() dtype_abstract() ambiguous_abstract() , example, use shape() instead shape_abstract(), function won’t work R literals. .e., <extract>_abstract() first converts input AbstractTensor (possible) extracts property.","code":"nv_add(1L, nv_tensor(2:3)) #> i32{2} nvl_add(1L, nv_tensor(2:3)) #> Error in `nvl_add()`: #> ! `lhs` and `rhs` must have the same tensor type. #> ✖ Got tensor<i32> and tensor<2xi32>. nv_repeat_along <- nvl_repeat_along"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"using-your-primitive","dir":"Articles","previous_headings":"Step 5: Register the Primitive","what":"Using Your Primitive","title":"Adding a Primitive","text":"can now use primitive: compute gradients .","code":"x <- nv_tensor(c(1, 2, 3), shape = c(3, 1)) result <- jit(function(x) nvl_repeat_along(x, times = 2L, dim = 2L))(x) result #> AnvilTensor #>  1 1 #>  2 2 #>  3 3 #> [ CPUf32{3,2} ] f <- function(x) {   repeated <- nvl_repeat_along(x, times = 2L, dim = 2L)   sum(repeated) }  grad_f <- jit(gradient(f)) grad_f(x)[[1L]] #> AnvilTensor #>  2 #>  2 #>  2 #> [ CPUf32{3,1} ]"},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"contributing-to-the-package","dir":"Articles","previous_headings":"","what":"Contributing to the Package","title":"Adding a Primitive","text":"want contribute primitive {anvil}, additional things aware .","code":""},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"file-organization","dir":"Articles","previous_headings":"Contributing to the Package","what":"File Organization","title":"Adding a Primitive","text":"R/primitives.R: Define AnvilPrimitive object nvl_* function R/rules-stablehlo.R: Add StableHLO lowering rule R/rules-backward.R: Add backward rule (differentiable) R/api.R: Add nv_* wrapper function (possibly another api file).","code":""},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"testing","dir":"Articles","previous_headings":"Contributing to the Package","what":"Testing","title":"Adding a Primitive","text":"Tests can go two places: inst/extra-tests/: tests compare torch. live inst/ avoid listing torch dependency. tests/testthat/: tests without torch counterpart. Important: Test names must start \"p_<name>\" (matching primitive object name). meta tests verify every primitive corresponding tests. Since torch counterpart exists nvl_repeat_along, add manual tests : tests/testthat/test-primitives-stablehlo.R tests/testthat/test-primitives-backward.R Also, ensure linter errors present, devtools::check() passes, format code using make format.","code":""},{"path":"https://r-xla.github.io/anvil/articles/new_primitive.html","id":"higher-order-primitives","dir":"Articles","previous_headings":"","what":"Higher-Order Primitives","title":"Adding a Primitive","text":"Higher-Order Primitives primitives parameterized R function expression. Examples include nvl_if nvl_while. generally much complex handle, don’t cover detail (now). general idea, however, primitive nvl_* function needs trace provided function using trace_fn() forward graph stablehlo lowering rule backward rule.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"subsetting-1d-tensors","dir":"Articles","previous_headings":"Subsetting","what":"Subsetting 1D tensors","title":"Subsetting","text":"Let’s start simple examples selecting individual elements 1-dimension tensor. index can either static dynamic can drop keep dimension: Static & Drop: Static & Keep: Dynamic & Drop: Dynamic & Keep: , almost perform operation , use tensor shape (1) instead scalar shape (). difference subsetting former preserve dimension, latter drop , seen . ensures dimensionality result 1D subset specification, suddenly “simplify” result 0D. Next, subset multiple elements, distinguish static dynamic indices. Static Dynamic using list() instead 1-dimension vectors, otherwise case use length-1 vector ambiguous (drop keep dimension?). allows us without drop parameter. can also use range can specified either canonically via :b using nv_seq(). Note :b syntax works via Non-Standard-Evaluation (NSE), can distinguish actual vector 2:5. Internally, translated nv_seq(, b). also possible select whole range omitting specification altogether.","code":"library(anvil) x <- nv_tensor(1:10) x ## AnvilTensor ##   1 ##   2 ##   3 ##   4 ##   5 ##   6 ##   7 ##   8 ##   9 ##  10 ## [ CPUi32{10} ] jit_eval({   x[2] }) ## AnvilTensor ##  2 ## [ CPUi32{} ] jit_eval({   x[list(2)] }) ## AnvilTensor ##  2 ## [ CPUi32{1} ] jit_eval({   x[nv_scalar(2L)] }) ## AnvilTensor ##  2 ## [ CPUi32{} ] jit_eval({   x[nv_tensor(2L)] }) ## AnvilTensor ##  2 ## [ CPUi32{1} ] jit_eval({   x[list(2, 4, 6)] }) ## AnvilTensor ##  2 ##  4 ##  6 ## [ CPUi32{3} ] jit_eval({   x[nv_tensor(c(2L, 4L, 6L))] }) ## AnvilTensor ##  2 ##  4 ##  6 ## [ CPUi32{3} ] jit_eval({   x[2:5] }) ## AnvilTensor ##  2 ##  3 ##  4 ##  5 ## [ CPUi32{4} ] jit_eval({   x[nv_seq(2, 5)] }) ## AnvilTensor ##  2 ##  3 ##  4 ##  5 ## [ CPUi32{4} ] jit_eval({   x[] }) ## AnvilTensor ##   1 ##   2 ##   3 ##   4 ##   5 ##   6 ##   7 ##   8 ##   9 ##  10 ## [ CPUi32{10} ]"},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"subsetting-higher-dimensional-tensors","dir":"Articles","previous_headings":"Subsetting","what":"Subsetting higher-dimensional tensors","title":"Subsetting","text":"start creating 2-dimensional tensor. Combining subsets just works like one expect.","code":"x <- nv_tensor(matrix(1:12, nrow = 3, byrow = TRUE)) x ## AnvilTensor ##   1  2  3  4 ##   5  6  7  8 ##   9 10 11 12 ## [ CPUi32{3,4} ] jit_eval({   x[1, ] }) ## AnvilTensor ##  1 ##  2 ##  3 ##  4 ## [ CPUi32{4} ] jit_eval({   x[1, 2] }) ## AnvilTensor ##  2 ## [ CPUi32{} ] jit_eval({   x[list(1), 2:3] }) ## AnvilTensor ##  2 3 ## [ CPUi32{1,2} ] jit_eval({   x[list(1, 3), 2:3] }) ## AnvilTensor ##   2  3 ##  10 11 ## [ CPUi32{2,2} ] jit_eval({   x[1:2, 2:3] }) ## AnvilTensor ##  2 3 ##  6 7 ## [ CPUi32{2,2} ] jit_eval({   x[1, 2:3] }) ## AnvilTensor ##  2 ##  3 ## [ CPUi32{2} ] jit_eval({   x[list(2, 2), ] }) ## AnvilTensor ##  5 6 7 8 ##  5 6 7 8 ## [ CPUi32{2,4} ] jit_eval({   x[list(2, 2)] }) ## AnvilTensor ##  5 6 7 8 ##  5 6 7 8 ## [ CPUi32{2,4} ]"},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"out-of-bounds-handling","dir":"Articles","previous_headings":"Subsetting","what":"Out-of-bounds Handling","title":"Subsetting","text":"one specifies --bounds indices, can throw error indices static (know compile time), XLA backend {anvil} compiles , throw errors using --bounds indices, instead clamps valid range: Therefore, need careful using dynamic indexing order avoid bugs.","code":"jit_eval({   x[nv_tensor(-1L), nv_tensor(100L)] }) ## AnvilTensor ##  4 ## [ CPUi32{1,1} ] jit_eval({   x[nv_tensor(1L), nv_tensor(4L)] }) ## AnvilTensor ##  4 ## [ CPUi32{1,1} ]"},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"updating-subsets","dir":"Articles","previous_headings":"","what":"Updating Subsets","title":"Subsetting","text":"Updating subsets supports syntax subsetting. value write must either shape subset, scalar. Also, must data type convertible data type tensor.","code":"x ## AnvilTensor ##   1  2  3  4 ##   5  6  7  8 ##   9 10 11 12 ## [ CPUi32{3,4} ] jit_eval({   x[, 3] <- nv_tensor(-(1:3))   x }) ## AnvilTensor ##   1  2 -1  4 ##   5  6 -2  8 ##   9 10 -3 12 ## [ CPUi32{3,4} ] jit_eval({   x[, 3] <- -99L   x }) ## AnvilTensor ##    1   2 -99   4 ##    5   6 -99   8 ##    9  10 -99  12 ## [ CPUi32{3,4} ] jit_eval({   x[, 3] <- nv_tensor(c(1.5, 2.5, 3.5))   x }) ## Error in `nv_subset_assign()`: ## ! Value type f32 is not promotable to left-hand side type i32"},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"out-of-bounds-handling-1","dir":"Articles","previous_headings":"Updating Subsets","what":"Out-of-bounds Handling","title":"Subsetting","text":"Similar subsetting, --bounds indices can checked static values. dynamic indices, --bounds writes simply ignored: , write index 100 silently ignored, indices 1 3 updated.","code":"x <- nv_tensor(1:5) jit_eval({   x[nv_tensor(c(1L, 100L, 3L))] <- nv_tensor(c(-1L, -2L, -3L))   x }) ## AnvilTensor ##  -1 ##   2 ##  -3 ##   4 ##   5 ## [ CPUi32{5} ]"},{"path":"https://r-xla.github.io/anvil/articles/subsetting.html","id":"duplicate-indices","dir":"Articles","previous_headings":"Updating Subsets","what":"Duplicate Indices","title":"Subsetting","text":"writing element multiple times, gaurantee value written. Specifically, might differ backends (CPU vs. GPU).","code":"x <- nv_tensor(1:5) jit_eval({   x[list(1, 1, 1)] <- nv_tensor(c(10L, 20L, 30L))   x }) ## AnvilTensor ##  30 ##   2 ##   3 ##   4 ##   5 ## [ CPUi32{5} ]"},{"path":"https://r-xla.github.io/anvil/articles/type-promotion.html","id":"type-promotion-rules","dir":"Articles","previous_headings":"","what":"Type Promotion Rules","title":"Type Promotion","text":"combining tensors different types (e.g., adding f32 i32), {anvil} needs determine common type. example, adding f32 f64, former promoted latter’s type, ’s expressive. type-promotion rules inspired JAX, designed execution accelerators like GPUs, one often wants speed instead precision. rules defined common_dtype() function. returns list() two values: common dtype flag indicating whether result ambiguous, cover later. table promotion rules . Type promotion rules (row × column)","code":"library(anvil) jit(nv_add)(   nv_scalar(1.0, dtype = \"f32\"),   nv_scalar(1.0, dtype = \"f64\") ) ## AnvilTensor ##  2 ## [ CPUf64{} ] common_dtype(\"f64\", \"f32\")$dtype ## <f64> common_dtype(\"i64\", \"f32\")$dtype ## <f32>"},{"path":"https://r-xla.github.io/anvil/articles/type-promotion.html","id":"literals-as-ambiguous-types","dir":"Articles","previous_headings":"","what":"Literals as Ambiguous Types","title":"Type Promotion","text":"Usually, types {anvil} program can deterministically inferred input types. case possible use R literals. default types literals follows: double() -> f32 integer() -> i32 logical() -> i1 (bool) However, just guess, behave differently known types promotion. Therefore, common_dtype function two arguments indicating data types ambiguous. , first type known f64 second ambiguous f32. Within anvil, denote latter i32?. result f64, although promote f64 known. types ambiguous, result generally known. promotion rules change one type ambiguous . , usually promote ambiguous type known type, unless: ambiguous type float known type . known type bool ambiguous type . case, promote known type default type ambiguous type. table shows promotion rules, rows ambiguous columns known. Promotion rules: ambiguous (row) × known (column)","code":"jit(\\() list(1L, 1.0, TRUE))() ## [[1]] ## AnvilTensor ##  1 ## [ CPUi32?{} ]  ##  ## [[2]] ## AnvilTensor ##  1 ## [ CPUf32?{} ]  ##  ## [[3]] ## AnvilTensor ##  1 ## [ CPUi1{} ] common_dtype(\"f32\", \"f64\", FALSE, TRUE) ## $dtype ## <f32> ##  ## $ambiguous ## [1] FALSE common_dtype(\"f32\", \"f64\", TRUE, TRUE) ## $dtype ## <f64> ##  ## $ambiguous ## [1] TRUE common_dtype(\"f32\", \"f64\", FALSE, FALSE) ## $dtype ## <f64> ##  ## $ambiguous ## [1] FALSE"},{"path":"https://r-xla.github.io/anvil/articles/type-promotion.html","id":"creating-tensors-with-different-ambiguity","dir":"Articles","previous_headings":"","what":"Creating Tensors with Different Ambiguity","title":"Type Promotion","text":"nv_scalar() nv_tensor() create non-ambiguous tensors default. can explicitly control ambiguity using ambiguous parameter:","code":"s1 <- nv_scalar(1.0) ambiguous(s1) ## [1] FALSE s2 <- nv_scalar(1.0, ambiguous = TRUE) ambiguous(s2) ## [1] TRUE t1 <- nv_tensor(c(1.0, 2.0, 3.0)) ambiguous(t1) ## [1] FALSE t2 <- nv_tensor(c(1.0, 2.0, 3.0), ambiguous = TRUE) ambiguous(t2) ## [1] TRUE"},{"path":"https://r-xla.github.io/anvil/articles/type-promotion.html","id":"propagating-ambiguity","dir":"Articles","previous_headings":"","what":"Propagating Ambiguity","title":"Type Promotion","text":"Ambiguity propagated operations. Consider following example: type z i32?, x promoted i32, default type 1L literal. z ambiguous, output i32, y promoted i32 multiplication. propagate ambiguity, z actually -promoted i16, z ambiguous, y known.","code":"f <- jit(function(x, y) {   z <- x + 1L   z * y }) f(nv_scalar(TRUE), nv_scalar(2L, dtype = \"i16\")) ## AnvilTensor ##  4 ## [ CPUi16{} ]"},{"path":"https://r-xla.github.io/anvil/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sebastian Fischer. Maintainer, author. Daniel Falbel. Author. Nikolai German. Author.","code":""},{"path":"https://r-xla.github.io/anvil/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fischer S, Falbel D, German N (2026). anvil: Framework R code transformations. R package version 0.0.0.9000, https://r-xla.github.io/anvil/.","code":"@Manual{,   title = {anvil: Framework for R code transformations},   author = {Sebastian Fischer and Daniel Falbel and Nikolai German},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://r-xla.github.io/anvil/}, }"},{"path":"https://r-xla.github.io/anvil/index.html","id":"anvil","dir":"","previous_headings":"","what":"Framework for R code transformations","title":"Framework for R code transformations","text":"Composable code transformation framework R, allowing run numerical programs speed light. currently implements JIT compilation fast execution backward-mode automatic differentiation. Programs can run various hardware backends, including CPU GPU.","code":""},{"path":"https://r-xla.github.io/anvil/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Framework for R code transformations","text":"order install source, need C++20 compiler, well libprotobuf protobuf-compiler. can also install r-universe, adding code .Rprofile. can also use one prebuilt Docker images.","code":"pak::pak(\"r-xla/anvil\") options(repos = c(   rxla = \"https://r-xla.r-universe.dev\",   CRAN = \"https://cloud.r-project.org/\" ))"},{"path":"https://r-xla.github.io/anvil/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Framework for R code transformations","text":", create standard R function. directly call function, first need wrap jit() call. resulting function called AnvilTensors – primary data type {anvil} – JIT compiled subsequently executed. automatic differentiation, can also obtain gradient function.","code":"library(anvil) f <- function(a, b, x) {   a * x + b } f_jit <- jit(f)  a <- nv_scalar(1.0, \"f32\") b <- nv_scalar(-2.0, \"f32\") x <- nv_scalar(3.0, \"f32\")  f_jit(a, b, x) #> AnvilTensor #>  1.0000 #> [ CPUf32{} ] g_jit <- jit(gradient(f, wrt = c(\"a\", \"b\"))) g_jit(a, b, x) #> $a #> AnvilTensor #>  3.0000 #> [ CPUf32{} ]  #>  #> $b #> AnvilTensor #>  1.0000 #> [ CPUf32{} ]"},{"path":"https://r-xla.github.io/anvil/index.html","id":"main-features","dir":"","previous_headings":"","what":"Main Features","title":"Framework for R code transformations","text":"Gradients functions scalar outputs supported. Code JIT compiled single kernel. Runs different hardware backends, including CPU GPU. possible add new primitives, transformations, (effort) new backends. package written almost entirely R.","code":""},{"path":"https://r-xla.github.io/anvil/index.html","id":"when-to-use-this-package","dir":"","previous_headings":"","what":"When to use this package?","title":"Framework for R code transformations","text":"{anvil} allows run certain types programs extremely fast, applies certain category problems. Specifically, suitable numerical algorithms, optimizing bayesian models, training neural networks generally numerical optimization. Another restriction {anvil} needs re-compile code new unique input shape. advantage, compiler can make memory optimizations, compilation overhead might problem fast running programs.","code":""},{"path":"https://r-xla.github.io/anvil/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"Framework for R code transformations","text":"work supported MaRDI. JAX, especially autodidax tutorial. microjax project. JIT compilation, leverage OpenXLA project.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AbstractTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Abstract Tensor Class — nv_aten","title":"Abstract Tensor Class — nv_aten","text":"Representation abstract tensor type. tracing, wrapped GraphNode held GraphBox. lowered AnvilGraph also part GraphNodes representing values program. base class represents unknown value, child classes exist : closed-constants: ConcreteTensor scalar tensors arising R literals: LiteralTensor sequence patterns: IotaTensor convert tensorish value abstract tensor, use to_abstract().","code":""},{"path":"https://r-xla.github.io/anvil/reference/AbstractTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Abstract Tensor Class — nv_aten","text":"","code":"nv_aten(dtype, shape, ambiguous = FALSE)  AbstractTensor(dtype, shape, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/AbstractTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Abstract Tensor Class — nv_aten","text":"dtype (stablehlo::TensorDataType | character(1)) data type tensor. shape (stablehlo::Shape | integer()) shape tensor. Can provided integer vector. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AbstractTensor.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Abstract Tensor Class — nv_aten","text":"following extractors available AbstractTensor objects: dtype(): Get data type tensor. shape(): Get shape (dimensions) tensor. ambiguous(): Get whether dtype ambiguous. ndims(): Get number dimensions.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/AbstractTensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Abstract Tensor Class — nv_aten","text":"","code":"# -- Creating abstract tensors -- a <- AbstractTensor(\"f32\", c(2L, 3L)) a #> AbstractTensor(dtype=f32, shape=2x3)  dtype(a) #> <f32> shape(a) #> [1] 2 3 ambiguous(a) #> [1] FALSE  # Shorthand nv_aten(\"f32\", c(2L, 3L)) #> AbstractTensor(dtype=f32, shape=2x3)   # How AbstractTensors appear in an AnvilGraph graph <- trace_fn(function(x) x + 1, list(x = nv_aten(\"i32\", 4L))) graph #> <AnvilGraph> #>   Inputs: #>     %x1: i32[4] #>   Body: #>     %1: f32?[4] = convert [dtype = f32, ambiguous = TRUE] (%x1) #>     %2: f32?[4] = broadcast_in_dim [shape = 4, broadcast_dimensions = <any>] (1:f32?) #>     %3: f32?[4] = add(%1, %2) #>   Outputs: #>     %3: f32?[4]  graph$inputs[[1]]$aval #> AbstractTensor(dtype=i32, shape=4)"},{"path":"https://r-xla.github.io/anvil/reference/AnvilBox.html","id":null,"dir":"Reference","previous_headings":"","what":"AnvilBox — AnvilBox","title":"AnvilBox — AnvilBox","text":"Virtual S3 base class GraphBox DebugBox.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/AnvilGraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph of Primitive Calls — AnvilGraph","title":"Graph of Primitive Calls — AnvilGraph","text":"Computational graph consisting exclusively primitive calls. mutable class.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilGraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph of Primitive Calls — AnvilGraph","text":"","code":"AnvilGraph(   calls = list(),   in_tree = NULL,   out_tree = NULL,   inputs = list(),   outputs = list(),   constants = list(),   is_static_flat = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/AnvilGraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph of Primitive Calls — AnvilGraph","text":"calls (list(PrimitiveCall)) primitive calls make graph. can also another call graph primitive p_call. in_tree (NULL | Node) tree inputs. May contain leaves tensor inputs static (non-tensor) arguments. tensor leaves correspond entries inputs; use is_static_flat distinguish . out_tree (NULL | Node) tree outputs. inputs (list(GraphValue)) inputs graph (tensor arguments ). outputs (list(GraphValue)) outputs graph. constants (list(GraphValue)) constants graph. is_static_flat (NULL | logical()) Boolean mask indicating flat positions in_tree static (non-tensor) args. NULL args tensor inputs.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilGraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph of Primitive Calls — AnvilGraph","text":"(AnvilGraph)","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilPrimitive.html","id":null,"dir":"Reference","previous_headings":"","what":"AnvilPrimitive — AnvilPrimitive","title":"AnvilPrimitive — AnvilPrimitive","text":"Primitive interpretation rule. Note [[ [[<- access interpretation rules. access fields, use $ $<-. primitive considered higher-order contains subgraphs.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilPrimitive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AnvilPrimitive — AnvilPrimitive","text":"","code":"AnvilPrimitive(name, subgraphs = character())"},{"path":"https://r-xla.github.io/anvil/reference/AnvilPrimitive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AnvilPrimitive — AnvilPrimitive","text":"name (character()) name primitive. subgraphs (character()) Names parameters subgraphs. used higher_order = TRUE.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilPrimitive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AnvilPrimitive — AnvilPrimitive","text":"(AnvilPrimitive)","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"AnvilTensor — AnvilTensor","title":"AnvilTensor — AnvilTensor","text":"main tensor object. type determined data type shape. transform tensors, apply jit()ted functions. Directly calling operations (e.g. nv_add(x, y)) AnvilTensor objects performs type inference returns AbstractTensor – see vignette(\"debugging\") details. compare whether two abstract tensors equal, use eq_type().","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AnvilTensor — AnvilTensor","text":"","code":"nv_tensor(data, dtype = NULL, device = NULL, shape = NULL, ambiguous = NULL)  nv_scalar(data, dtype = NULL, device = NULL, ambiguous = NULL)  nv_empty(dtype, shape, device = NULL, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AnvilTensor — AnvilTensor","text":"data () Object convertible PJRTBuffer. Includes integer(), double(), logical() vectors arrays. dtype (NULL | character(1) | stablehlo::TensorDataType) One pred, i8, i16, i32, i64, ui8, ui16, ui32, ui64, f32, f64 stablehlo::TensorDataType. default (NULL) uses f32 numeric data, i32 integer data, i1 logical data. device (NULL | character(1) | PJRTDevice) device tensor (\"cpu\", \"cuda\"). Default use CPU new tensors. can changed setting PJRT_PLATFORM environment variable. shape (NULL | integer()) output shape tensor. default (NULL) infer data possible. Note nv_tensor interprets length 1 vectors shape (1). create \"scalar\" dimension (), use nv_scalar explicitly specify shape = c(). ambiguous (NULL | logical(1)) Whether dtype marked ambiguous. Defaults FALSE new tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AnvilTensor — AnvilTensor","text":"(AnvilTensor)","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"AnvilTensor — AnvilTensor","text":"following generic functions can used extract information AnvilTensor: dtype(): Get data type tensor. shape(): Get shape (dimensions) tensor. ndims(): Get number dimensions. device(): Get device tensor. platform(): Get platform (e.g. \"cpu\", \"cuda\"). ambiguous(): Get whether dtype ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"serialization","dir":"Reference","previous_headings":"","what":"Serialization","title":"AnvilTensor — AnvilTensor","text":"Tensors can serialized safetensors format: nv_save() / nv_read(): Save/load tensors /file. nv_serialize() / nv_unserialize(): Serialize/deserialize tensors /raw vectors.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/AnvilTensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"AnvilTensor — AnvilTensor","text":"","code":"# A 1-d tensor (vector) with shape (4). Default type for integers is `i32` nv_tensor(1:4) #> AnvilTensor #>  1 #>  2 #>  3 #>  4 #> [ CPUi32{4} ]   # Specify a dtype nv_tensor(c(1.5, 2.5, 3.5), dtype = \"f64\") #> AnvilTensor #>  1.5000 #>  2.5000 #>  3.5000 #> [ CPUf64{3} ]   # A 2x3 matrix nv_tensor(1:6, shape = c(2L, 3L)) #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]   # A scalar tensor. nv_scalar(3.14) #> AnvilTensor #>  3.1400 #> [ CPUf32{} ]   # A 0x3 tensor nv_empty(\"f32\", shape = c(0L, 3L)) #> AnvilTensor #> [ CPUf32{0,3} ]   # --- Extractors --- x <- nv_tensor(1:6, shape = c(2L, 3L)) dtype(x) #> <i32> shape(x) #> [1] 2 3 ndims(x) #> [1] 2 device(x) #> <CpuDevice(id=0)> platform(x) #> [1] \"cpu\" ambiguous(x) #> [1] FALSE  # --- Transforming tensors with jit --- add_one <- jit(function(x) x + 1) add_one(nv_tensor(1:4)) #> AnvilTensor #>  2 #>  3 #>  4 #>  5 #> [ CPUf32?{4} ]   # --- Debug mode (calling operations directly) --- # Outside of jit, operations only perform type inference: nv_add(nv_tensor(1:3), nv_tensor(4:6)) #> i32{3}"},{"path":"https://r-xla.github.io/anvil/reference/ConcreteTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Concrete Tensor Class — ConcreteTensor","title":"Concrete Tensor Class — ConcreteTensor","text":"AbstractTensor also holds reference actual tensor data. Usually represents closed-constant program. Inherits AbstractTensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ConcreteTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concrete Tensor Class — ConcreteTensor","text":"","code":"ConcreteTensor(data)"},{"path":"https://r-xla.github.io/anvil/reference/ConcreteTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concrete Tensor Class — ConcreteTensor","text":"data (AnvilTensor) actual tensor data.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ConcreteTensor.html","id":"lowering","dir":"Reference","previous_headings":"","what":"Lowering","title":"Concrete Tensor Class — ConcreteTensor","text":"lowering XLA, become inputs executable instead embedding programs constants. avoid increasing compilation time bloating size executable.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ConcreteTensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concrete Tensor Class — ConcreteTensor","text":"","code":"y <- nv_tensor(c(0.5, 0.6)) x <- ConcreteTensor(y) x #> ConcreteTensor #>  0.5000 #>  0.6000 #> [ CPUf32{2} ]  ambiguous(x) #> [1] FALSE shape(x) #> [1] 2 ndims(x) #> [1] 1 dtype(x) #> <f32>  # How it appears during tracing graph <- trace_fn(function() y, list()) graph #> <AnvilGraph> #>   Inputs: (none) #>   Constants: #>     %c1: f32[2] #>   Body: (empty) #>   Outputs: #>     %c1: f32[2]  graph$outputs[[1]]$aval #> ConcreteTensor #>  0.5000 #>  0.6000 #> [ CPUf32{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":null,"dir":"Reference","previous_headings":"","what":"Debug Box Class — DebugBox","title":"Debug Box Class — DebugBox","text":"AnvilBox subclass wraps AbstractTensor use debug mode. anvil operations (e.g. nv_add()) called outside jit(), return DebugBox objects instead actual computed results. allows checking types shapes intermediate values without compiling running computation – see vignette(\"debugging\") details. convenience constructor debug_box() creates DebugBox dtype shape directly.","code":""},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debug Box Class — DebugBox","text":"","code":"DebugBox(aval)"},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debug Box Class — DebugBox","text":"aval (AbstractTensor) abstract tensor representing value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Debug Box Class — DebugBox","text":"(DebugBox)","code":""},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Debug Box Class — DebugBox","text":"dtype() shape() ndims() ambiguous()","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/DebugBox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Debug Box Class — DebugBox","text":"","code":"x <- nv_tensor(1:4) y <- nv_tensor(5:8) result <- nv_add(x, y) result #> i32{4} dtype(result) #> <i32> shape(result) #> [1] 4  # Create directly via debug_box() db <- debug_box(\"f32\", c(2L, 3L)) db #> f32{2,3} nv_reduce_sum(db, dims = 2L) #> f32{2}"},{"path":"https://r-xla.github.io/anvil/reference/GraphBox.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Box — GraphBox","title":"Graph Box — GraphBox","text":"AnvilBox subclass wraps GraphNode graph construction (tracing). function traced via trace_fn(), intermediate tensor value represented GraphBox. also contains associated GraphDescriptor node \"lives\".","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphBox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Box — GraphBox","text":"","code":"GraphBox(gnode, desc)"},{"path":"https://r-xla.github.io/anvil/reference/GraphBox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Box — GraphBox","text":"gnode (GraphNode) graph node – either GraphValue GraphLiteral. desc (GraphDescriptor) descriptor graph built.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphBox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph Box — GraphBox","text":"(GraphBox)","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphBox.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Graph Box — GraphBox","text":"dtype() shape() ndims() ambiguous()","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/GraphDescriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Descriptor — GraphDescriptor","title":"Graph Descriptor — GraphDescriptor","text":"Descriptor AnvilGraph. mutable class.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphDescriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Descriptor — GraphDescriptor","text":"","code":"GraphDescriptor(   calls = list(),   tensor_to_gval = NULL,   gval_to_box = NULL,   constants = list(),   in_tree = NULL,   out_tree = NULL,   inputs = list(),   outputs = list(),   is_static_flat = NULL,   devices = character() )"},{"path":"https://r-xla.github.io/anvil/reference/GraphDescriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Descriptor — GraphDescriptor","text":"calls (list(PrimitiveCall)) primitive calls make graph. tensor_to_gval (hashtab) Mapping: AnvilTensor -> GraphValue gval_to_box (hashtab) Mapping: GraphValue -> GraphBox constants (list(GraphValue)) constants graph. in_tree (NULL | Node) tree inputs. May contain leaves tensor inputs static (non-tensor) arguments. tensor leaves correspond entries inputs; use is_static_flat distinguish . out_tree (NULL | Node) tree outputs. inputs (list(GraphValue)) inputs graph (tensor arguments ). outputs (list(GraphValue)) outputs graph. is_static_flat (NULL | logical()) Boolean mask indicating flat positions in_tree static (non-tensor) args. NULL args tensor inputs. devices (character()) Device platforms encountered tracing (e.g. \"cpu\", \"cuda\"). Populated automatically tensors registered.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphDescriptor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph Descriptor — GraphDescriptor","text":"(GraphDescriptor)","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphLiteral.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Literal — GraphLiteral","title":"Graph Literal — GraphLiteral","text":"Literal AnvilGraph. mutable class.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphLiteral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Literal — GraphLiteral","text":"","code":"GraphLiteral(aval)"},{"path":"https://r-xla.github.io/anvil/reference/GraphLiteral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Literal — GraphLiteral","text":"aval (LiteralTensor) value literal.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphLiteral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph Literal — GraphLiteral","text":"(GraphLiteral)","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphNode.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Node — GraphNode","title":"Graph Node — GraphNode","text":"Virtual base class nodes AnvilGraph. either GraphValue GraphLiteral. instantiated directly - use GraphValue() GraphLiteral() instead.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphValue.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Value — GraphValue","title":"Graph Value — GraphValue","text":"Value AnvilGraph. mutable class.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphValue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Value — GraphValue","text":"","code":"GraphValue(aval)"},{"path":"https://r-xla.github.io/anvil/reference/GraphValue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Value — GraphValue","text":"aval (AbstractTensor) abstract value variable.","code":""},{"path":"https://r-xla.github.io/anvil/reference/GraphValue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph Value — GraphValue","text":"(GraphValue)","code":""},{"path":"https://r-xla.github.io/anvil/reference/HloEnv.html","id":null,"dir":"Reference","previous_headings":"","what":"HloEnv — HloEnv","title":"HloEnv — HloEnv","text":"Environment storing graph value func value mappings. mutable class.","code":""},{"path":"https://r-xla.github.io/anvil/reference/HloEnv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HloEnv — HloEnv","text":"","code":"HloEnv(parent = NULL, gval_to_fval = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/HloEnv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HloEnv — HloEnv","text":"parent (HloEnv | NULL) Parent environment lookups. gval_to_fval (hashtab) Mapping graph values func values.","code":""},{"path":"https://r-xla.github.io/anvil/reference/HloEnv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"HloEnv — HloEnv","text":"(HloEnv)","code":""},{"path":"https://r-xla.github.io/anvil/reference/IotaTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Iota Tensor Class — IotaTensor","title":"Iota Tensor Class — IotaTensor","text":"AbstractTensor representing integer sequence. Usually created nv_iota() / nv_seq(), call nvl_iota() internally. Inherits AbstractTensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/IotaTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iota Tensor Class — IotaTensor","text":"","code":"IotaTensor(shape, dtype, dimension, start = 1L, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/IotaTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iota Tensor Class — IotaTensor","text":"shape (stablehlo::Shape | integer()) shape tensor. dtype (stablehlo::TensorDataType) data type. dimension (integer(1)) dimension along values increase. start (integer(1)) starting value. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/IotaTensor.html","id":"lowering","dir":"Reference","previous_headings":"","what":"Lowering","title":"Iota Tensor Class — IotaTensor","text":"lowering stableHLO, become iota operations generate integer sequence need actually hold data executable, similar ALTREPs R. lowers stablehlo::hlo_iota(), optionally shifting starting value via stablehlo::hlo_add().","code":""},{"path":"https://r-xla.github.io/anvil/reference/IotaTensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iota Tensor Class — IotaTensor","text":"","code":"x <- IotaTensor(shape = 4L, dtype = \"i32\", dimension = 1L) x #> IotaTensor(shape=(4), dtype=i32, dimension=1, start=1)  ambiguous(x) #> [1] FALSE shape(x) #> [1] 4 ndims(x) #> [1] 1 dtype(x) #> <i32> # How it appears during tracing: graph <- trace_fn(function() nv_iota(dim = 1L, dtype = \"i32\", shape = 4L), list()) graph #> <AnvilGraph> #>   Inputs: (none) #>   Body: #>     %1: i32[4] = iota [dim = 1, dtype = i32, shape = 4, start = 1, ambiguous = FALSE] () #>   Outputs: #>     %1: i32[4]  graph$outputs[[1]]$aval #> IotaTensor(shape=(4), dtype=i32, dimension=1, start=1)"},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Literal Tensor Class — LiteralTensor","title":"Literal Tensor Class — LiteralTensor","text":"AbstractTensor elements constant value. either arises using literals traced code (e.g. x + 1) using nv_fill() create constant.","code":""},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literal Tensor Class — LiteralTensor","text":"","code":"LiteralTensor(data, shape, dtype = default_dtype(data), ambiguous)"},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Literal Tensor Class — LiteralTensor","text":"data (double(1) | integer(1) | logical(1) | AnvilTensor) scalar value scalarish AnvilTensor (contains 1 element). shape (stablehlo::Shape | integer()) shape tensor. dtype (stablehlo::TensorDataType) data type. Defaults f32 numeric, i32 integer, i1 logical. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":"type-ambiguity","dir":"Reference","previous_headings":"","what":"Type Ambiguity","title":"Literal Tensor Class — LiteralTensor","text":"arising R literals, resulting LiteralTensor ambiguous type information available. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":"lowering","dir":"Reference","previous_headings":"","what":"Lowering","title":"Literal Tensor Class — LiteralTensor","text":"LiteralTensors become constants inlined stableHLO program. .e., lower stablehlo::hlo_tensor().","code":""},{"path":"https://r-xla.github.io/anvil/reference/LiteralTensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Literal Tensor Class — LiteralTensor","text":"","code":"x <- LiteralTensor(1L, shape = integer(), ambiguous = TRUE) x #> LiteralTensor(1, i32?, ())  ambiguous(x) #> [1] TRUE shape(x) #> integer(0) ndims(x) #> [1] 0 dtype(x) #> <i32> # How it appears during tracing: # 1. via R literals graph <- trace_fn(function() 1, list()) graph #> <AnvilGraph> #>   Inputs: (none) #>   Body: (empty) #>   Outputs: #>     1:f32?  graph$outputs[[1]]$aval #> LiteralTensor(1, f32?, ())  # 2. via nv_fill() graph <- trace_fn(function() nv_fill(2L, shape = c(2, 2)), list()) graph #> <AnvilGraph> #>   Inputs: (none) #>   Body: #>     %1: i32[2, 2] = fill [value = 2, dtype = i32, shape = c(2, 2), ambiguous = FALSE] () #>   Outputs: #>     %1: i32[2, 2]  graph$outputs[[1]]$aval #> AbstractTensor(dtype=i32, shape=2x2)"},{"path":"https://r-xla.github.io/anvil/reference/PrimitiveCall.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Call — PrimitiveCall","title":"Primitive Call — PrimitiveCall","text":"Call primitive AnvilGraph Note primitive call also call another graph (p_graph).","code":""},{"path":"https://r-xla.github.io/anvil/reference/PrimitiveCall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Call — PrimitiveCall","text":"","code":"PrimitiveCall(primitive, inputs, params, outputs)"},{"path":"https://r-xla.github.io/anvil/reference/PrimitiveCall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Call — PrimitiveCall","text":"primitive (AnvilPrimitive) function. inputs (list(GraphValue)) (tensor) inputs primitive. params (list(<>)) (static) parameters function call. outputs (list(GraphValue)) (tensor) outputs primitive.","code":""},{"path":"https://r-xla.github.io/anvil/reference/PrimitiveCall.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Call — PrimitiveCall","text":"(PrimitiveCall)","code":""},{"path":"https://r-xla.github.io/anvil/reference/Shape-constructor.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Shape object — Shape","title":"Create a Shape object — Shape","text":"Constructs Shape representing tensor dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/Shape-constructor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Shape object — Shape","text":"","code":"Shape(dims = integer())"},{"path":"https://r-xla.github.io/anvil/reference/Shape-constructor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Shape object — Shape","text":"dims integer() vector dimension sizes (>= 0).","code":""},{"path":"https://r-xla.github.io/anvil/reference/Shape-constructor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Shape object — Shape","text":"Shape object.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/Shape-constructor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Shape object — Shape","text":"","code":"Shape(c(2L, 3L)) #> (2x3)"},{"path":"https://r-xla.github.io/anvil/reference/abstract_properties.html","id":null,"dir":"Reference","previous_headings":"","what":"Abstract Properties — abstract_properties","title":"Abstract Properties — abstract_properties","text":"Calls extractor converting input AbstractTensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/abstract_properties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Abstract Properties — abstract_properties","text":"","code":"shape_abstract(x)  ndims_abstract(x)  dtype_abstract(x)  ambiguous_abstract(x)"},{"path":"https://r-xla.github.io/anvil/reference/abstract_properties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Abstract Properties — abstract_properties","text":"x (tensorish)","code":""},{"path":"https://r-xla.github.io/anvil/reference/ambiguous.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Ambiguity of a Tensor — ambiguous","title":"Get Ambiguity of a Tensor — ambiguous","text":"Returns whether tensor's dtype ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ambiguous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Ambiguity of a Tensor — ambiguous","text":"","code":"ambiguous(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/ambiguous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Ambiguity of a Tensor — ambiguous","text":"x tensor object ... Additional arguments (unused)","code":""},{"path":"https://r-xla.github.io/anvil/reference/ambiguous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Ambiguity of a Tensor — ambiguous","text":"logical(1) - TRUE dtype ambiguous, FALSE otherwise","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a tensor to an R array — as_array","title":"Convert a tensor to an R array — as_array","text":"Transfers tensor data R returns R array. case scalars result vector length 1, R arrays 0 dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a tensor to an R array — as_array","text":"","code":"as_array(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a tensor to an R array — as_array","text":"x (tensorish) tensor-like object. ... Additional arguments passed methods (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a tensor to an R array — as_array","text":"R array vector length 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a tensor to an R array — as_array","text":"implemented via generic tengen::as_array().","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a tensor to an R array — as_array","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") as_array(x) #> [1] 1 2 3 4 y <- nv_scalar(1L) # R arrays can't have 0 dimensions: as_array(y) #> [1] 1"},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a TensorDataType — as_dtype","title":"Convert to a TensorDataType — as_dtype","text":"Coerces value TensorDataType. Accepts data type strings (e.g. \"f32\", \"i64\", \"i1\") existing TensorDataType objects (returned unchanged).","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a TensorDataType — as_dtype","text":"","code":"as_dtype(x)"},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a TensorDataType — as_dtype","text":"x character string TensorDataType convert.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to a TensorDataType — as_dtype","text":"TensorDataType object.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert to a TensorDataType — as_dtype","text":"implemented via generic stablehlo::as_dtype().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/as_dtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to a TensorDataType — as_dtype","text":"","code":"as_dtype(\"f32\") #> <f32> as_dtype(\"i32\") #> <i32>"},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a tensor to a raw vector — as_raw","title":"Convert a tensor to a raw vector — as_raw","text":"Returns underlying bytes tensor raw vector.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a tensor to a raw vector — as_raw","text":"","code":"as_raw(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a tensor to a raw vector — as_raw","text":"x (tensorish) tensor-like object. ... Additional arguments passed method: row_major (logical(1)) Whether write bytes row-major order.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a tensor to a raw vector — as_raw","text":"raw vector.","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a tensor to a raw vector — as_raw","text":"implemented via generic tengen::as_raw().","code":""},{"path":"https://r-xla.github.io/anvil/reference/as_raw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a tensor to a raw vector — as_raw","text":"","code":"x <- nv_tensor(1:4, shape = c(2, 2), dtype = \"f32\") as_raw(x, row_major = TRUE) #>  [1] 00 00 80 3f 00 00 40 40 00 00 00 40 00 00 80 40 as_raw(x, row_major = FALSE) #>  [1] 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40"},{"path":"https://r-xla.github.io/anvil/reference/assert_shapevec.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Shape Vector — assert_shapevec","title":"Assert Shape Vector — assert_shapevec","text":"Check whether input valid shape vector (integer vector positive values).","code":""},{"path":"https://r-xla.github.io/anvil/reference/assert_shapevec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert Shape Vector — assert_shapevec","text":"","code":"assert_shapevec(x, min_len = 1L, var_name = rlang::caller_arg(x))"},{"path":"https://r-xla.github.io/anvil/reference/assert_shapevec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Shape Vector — assert_shapevec","text":"x Object check. min_len (integer(1)) Minimum length shape vector. Default 1. var_name (character(1)) Name variable use error messages.","code":""},{"path":"https://r-xla.github.io/anvil/reference/assert_shapevec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Shape Vector — assert_shapevec","text":"Invisibly returns x assertion passes.","code":""},{"path":"https://r-xla.github.io/anvil/reference/at2vt.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert AbstractTensor to ValueType — at2vt","title":"Convert AbstractTensor to ValueType — at2vt","text":"Convert AbstractTensor ValueType.","code":""},{"path":"https://r-xla.github.io/anvil/reference/at2vt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert AbstractTensor to ValueType — at2vt","text":"","code":"at2vt(x)"},{"path":"https://r-xla.github.io/anvil/reference/at2vt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert AbstractTensor to ValueType — at2vt","text":"x (AbstractTensor)","code":""},{"path":"https://r-xla.github.io/anvil/reference/at2vt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert AbstractTensor to ValueType — at2vt","text":"(ValueType)","code":""},{"path":"https://r-xla.github.io/anvil/reference/build_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Tree — build_tree","title":"Build Tree — build_tree","text":"Captures nesting structure object tree Nodes. leaf input becomes LeafNode integer index corresponding position flat list produced flatten(). Lists become ListNodes record child nodes names. resulting tree can passed unflatten() reconstruct original structure flat list.","code":""},{"path":"https://r-xla.github.io/anvil/reference/build_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Tree — build_tree","text":"","code":"build_tree(x, counter = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/build_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Tree — build_tree","text":"x () Object whose structure capture. Lists recursed ; everything else leaf. counter (NULL | environment) Internal counter assigning leaf indices. Mostly used internally otherwise left NULL (default.)","code":""},{"path":"https://r-xla.github.io/anvil/reference/build_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Tree — build_tree","text":"Node (LeafNode scalars, ListNode lists).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/build_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Tree — build_tree","text":"","code":"x <- list(a = 1, b = list(c = 2, d = 3)) tree <- build_tree(x) tree_size(tree) #> [1] 3  flat <- flatten(x) unflatten(tree, flat) #> $a #> [1] 1 #>  #> $b #> $b$c #> [1] 2 #>  #> $b$d #> [1] 3 #>  #>"},{"path":"https://r-xla.github.io/anvil/reference/common_dtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Promotion Rules — common_dtype","title":"Type Promotion Rules — common_dtype","text":"Computes common dtype set abstract types, respecting whether type ambiguous . type ambiguous comes literal (like 1 1.0) promoted ambiguous type. Promoting ambiguous type can happen scenarios like x + 1.2, x bool int.","code":""},{"path":"https://r-xla.github.io/anvil/reference/common_dtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Promotion Rules — common_dtype","text":"","code":"common_dtype(   lhs_dtype,   rhs_dtype,   lhs_ambiguous = FALSE,   rhs_ambiguous = FALSE )"},{"path":"https://r-xla.github.io/anvil/reference/common_dtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Promotion Rules — common_dtype","text":"lhs_dtype (stablehlo::TensorDataType) left-hand side type. rhs_dtype (stablehlo::TensorDataType) right-hand side type. lhs_ambiguous (logical(1)) Whether left-hand side type ambiguous. rhs_ambiguous (logical(1)) Whether right-hand side type ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/common_dtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Promotion Rules — common_dtype","text":"(list(dtype = [stablehlo::TensorDataType], ambiguous = logical(1)`)","code":""},{"path":"https://r-xla.github.io/anvil/reference/compile_to_xla.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace, lower, and compile a function to an XLA executable — compile_to_xla","title":"Trace, lower, and compile a function to an XLA executable — compile_to_xla","text":"Takes function, traces computational graph, lowers StableHLO, compiles PJRT executable. Returns compiled executable along metadata needed execution.","code":""},{"path":"https://r-xla.github.io/anvil/reference/compile_to_xla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace, lower, and compile a function to an XLA executable — compile_to_xla","text":"","code":"compile_to_xla(f, args_flat, in_tree, donate = character(), device = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/compile_to_xla.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace, lower, and compile a function to an XLA executable — compile_to_xla","text":"f (function) Function compile. args_flat (list) Flat list abstract input values. in_tree (Node) Tree structure inputs. donate (character()) Names arguments whose buffers donated. device (NULL | character(1)) Target device (e.g. \"cpu\", \"cuda\"). NULL, inferred traced tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/compile_to_xla.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace, lower, and compile a function to an XLA executable — compile_to_xla","text":"list elements: exec: compiled PJRT executable. out_tree: output tree structure. const_tensors: Constants needed execution time. ambiguous_out: Logical vector indicating outputs ambiguous (NULL none ).","code":""},{"path":"https://r-xla.github.io/anvil/reference/debug_box.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Debug Box — debug_box","title":"Create a Debug Box — debug_box","text":"Convenience constructor creates DebugBox data type shape, without manually construct AbstractTensor first.","code":""},{"path":"https://r-xla.github.io/anvil/reference/debug_box.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Debug Box — debug_box","text":"","code":"debug_box(dtype, shape, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/debug_box.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Debug Box — debug_box","text":"dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/debug_box.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Debug Box — debug_box","text":"(DebugBox)","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/debug_box.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Debug Box — debug_box","text":"","code":"# Create a debug box representing a 2x3 f32 tensor db <- debug_box(\"f32\", c(2L, 3L)) db #> f32{2,3} dtype(db) #> <f32> shape(db) #> [1] 2 3"},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the device of a tensor — device","title":"Get the device of a tensor — device","text":"Returns device tensor allocated.","code":""},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the device of a tensor — device","text":"","code":"device(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the device of a tensor — device","text":"x (tensorish) tensor-like object. ... Additional arguments passed methods (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the device of a tensor — device","text":"PJRTDevice","code":""},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the device of a tensor — device","text":"implemented via generic tengen::device().","code":""},{"path":"https://r-xla.github.io/anvil/reference/device.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the device of a tensor — device","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") device(x) #> <CpuDevice(id=0)>"},{"path":"https://r-xla.github.io/anvil/reference/dot-current_descriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the current graph — .current_descriptor","title":"Get the current graph — .current_descriptor","text":"Get current graph built (via local_descriptor).","code":""},{"path":"https://r-xla.github.io/anvil/reference/dot-current_descriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the current graph — .current_descriptor","text":"","code":".current_descriptor(silent = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/dot-current_descriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the current graph — .current_descriptor","text":"silent (logical(1)) Whether return NULL graph currently built (opposed aborting).","code":""},{"path":"https://r-xla.github.io/anvil/reference/dot-current_descriptor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the current graph — .current_descriptor","text":"GraphDescriptor object.","code":""},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the data type of a tensor — dtype","title":"Get the data type of a tensor — dtype","text":"Returns data type tensor (e.g. f32, i64).","code":""},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the data type of a tensor — dtype","text":"","code":"dtype(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the data type of a tensor — dtype","text":"x (tensorish) tensor-like object. ... Additional arguments passed methods (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the data type of a tensor — dtype","text":"TensorDataType.","code":""},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the data type of a tensor — dtype","text":"implemented via generic tengen::dtype().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/dtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the data type of a tensor — dtype","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") dtype(x) #> <f32>"},{"path":"https://r-xla.github.io/anvil/reference/eq_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare AbstractTensor Types — eq_type","title":"Compare AbstractTensor Types — eq_type","text":"Compare two AbstractTensors type equality.","code":""},{"path":"https://r-xla.github.io/anvil/reference/eq_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare AbstractTensor Types — eq_type","text":"","code":"eq_type(e1, e2, ambiguity)  neq_type(e1, e2, ambiguity)"},{"path":"https://r-xla.github.io/anvil/reference/eq_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare AbstractTensor Types — eq_type","text":"e1 (AbstractTensor) First tensor compare. e2 (AbstractTensor) Second tensor compare. ambiguity (logical(1)) Whether consider ambiguous field comparing. TRUE, tensors different ambiguity equal. FALSE, dtype shape compared.","code":""},{"path":"https://r-xla.github.io/anvil/reference/eq_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare AbstractTensor Types — eq_type","text":"logical(1) - TRUE tensors equal, FALSE otherwise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/eq_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare AbstractTensor Types — eq_type","text":"","code":"a <- nv_aten(\"f32\", c(2L, 3L)) b <- nv_aten(\"f32\", c(2L, 3L))  # Same dtype and shape eq_type(a, b, ambiguity = FALSE) #> [1] TRUE  # Different dtype eq_type(a, nv_aten(\"i32\", c(2L, 3L)), ambiguity = FALSE) #> [1] FALSE  # Different shape eq_type(a, nv_aten(\"f32\", c(3L, 2L)), ambiguity = FALSE) #> [1] FALSE  # ambiguity parameter controls whether ambiguous field is compared c <- nv_aten(\"f32\", c(2L, 3L), ambiguous = TRUE) eq_type(a, c, ambiguity = FALSE) #> [1] TRUE eq_type(a, c, ambiguity = TRUE) #> [1] FALSE  # neq_type is the negation of eq_type neq_type(a, b, ambiguity = FALSE) #> [1] FALSE"},{"path":"https://r-xla.github.io/anvil/reference/filter_list_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter List Node — filter_list_node","title":"Filter List Node — filter_list_node","text":"Subsets ListNode keep children whose names match names, reindexes leaf nodes map contiguous positions flat list. names kept original tree returned unchanged.","code":""},{"path":"https://r-xla.github.io/anvil/reference/filter_list_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter List Node — filter_list_node","text":"","code":"filter_list_node(tree, names)"},{"path":"https://r-xla.github.io/anvil/reference/filter_list_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter List Node — filter_list_node","text":"tree (ListNode) named list node returned build_tree(). names (character) Names children keep.","code":""},{"path":"https://r-xla.github.io/anvil/reference/filter_list_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter List Node — filter_list_node","text":"ListNode containing selected children reindexed leaves.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/filter_list_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter List Node — filter_list_node","text":"","code":"x <- list(a = 1, b = 2, c = 3) tree <- build_tree(x) sub <- filter_list_node(tree, c(\"a\", \"c\")) tree_size(sub) #> [1] 2  unflatten(sub, x[c(\"a\", \"c\")]) #> $a #> [1] 1 #>  #> $c #> [1] 3 #>"},{"path":"https://r-xla.github.io/anvil/reference/flatten.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten — flatten","title":"Flatten — flatten","text":"Recursively flattens nested list single flat list containing leaf values, preserving left--right order. Currently lists flattened objects treated leaves. Use build_tree() capture nesting structure can restored unflatten().","code":""},{"path":"https://r-xla.github.io/anvil/reference/flatten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten — flatten","text":"","code":"flatten(x)"},{"path":"https://r-xla.github.io/anvil/reference/flatten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten — flatten","text":"x () Object flatten.","code":""},{"path":"https://r-xla.github.io/anvil/reference/flatten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten — flatten","text":"list() containing flattened values.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/flatten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatten — flatten","text":"","code":"x <- list(a = 1, b = list(c = 2, d = 3)) flatten(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>   flatten(list(1:3, \"hello\")) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] \"hello\" #>"},{"path":"https://r-xla.github.io/anvil/reference/gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient — gradient","title":"Gradient — gradient","text":"Returns new function computes gradient f via reverse-mode automatic differentiation. f must return single float scalar. returned function signature f returns gradients structure inputs (subset selected wrt).","code":""},{"path":"https://r-xla.github.io/anvil/reference/gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient — gradient","text":"","code":"gradient(f, wrt = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient — gradient","text":"f (function) Function differentiate. Arguments can tensorish (AnvilTensor) static (non-tensor) values. Must return single scalar float tensor. wrt (character NULL) Names arguments compute gradient respect . tensorish (float tensor) arguments can included; static arguments must appear wrt. NULL (default), gradient computed respect arguments (must tensorish case).","code":""},{"path":"https://r-xla.github.io/anvil/reference/gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient — gradient","text":"function","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient — gradient","text":"","code":"f <- function(x, y) sum(x * y) g <- jit(gradient(f)) g(nv_tensor(c(1, 2), dtype = \"f32\"), nv_tensor(c(3, 4), dtype = \"f32\")) #> $x #> AnvilTensor #>  3 #>  4 #> [ CPUf32{2} ]  #>  #> $y #> AnvilTensor #>  1 #>  2 #> [ CPUf32{2} ]  #>   # Differentiate with respect to a single argument g_x <- jit(gradient(f, wrt = \"x\")) g_x(nv_tensor(c(1, 2), dtype = \"f32\"), nv_tensor(c(3, 4), dtype = \"f32\")) #> $x #> AnvilTensor #>  3 #>  4 #> [ CPUf32{2} ]  #>   # Static (non-tensor) arguments are passed through but cannot be in wrt f2 <- function(x, power) sum(x^power) g2 <- jit(gradient(f2, wrt = \"x\"), static = \"power\") g2(nv_tensor(c(1, 2, 3), dtype = \"f32\"), power = 2L) #> $x #> AnvilTensor #>  2 #>  4 #>  6 #> [ CPUf32{3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/graph_desc_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"Add primitive call graph descriptor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/graph_desc_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"","code":"graph_desc_add(   prim,   args,   params = list(),   infer_fn,   desc = NULL,   debug_mode = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/graph_desc_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"prim (AnvilPrimitive) primitive add. args (list GraphNode) arguments primitive. params (list) parameters primitive. infer_fn (function) inference function use. Must output list AbstractTensors. desc (GraphDescriptor | NULL) graph descriptor add primitive call . Uses current descriptor NULL. debug_mode (logical(1)) Whether just perform abstract evaluation debugging.","code":""},{"path":"https://r-xla.github.io/anvil/reference/graph_desc_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"(list Box) Either GraphBox objects DebugBox objects, depending debug_mode.","code":""},{"path":"https://r-xla.github.io/anvil/reference/is_dtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is a TensorDataType — is_dtype","title":"Check if an object is a TensorDataType — is_dtype","text":"Tests whether x TensorDataType object.","code":""},{"path":"https://r-xla.github.io/anvil/reference/is_dtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is a TensorDataType — is_dtype","text":"","code":"is_dtype(x)"},{"path":"https://r-xla.github.io/anvil/reference/is_dtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is a TensorDataType — is_dtype","text":"x object test.","code":""},{"path":"https://r-xla.github.io/anvil/reference/is_dtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is a TensorDataType — is_dtype","text":"TRUE FALSE.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/is_dtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an object is a TensorDataType — is_dtype","text":"","code":"is_dtype(\"f32\") #> [1] FALSE is_dtype(as_dtype(\"f32\")) #> [1] TRUE"},{"path":"https://r-xla.github.io/anvil/reference/jit.html","id":null,"dir":"Reference","previous_headings":"","what":"JIT compile a function — jit","title":"JIT compile a function — jit","text":"Wraps function traced, lowered StableHLO, compiled XLA executable first call. Subsequent calls input shapes dtypes hit LRU cache skip recompilation. Unlike xla(), compiled executable created eagerly lazily first invocation.","code":""},{"path":"https://r-xla.github.io/anvil/reference/jit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JIT compile a function — jit","text":"","code":"jit(   f,   static = character(),   cache_size = 100L,   donate = character(),   device = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/jit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JIT compile a function — jit","text":"f (function) Function compile. Must accept return AnvilTensors (/static arguments). static (character()) Names parameters f tensors. Static values embedded constants compiled program; new compilation triggered whenever static value changes. example useful want R control flow function. cache_size (integer(1)) Maximum number compiled executables keep LRU cache. donate (character()) Names arguments whose buffers donated. Donated buffers can aliased outputs type, allowing -place operations reducing memory usage. argument appear donate static. device (NULL | character(1) | PJRTDevice) device use inferred inputs constants. Defaults \"cpu\".","code":""},{"path":"https://r-xla.github.io/anvil/reference/jit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JIT compile a function — jit","text":"JitFunction formals f. (function)","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/jit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"JIT compile a function — jit","text":"","code":"f <- jit(function(x, y) x + y) f(nv_tensor(1), nv_tensor(2)) #> AnvilTensor #>  3 #> [ CPUf32{1} ]   # Static arguments enable data-dependent control flow g <- jit(function(x, flag) {   if (flag) x + 1 else x * 2 }, static = \"flag\") g(nv_tensor(3), TRUE) #> AnvilTensor #>  4 #> [ CPUf32{1} ]  g(nv_tensor(3), FALSE) #> AnvilTensor #>  6 #> [ CPUf32{1} ]"},{"path":"https://r-xla.github.io/anvil/reference/jit_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"JIT-compile and evaluate an expression — jit_eval","title":"JIT-compile and evaluate an expression — jit_eval","text":"Convenience wrapper JIT-compiles immediately evaluates single expression. Equivalent wrapping expr anonymous function, calling jit() , invoking result. Useful want evaluate expression .","code":""},{"path":"https://r-xla.github.io/anvil/reference/jit_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JIT-compile and evaluate an expression — jit_eval","text":"","code":"jit_eval(expr, device = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/jit_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JIT-compile and evaluate an expression — jit_eval","text":"expr (NSE) Expression compile evaluate. device (NULL | character(1) | PJRTDevice) device use. default (NULL), device inferred tensors encountered tracing, falling back \"cpu\". \"cpu\".","code":""},{"path":"https://r-xla.github.io/anvil/reference/jit_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JIT-compile and evaluate an expression — jit_eval","text":"() Result compiled evaluated expression.","code":""},{"path":"https://r-xla.github.io/anvil/reference/jit_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"JIT-compile and evaluate an expression — jit_eval","text":"","code":"x <- nv_tensor(c(1, 2, 3), dtype = \"f32\") jit_eval(x + x) #> AnvilTensor #>  2 #>  4 #>  6 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/local_descriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graph — local_descriptor","title":"Create a graph — local_descriptor","text":"Creates new GraphDescriptor afterwards accessible via .current_descriptor(). graph automatically removed exiting current scope. graph either cleaned automatically (exiting scope) finalized, previously built graph restored, .e., accessible via .current_descriptor().","code":""},{"path":"https://r-xla.github.io/anvil/reference/local_descriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graph — local_descriptor","text":"","code":"local_descriptor(..., envir = parent.frame())"},{"path":"https://r-xla.github.io/anvil/reference/local_descriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graph — local_descriptor","text":"... () Additional arguments pass GraphDescriptor constructor. envir (environment) Environment exit handler registered cleaning GraphDescriptor returned yet.","code":""},{"path":"https://r-xla.github.io/anvil/reference/local_descriptor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graph — local_descriptor","text":"GraphDescriptor object.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ndims.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of dimensions of a tensor — ndims","title":"Get the number of dimensions of a tensor — ndims","text":"Returns number dimensions (sometimes also refered rank) tensor. Equivalent length(shape(x)).","code":""},{"path":"https://r-xla.github.io/anvil/reference/ndims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of dimensions of a tensor — ndims","text":"","code":"ndims(x)"},{"path":"https://r-xla.github.io/anvil/reference/ndims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of dimensions of a tensor — ndims","text":"x (tensorish) tensor-like object.","code":""},{"path":"https://r-xla.github.io/anvil/reference/ndims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of dimensions of a tensor — ndims","text":"integer(1)","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/ndims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of dimensions of a tensor — ndims","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") ndims(x) #> [1] 1"},{"path":"https://r-xla.github.io/anvil/reference/nv_abs.html","id":null,"dir":"Reference","previous_headings":"","what":"Absolute Value — nv_abs","title":"Absolute Value — nv_abs","text":"Element-wise absolute value. can also use abs().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_abs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Absolute Value — nv_abs","text":"","code":"nv_abs(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_abs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Absolute Value — nv_abs","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_abs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Absolute Value — nv_abs","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_abs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Absolute Value — nv_abs","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 2, -3))   abs(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Addition — nv_add","title":"Addition — nv_add","text":"Adds two tensors element-wise. can also use + operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Addition — nv_add","text":"","code":"nv_add(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Addition — nv_add","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Addition — nv_add","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Addition — nv_add","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   x + y }) #> AnvilTensor #>  5 #>  7 #>  9 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_and.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical And — nv_and","title":"Logical And — nv_and","text":"Element-wise logical . can also use & operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_and.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical And — nv_and","text":"","code":"nv_and(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_and.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical And — nv_and","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_and.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical And — nv_and","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_and.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical And — nv_and","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   x & y }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_atan2.html","id":null,"dir":"Reference","previous_headings":"","what":"Arctangent 2 — nv_atan2","title":"Arctangent 2 — nv_atan2","text":"Element-wise two-argument arctangent, .e. angle (radians) positive x-axis point (rhs, lhs).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_atan2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arctangent 2 — nv_atan2","text":"","code":"nv_atan2(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_atan2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arctangent 2 — nv_atan2","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_atan2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arctangent 2 — nv_atan2","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_atan2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arctangent 2 — nv_atan2","text":"","code":"jit_eval({   y <- nv_tensor(c(1, 0, -1))   x <- nv_tensor(c(0, 1, 0))   nv_atan2(y, x) }) #> AnvilTensor #>   1.5708 #>   0.0000 #>  -1.5708 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_bitcast_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Bitcast Conversion — nv_bitcast_convert","title":"Bitcast Conversion — nv_bitcast_convert","text":"Reinterprets bits tensor different data type without modifying underlying data. target type narrower, extra trailing dimension added; wider, last dimension consumed.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_bitcast_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bitcast Conversion — nv_bitcast_convert","text":"","code":"nv_bitcast_convert(operand, dtype)"},{"path":"https://r-xla.github.io/anvil/reference/nv_bitcast_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bitcast Conversion — nv_bitcast_convert","text":"operand (tensorish) Operand. dtype (character(1) | stablehlo::TensorDataType) Target data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_bitcast_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bitcast Conversion — nv_bitcast_convert","text":"tensorish given dtype.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_bitcast_convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bitcast Conversion — nv_bitcast_convert","text":"","code":"jit_eval({   x <- nv_tensor(1L)   nvl_bitcast_convert(x, dtype = \"i8\") }) #> AnvilTensor #>  1 0 0 0 #> [ CPUi8{1,4} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_scalars.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"Broadcast scalar tensors match shape non-scalar tensors. non-scalar tensors must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_scalars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"","code":"nv_broadcast_scalars(...)"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_scalars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"... (tensorish) Tensors broadcast. Scalars broadcast common non-scalar shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_scalars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"(list() tensorish) List broadcasted tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_scalars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   # scalar 1 is broadcast to shape [3]   nv_broadcast_scalars(x, 1) }) #> [[1]] #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]  #>  #> [[2]] #> AnvilTensor #>  1 #>  1 #>  1 #> [ CPUf32?{3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"Broadcasts tensors common shape using NumPy-style broadcasting rules.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"","code":"nv_broadcast_tensors(...)"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"... (tensorish) Tensors broadcast.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"(list() tensorish) List tensors, shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":"broadcasting-rules","dir":"Reference","previous_headings":"","what":"Broadcasting Rules","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"tensors different numbers dimensions, prepend size-1 dimensions shorter shape. dimension: sizes match, keep ; one 1, expand 's size; otherwise raise error.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_tensors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   y <- nv_tensor(c(10, 20, 30))   nv_broadcast_tensors(x, y) }) #> [[1]] #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  #>  #> [[2]] #> AnvilTensor #>  10 20 30 #>  10 20 30 #> [ CPUf32{2,3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_to.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast to Shape — nv_broadcast_to","title":"Broadcast to Shape — nv_broadcast_to","text":"Broadcasts tensor target shape using NumPy-style broadcasting rules.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_to.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast to Shape — nv_broadcast_to","text":"","code":"nv_broadcast_to(operand, shape)"},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_to.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast to Shape — nv_broadcast_to","text":"operand (tensorish) Operand. shape (integer()) Target shape. existing dimension must either match 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_to.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast to Shape — nv_broadcast_to","text":"tensorish given shape data type operand.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_broadcast_to.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broadcast to Shape — nv_broadcast_to","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   nv_broadcast_to(x, shape = c(2, 3)) }) #> AnvilTensor #>  1 2 3 #>  1 2 3 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_cbrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Cube Root — nv_cbrt","title":"Cube Root — nv_cbrt","text":"Element-wise cube root.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_cbrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cube Root — nv_cbrt","text":"","code":"nv_cbrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_cbrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cube Root — nv_cbrt","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_cbrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cube Root — nv_cbrt","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_cbrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cube Root — nv_cbrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 8, 27))   nv_cbrt(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_ceil.html","id":null,"dir":"Reference","previous_headings":"","what":"Ceiling — nv_ceil","title":"Ceiling — nv_ceil","text":"Element-wise ceiling (round toward positive infinity). can also use ceiling().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ceil.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ceiling — nv_ceil","text":"","code":"nv_ceil(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_ceil.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ceiling — nv_ceil","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ceil.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ceiling — nv_ceil","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_ceil.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ceiling — nv_ceil","text":"","code":"jit_eval({   x <- nv_tensor(c(1.2, 2.7, -1.5))   ceiling(x) }) #> AnvilTensor #>   2 #>   3 #>  -1 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":null,"dir":"Reference","previous_headings":"","what":"Clamp — nv_clamp","title":"Clamp — nv_clamp","text":"Element-wise clamp: max(min_val, min(operand, max_val)). Converts min_val max_val data type operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clamp — nv_clamp","text":"","code":"nv_clamp(min_val, operand, max_val)"},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clamp — nv_clamp","text":"min_val, max_val (tensorish) Minimum maximum values (scalar shape operand). operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clamp — nv_clamp","text":"tensorish shape data type input.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clamp — nv_clamp","text":"underlying stableHLO function already broadcasts scalars, need broadcast manually.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_clamp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clamp — nv_clamp","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 0.5, 2))   nv_clamp(nv_scalar(0), x, nv_scalar(1)) }) #> AnvilTensor #>  0.0000 #>  0.5000 #>  1.0000 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_concatenate.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenate — nv_concatenate","title":"Concatenate — nv_concatenate","text":"Concatenates tensors along dimension. Operands promoted common data type scalars broadcast concatenation.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_concatenate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concatenate — nv_concatenate","text":"","code":"nv_concatenate(..., dimension = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/nv_concatenate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concatenate — nv_concatenate","text":"... (tensorish) Tensors concatenate. Must shape except along dimension. dimension (integer(1) | NULL) Dimension along concatenate. NULL (default), assumes inputs 1-D concatenates along dimension 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_concatenate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concatenate — nv_concatenate","text":"tensorish common data type shape matching inputs dimensions except dimension, sum input sizes.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_concatenate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concatenate — nv_concatenate","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   nv_concatenate(x, y) }) #> AnvilTensor #>  1 #>  2 #>  3 #>  4 #>  5 #>  6 #> [ CPUf32{6} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Data Type — nv_convert","title":"Convert Data Type — nv_convert","text":"Converts elements tensor different data type. Returns input unchanged already target type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Data Type — nv_convert","text":"","code":"nv_convert(operand, dtype)"},{"path":"https://r-xla.github.io/anvil/reference/nv_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Data Type — nv_convert","text":"operand (tensorish) Operand. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Data Type — nv_convert","text":"tensorish given dtype shape operand.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Data Type — nv_convert","text":"","code":"jit_eval({   x <- nv_tensor(c(1L, 2L, 3L))   nv_convert(x, dtype = \"f32\") }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_cosine.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine — nv_cosine","title":"Cosine — nv_cosine","text":"Element-wise cosine. can also use cos().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_cosine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine — nv_cosine","text":"","code":"nv_cosine(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_cosine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine — nv_cosine","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_cosine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cosine — nv_cosine","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_cosine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cosine — nv_cosine","text":"","code":"jit_eval({   x <- nv_tensor(c(0, pi / 2, pi))   cos(x) }) #> AnvilTensor #>   1.0000e+00 #>  -4.3711e-08 #>  -1.0000e+00 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Division — nv_div","title":"Division — nv_div","text":"Divides two tensors element-wise. can also use / operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Division — nv_div","text":"","code":"nv_div(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Division — nv_div","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Division — nv_div","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Division — nv_div","text":"","code":"jit_eval({   x <- nv_tensor(c(10, 20, 30))   y <- nv_tensor(c(2, 5, 10))   x / y }) #> AnvilTensor #>  5 #>  4 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_eq.html","id":null,"dir":"Reference","previous_headings":"","what":"Equal — nv_eq","title":"Equal — nv_eq","text":"Element-wise equality comparison. can also use == operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_eq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equal — nv_eq","text":"","code":"nv_eq(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_eq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equal — nv_eq","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_eq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Equal — nv_eq","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_eq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Equal — nv_eq","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(1, 3, 2))   x == y }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential — nv_exp","title":"Exponential — nv_exp","text":"Element-wise exponential. can also use exp().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential — nv_exp","text":"","code":"nv_exp(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential — nv_exp","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_exp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential — nv_exp","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_exp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential — nv_exp","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 1, 2))   exp(x) }) #> AnvilTensor #>  1.0000 #>  2.7183 #>  7.3891 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_expm1.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Minus One — nv_expm1","title":"Exponential Minus One — nv_expm1","text":"Element-wise exp(x) - 1, accurate small x.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_expm1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Minus One — nv_expm1","text":"","code":"nv_expm1(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_expm1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Minus One — nv_expm1","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_expm1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Minus One — nv_expm1","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_expm1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential Minus One — nv_expm1","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.001, 1))   nv_expm1(x) }) #> AnvilTensor #>  0.0000 #>  0.0010 #>  1.7183 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_fill.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill Constant — nv_fill","title":"Fill Constant — nv_fill","text":"Creates tensor filled scalar value. memory-efficient nv_tensor(value, shape = shape) large tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_fill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill Constant — nv_fill","text":"","code":"nv_fill(value, shape, dtype = NULL, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_fill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill Constant — nv_fill","text":"value (numeric(1)) Scalar value fill tensor . shape (integer()) Shape output tensor. dtype (character(1) | NULL) Data type. NULL (default), inferred value. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_fill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill Constant — nv_fill","text":"tensorish given shape dtype.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_fill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill Constant — nv_fill","text":"","code":"jit_eval(nv_fill(0, shape = c(2, 3))) #> AnvilTensor #>  0 0 0 #>  0 0 0 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_floor.html","id":null,"dir":"Reference","previous_headings":"","what":"Floor — nv_floor","title":"Floor — nv_floor","text":"Element-wise floor (round toward negative infinity). can also use floor().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_floor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Floor — nv_floor","text":"","code":"nv_floor(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_floor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Floor — nv_floor","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_floor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Floor — nv_floor","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_floor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Floor — nv_floor","text":"","code":"jit_eval({   x <- nv_tensor(c(1.2, 2.7, -1.5))   floor(x) }) #> AnvilTensor #>   1 #>   2 #>  -2 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_ge.html","id":null,"dir":"Reference","previous_headings":"","what":"Greater Than or Equal — nv_ge","title":"Greater Than or Equal — nv_ge","text":"Element-wise greater equal comparison. can also use >= operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greater Than or Equal — nv_ge","text":"","code":"nv_ge(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_ge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greater Than or Equal — nv_ge","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greater Than or Equal — nv_ge","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_ge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Greater Than or Equal — nv_ge","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   x >= y }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Greater Than — nv_gt","title":"Greater Than — nv_gt","text":"Element-wise greater comparison. can also use > operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greater Than — nv_gt","text":"","code":"nv_gt(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greater Than — nv_gt","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greater Than — nv_gt","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Greater Than — nv_gt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   x > y }) #> AnvilTensor #>  0 #>  0 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Branching — nv_if","title":"Conditional Branching — nv_if","text":"Conditional execution two branches. Unlike nv_ifelse(), selects elements, executes one two branches depending scalar predicate.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Branching — nv_if","text":"","code":"nv_if(pred, true, false)"},{"path":"https://r-xla.github.io/anvil/reference/nv_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Branching — nv_if","text":"pred (tensorish boolean type, scalar) Predicate. true (expression) Expression true branch (non-standard evaluation). false (expression) Expression false branch (non-standard evaluation). Must return outputs shapes true branch.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Branching — nv_if","text":"Result executed branch.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_if.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Branching — nv_if","text":"","code":"jit_eval(nv_if(nv_scalar(TRUE), nv_scalar(1), nv_scalar(2))) #> AnvilTensor #>  1 #> [ CPUf32{} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_ifelse.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Element Selection — nv_ifelse","title":"Conditional Element Selection — nv_ifelse","text":"Selects elements true_value false_value based pred, analogous R's ifelse().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ifelse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Element Selection — nv_ifelse","text":"","code":"nv_ifelse(pred, true_value, false_value)"},{"path":"https://r-xla.github.io/anvil/reference/nv_ifelse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Element Selection — nv_ifelse","text":"pred (tensorish boolean type) Predicate tensor. Must scalar shape true_value. true_value (tensorish) Values return pred TRUE. false_value (tensorish) Values return pred FALSE. Must shape data type true_value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ifelse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Element Selection — nv_ifelse","text":"tensorish shape data type true_value.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_ifelse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Element Selection — nv_ifelse","text":"","code":"jit_eval({   pred <- nv_tensor(c(TRUE, FALSE, TRUE))   nv_ifelse(pred, nv_tensor(c(1, 2, 3)), nv_tensor(c(4, 5, 6))) }) #> AnvilTensor #>  1 #>  5 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_iota.html","id":null,"dir":"Reference","previous_headings":"","what":"Iota — nv_iota","title":"Iota — nv_iota","text":"Creates tensor values increasing along specified dimension, starting start.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_iota.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iota — nv_iota","text":"","code":"nv_iota(dim, dtype, shape, start = 1L, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_iota.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iota — nv_iota","text":"dim (integer(1)) Dimension along values increase. dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape. start (integer(1)) Starting value (default 1). ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_iota.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iota — nv_iota","text":"tensorish given dtype shape.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_iota.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iota — nv_iota","text":"","code":"jit_eval(nv_iota(dim = 1L, dtype = \"i32\", shape = 5L)) #> AnvilTensor #>  1 #>  2 #>  3 #>  4 #>  5 #> [ CPUi32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_is_finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Is Finite — nv_is_finite","title":"Is Finite — nv_is_finite","text":"Element-wise check values finite (Inf, -Inf, NaN).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_is_finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is Finite — nv_is_finite","text":"","code":"nv_is_finite(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_is_finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is Finite — nv_is_finite","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_is_finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is Finite — nv_is_finite","text":"tensorish shape input boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_is_finite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is Finite — nv_is_finite","text":"","code":"jit_eval({   x <- nv_tensor(c(1, Inf, NaN, -Inf, 0))   nv_is_finite(x) }) #> AnvilTensor #>  1 #>  0 #>  0 #>  0 #>  1 #> [ CPUi1{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_le.html","id":null,"dir":"Reference","previous_headings":"","what":"Less Than or Equal — nv_le","title":"Less Than or Equal — nv_le","text":"Element-wise less equal comparison. can also use <= operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_le.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Less Than or Equal — nv_le","text":"","code":"nv_le(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_le.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Less Than or Equal — nv_le","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_le.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Less Than or Equal — nv_le","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_le.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Less Than or Equal — nv_le","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   x <= y }) #> AnvilTensor #>  1 #>  1 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Natural Logarithm — nv_log","title":"Natural Logarithm — nv_log","text":"Element-wise natural logarithm. can also use log().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Natural Logarithm — nv_log","text":"","code":"nv_log(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Natural Logarithm — nv_log","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Natural Logarithm — nv_log","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_log.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Natural Logarithm — nv_log","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2.718, 7.389))   log(x) }) #> AnvilTensor #>  0.0000 #>  0.9999 #>  2.0000 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Plus One — nv_log1p","title":"Log Plus One — nv_log1p","text":"Element-wise log(1 + x), accurate small x.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Plus One — nv_log1p","text":"","code":"nv_log1p(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Plus One — nv_log1p","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Plus One — nv_log1p","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_log1p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log Plus One — nv_log1p","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.001, 1))   nv_log1p(x) }) #> AnvilTensor #>  0.0000 #>  0.0010 #>  0.6931 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic (Sigmoid) — nv_logistic","title":"Logistic (Sigmoid) — nv_logistic","text":"Element-wise logistic sigmoid: 1 / (1 + exp(-x)).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic (Sigmoid) — nv_logistic","text":"","code":"nv_logistic(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic (Sigmoid) — nv_logistic","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logistic (Sigmoid) — nv_logistic","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_logistic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logistic (Sigmoid) — nv_logistic","text":"","code":"jit_eval({   x <- nv_tensor(c(-2, 0, 2))   nv_logistic(x) }) #> AnvilTensor #>  0.1192 #>  0.5000 #>  0.8808 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Less Than — nv_lt","title":"Less Than — nv_lt","text":"Element-wise less comparison. can also use < operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Less Than — nv_lt","text":"","code":"nv_lt(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Less Than — nv_lt","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Less Than — nv_lt","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_lt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Less Than — nv_lt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   x < y }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Multiplication — nv_matmul","title":"Matrix Multiplication — nv_matmul","text":"Matrix multiplication two tensors. can also use %*% operator. Supports batched matrix multiplication inputs 2 dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Multiplication — nv_matmul","text":"","code":"nv_matmul(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Multiplication — nv_matmul","text":"lhs, rhs (tensorish) Tensors least 2 dimensions. Operands promoted common data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Multiplication — nv_matmul","text":"tensorish","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":"shapes","dir":"Reference","previous_headings":"","what":"Shapes","title":"Matrix Multiplication — nv_matmul","text":"lhs: (b1, ..., bk, m, n) rhs: (b1, ..., bk, n, p) output: (b1, ..., bk, m, p)","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_matmul.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Multiplication — nv_matmul","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   y <- nv_tensor(matrix(1:6, nrow = 3))   x %*% y }) #> AnvilTensor #>  22 49 #>  28 64 #> [ CPUi32{2,2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum — nv_max","title":"Maximum — nv_max","text":"Element-wise maximum two tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum — nv_max","text":"","code":"nv_max(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum — nv_max","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum — nv_max","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_max.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum — nv_max","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 5, 3))   y <- nv_tensor(c(4, 2, 6))   nv_max(x, y) }) #> AnvilTensor #>  4 #>  5 #>  6 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum — nv_min","title":"Minimum — nv_min","text":"Element-wise minimum two tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum — nv_min","text":"","code":"nv_min(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum — nv_min","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum — nv_min","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum — nv_min","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 5, 3))   y <- nv_tensor(c(4, 2, 6))   nv_min(x, y) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiplication — nv_mul","title":"Multiplication — nv_mul","text":"Multiplies two tensors element-wise. can also use * operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiplication — nv_mul","text":"","code":"nv_mul(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiplication — nv_mul","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiplication — nv_mul","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_mul.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiplication — nv_mul","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   x * y }) #> AnvilTensor #>   4 #>  10 #>  18 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_ne.html","id":null,"dir":"Reference","previous_headings":"","what":"Not Equal — nv_ne","title":"Not Equal — nv_ne","text":"Element-wise inequality comparison. can also use != operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Not Equal — nv_ne","text":"","code":"nv_ne(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_ne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Not Equal — nv_ne","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_ne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Not Equal — nv_ne","text":"tensorish shape inputs boolean data type.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_ne.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Not Equal — nv_ne","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(1, 3, 2))   x != y }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_negate.html","id":null,"dir":"Reference","previous_headings":"","what":"Negation — nv_negate","title":"Negation — nv_negate","text":"Negates tensor element-wise. can also use unary - operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_negate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negation — nv_negate","text":"","code":"nv_negate(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_negate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negation — nv_negate","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_negate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negation — nv_negate","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_negate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negation — nv_negate","text":"","code":"jit_eval({   x <- nv_tensor(c(1, -2, 3))   -x }) #> AnvilTensor #>  -1 #>   2 #>  -3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Not — nv_not","title":"Logical Not — nv_not","text":"Element-wise logical . can also use ! operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Not — nv_not","text":"","code":"nv_not(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Not — nv_not","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Not — nv_not","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical Not — nv_not","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   !x }) #> AnvilTensor #>  0 #>  1 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Or — nv_or","title":"Logical Or — nv_or","text":"Element-wise logical . can also use | operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Or — nv_or","text":"","code":"nv_or(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Or — nv_or","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Or — nv_or","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_or.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical Or — nv_or","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   x | y }) #> AnvilTensor #>  1 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_pad.html","id":null,"dir":"Reference","previous_headings":"","what":"Pad — nv_pad","title":"Pad — nv_pad","text":"Pads tensor given value edges optionally elements.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_pad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pad — nv_pad","text":"","code":"nv_pad(   operand,   padding_value,   edge_padding_low,   edge_padding_high,   interior_padding = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/nv_pad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pad — nv_pad","text":"operand (tensorish) Operand. padding_value (tensorish) Scalar value use padding. Must dtype operand. edge_padding_low (integer()) Amount padding add start dimension. edge_padding_high (integer()) Amount padding add end dimension. interior_padding (integer() | NULL) Amount padding add elements dimension. NULL (default), interior padding applied.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_pad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pad — nv_pad","text":"tensorish data type operand.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_pad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pad — nv_pad","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   nv_pad(x, nv_scalar(0), edge_padding_low = 2L, edge_padding_high = 1L) }) #> AnvilTensor #>  0 #>  0 #>  1 #>  2 #>  3 #>  0 #> [ CPUf32{6} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_popcnt.html","id":null,"dir":"Reference","previous_headings":"","what":"Population Count — nv_popcnt","title":"Population Count — nv_popcnt","text":"Element-wise population count (number set bits).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_popcnt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Population Count — nv_popcnt","text":"","code":"nv_popcnt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_popcnt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Population Count — nv_popcnt","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_popcnt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Population Count — nv_popcnt","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_popcnt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Population Count — nv_popcnt","text":"","code":"jit_eval({   x <- nv_tensor(c(7L, 3L, 15L))   nv_popcnt(x) }) #> AnvilTensor #>  3 #>  2 #>  4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_pow.html","id":null,"dir":"Reference","previous_headings":"","what":"Power — nv_pow","title":"Power — nv_pow","text":"Raises lhs power rhs element-wise. can also use ^ operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_pow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power — nv_pow","text":"","code":"nv_pow(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_pow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power — nv_pow","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_pow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power — nv_pow","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_pow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power — nv_pow","text":"","code":"jit_eval({   x <- nv_tensor(c(2, 3, 4))   y <- nv_tensor(c(3, 2, 1))   x ^ y }) #> AnvilTensor #>  8 #>  9 #>  4 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Tensor — nv_print","title":"Print Tensor — nv_print","text":"Prints tensor value console JIT execution returns input unchanged. Useful debugging.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Tensor — nv_print","text":"","code":"nv_print(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Tensor — nv_print","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Tensor — nv_print","text":"tensorish Returns operand unchanged.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Print Tensor — nv_print","text":"Currently works CPU backend.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Tensor — nv_print","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3), device = \"cpu\")   nv_print(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ f32{3} ] #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_promote_to_common.html","id":null,"dir":"Reference","previous_headings":"","what":"Promote Tensors to a Common Dtype — nv_promote_to_common","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"Promote tensors common data type, see common_dtype details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_promote_to_common.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"","code":"nv_promote_to_common(...)"},{"path":"https://r-xla.github.io/anvil/reference/nv_promote_to_common.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"... (tensorish) Tensors promote.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_promote_to_common.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"(list() tensorish)","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_promote_to_common.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"","code":"jit_eval({   x <- nv_tensor(1L)   y <- nv_tensor(1.5)   # integer is promoted to float   nv_promote_to_common(x, y) }) #> [[1]] #> AnvilTensor #>  1 #> [ CPUf32{1} ]  #>  #> [[2]] #> AnvilTensor #>  1.5000 #> [ CPUf32{1} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_rbinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Binomial Distribution — nv_rbinom","title":"Sample from a Binomial Distribution — nv_rbinom","text":"Samples binomial distribution \\(n\\) trials success probability \\(p\\). n = 1 (default), Bernoulli distribution.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rbinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Binomial Distribution — nv_rbinom","text":"","code":"nv_rbinom(shape, initial_state, n = 1L, prob = 0.5, dtype = \"i32\")"},{"path":"https://r-xla.github.io/anvil/reference/nv_rbinom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Binomial Distribution — nv_rbinom","text":"shape (integer()) Shape. initial_state (tensorish) RNG state (ui64[2]). n (integer(1)) Number trials. prob (numeric(1)) Probability success trial. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rbinom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Binomial Distribution — nv_rbinom","text":"(list() tensorish) List two elements: updated RNG state sampled values.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_rbinom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a Binomial Distribution — nv_rbinom","text":"","code":"jit_eval({   state <- nv_rng_state(42L)   # Bernoulli samples   result <- nv_rbinom(c(2, 3), state)   result[[2]] }) #> AnvilTensor #>  0 0 1 #>  0 1 1 #> [ CPUi32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_rdunif.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Discrete Uniform Distribution — nv_rdunif","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"Samples integers 1 n equal probability (replacement), analogous R's sample.int(n, size, replace = TRUE).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rdunif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"","code":"nv_rdunif(shape, initial_state, n, dtype = \"i32\")"},{"path":"https://r-xla.github.io/anvil/reference/nv_rdunif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"shape (integer()) Shape. initial_state (tensorish) RNG state (ui64[2]). n (integer(1)) Number categories (samples integers 1 n). dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rdunif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"(list() tensorish) List two elements: updated RNG state sampled integers.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_rdunif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"","code":"jit_eval({   state <- nv_rng_state(42L)   # Roll 6 dice   result <- nv_rdunif(6, state, n = 6L)   result[[2]] }) #> AnvilTensor #>  3 #>  5 #>  1 #>  4 #>  1 #>  1 #> [ CPUi32{6} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read tensors from a file — nv_read","title":"Read tensors from a file — nv_read","text":"Loads tensors file safetensors format.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read tensors from a file — nv_read","text":"","code":"nv_read(path, device = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read tensors from a file — nv_read","text":"path (character(1)) Path safetensors file. device (NULL | character(1) | PJRTDevice) device place loaded tensors (\"cpu\", \"cuda\", ...). Default use CPU.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read tensors from a file — nv_read","text":"Named list AnvilTensor objects.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read tensors from a file — nv_read","text":"convenience wrapper around nv_unserialize() opens closes file connection.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read tensors from a file — nv_read","text":"","code":"x <- nv_tensor(array(1:6, dim = c(2, 3))) x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  path <- tempfile(fileext = \".safetensors\") nv_save(list(x = x), path) nv_read(path) #> $x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_all.html","id":null,"dir":"Reference","previous_headings":"","what":"All Reduction — nv_reduce_all","title":"All Reduction — nv_reduce_all","text":"Performs logical along specified dimensions. Returns TRUE elements TRUE.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All Reduction — nv_reduce_all","text":"","code":"nv_reduce_all(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"All Reduction — nv_reduce_all","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All Reduction — nv_reduce_all","text":"tensorish Boolean tensor. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"All Reduction — nv_reduce_all","text":"","code":"jit_eval({   x <- nv_tensor(matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2))   nv_reduce_all(x, dims = 1L) }) #> AnvilTensor #>  0 #>  1 #> [ CPUi1{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Any Reduction — nv_reduce_any","title":"Any Reduction — nv_reduce_any","text":"Performs logical along specified dimensions. Returns TRUE element TRUE.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Any Reduction — nv_reduce_any","text":"","code":"nv_reduce_any(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Any Reduction — nv_reduce_any","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Any Reduction — nv_reduce_any","text":"tensorish Boolean tensor. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_any.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Any Reduction — nv_reduce_any","text":"","code":"jit_eval({   x <- nv_tensor(matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2))   nv_reduce_any(x, dims = 1L) }) #> AnvilTensor #>  1 #>  1 #> [ CPUi1{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Max Reduction — nv_reduce_max","title":"Max Reduction — nv_reduce_max","text":"Finds maximum tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Max Reduction — nv_reduce_max","text":"","code":"nv_reduce_max(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Max Reduction — nv_reduce_max","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Max Reduction — nv_reduce_max","text":"tensorish data type input. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_max.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Max Reduction — nv_reduce_max","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nv_reduce_max(x, dims = 1L) }) #> AnvilTensor #>  2 #>  4 #>  6 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Reduction — nv_reduce_mean","title":"Mean Reduction — nv_reduce_mean","text":"Computes arithmetic mean along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Reduction — nv_reduce_mean","text":"","code":"nv_reduce_mean(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Reduction — nv_reduce_mean","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Reduction — nv_reduce_mean","text":"tensorish data type input. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mean Reduction — nv_reduce_mean","text":"Implemented nv_reduce_sum(operand, dims, drop) / n n product reduced dimension sizes.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean Reduction — nv_reduce_mean","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nv_reduce_mean(x, dims = 1L) }) #> AnvilTensor #>  1.5000 #>  3.5000 #>  5.5000 #> [ CPUf32?{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Min Reduction — nv_reduce_min","title":"Min Reduction — nv_reduce_min","text":"Finds minimum tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Min Reduction — nv_reduce_min","text":"","code":"nv_reduce_min(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Min Reduction — nv_reduce_min","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Min Reduction — nv_reduce_min","text":"tensorish data type input. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Min Reduction — nv_reduce_min","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nv_reduce_min(x, dims = 1L) }) #> AnvilTensor #>  1 #>  3 #>  5 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_prod.html","id":null,"dir":"Reference","previous_headings":"","what":"Product Reduction — nv_reduce_prod","title":"Product Reduction — nv_reduce_prod","text":"Multiplies tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_prod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Product Reduction — nv_reduce_prod","text":"","code":"nv_reduce_prod(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_prod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Product Reduction — nv_reduce_prod","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_prod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Product Reduction — nv_reduce_prod","text":"tensorish data type input. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_prod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Product Reduction — nv_reduce_prod","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nv_reduce_prod(x, dims = 1L) }) #> AnvilTensor #>   2 #>  12 #>  30 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Sum Reduction — nv_reduce_sum","title":"Sum Reduction — nv_reduce_sum","text":"Sums tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum Reduction — nv_reduce_sum","text":"","code":"nv_reduce_sum(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum Reduction — nv_reduce_sum","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sum Reduction — nv_reduce_sum","text":"tensorish data type input. drop = TRUE, reduced dimensions removed. drop = FALSE, reduced dimensions set 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reduce_sum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sum Reduction — nv_reduce_sum","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nv_reduce_sum(x, dims = 1L) }) #> AnvilTensor #>   3 #>   7 #>  11 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_remainder.html","id":null,"dir":"Reference","previous_headings":"","what":"Remainder — nv_remainder","title":"Remainder — nv_remainder","text":"Element-wise remainder division. can also use %% operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_remainder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remainder — nv_remainder","text":"","code":"nv_remainder(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_remainder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remainder — nv_remainder","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_remainder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remainder — nv_remainder","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_remainder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remainder — nv_remainder","text":"","code":"jit_eval({   x <- nv_tensor(c(7, 8, 9))   y <- nv_tensor(c(3, 3, 4))   x %% y }) #> AnvilTensor #>  1 #>  2 #>  1 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshape — nv_reshape","title":"Reshape — nv_reshape","text":"Reshapes tensor new shape without changing underlying data. Returns input unchanged already target shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshape — nv_reshape","text":"","code":"nv_reshape(operand, shape)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshape — nv_reshape","text":"operand (tensorish) Operand. shape (integer()) Target shape. Must number elements operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshape — nv_reshape","text":"tensorish given shape data type operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reshape — nv_reshape","text":"Note row-major order used, differs R's column-major order.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reshape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reshape — nv_reshape","text":"","code":"jit_eval({   x <- nv_tensor(1:6)   nv_reshape(x, c(2, 3)) }) #> AnvilTensor #>  1 2 3 #>  4 5 6 #> [ CPUi32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse — nv_reverse","title":"Reverse — nv_reverse","text":"Reverses order elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse — nv_reverse","text":"","code":"nv_reverse(operand, dims)"},{"path":"https://r-xla.github.io/anvil/reference/nv_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse — nv_reverse","text":"operand (tensorish) Operand. dims (integer()) Dimensions reverse.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse — nv_reverse","text":"tensorish shape data type operand.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_reverse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse — nv_reverse","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3, 4, 5))   nv_reverse(x, dims = 1L) }) #> AnvilTensor #>  5 #>  4 #>  3 #>  2 #>  1 #> [ CPUf32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_rng_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate RNG State — nv_rng_state","title":"Generate RNG State — nv_rng_state","text":"Creates initial RNG state seed. state required random sampling functions updated call.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rng_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate RNG State — nv_rng_state","text":"","code":"nv_rng_state(seed)"},{"path":"https://r-xla.github.io/anvil/reference/nv_rng_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate RNG State — nv_rng_state","text":"seed (integer(1)) Seed value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rng_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate RNG State — nv_rng_state","text":"nv_tensor dtype ui64 shape (2).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_rng_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate RNG State — nv_rng_state","text":"","code":"jit_eval({   state <- nv_rng_state(42L)   state }) #> AnvilTensor #>  42 #>   0 #> [ CPUui64{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Normal Distribution — nv_rnorm","title":"Sample from a Normal Distribution — nv_rnorm","text":"Samples normal distribution mean \\(\\mu\\) standard deviation \\(\\sigma\\) using Box-Muller transform.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Normal Distribution — nv_rnorm","text":"","code":"nv_rnorm(shape, initial_state, dtype = \"f32\", mu = 0, sigma = 1)"},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Normal Distribution — nv_rnorm","text":"shape (integer()) Shape. initial_state (tensorish) RNG state (ui64[2]). dtype (character(1) | stablehlo::TensorDataType) Data type. mu (tensorish) Mean. sigma (tensorish) Standard deviation. Must positive, otherwise results invalid.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Normal Distribution — nv_rnorm","text":"(list() tensorish) List two elements: updated RNG state sampled values.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":"covariance","dir":"Reference","previous_headings":"","what":"Covariance","title":"Sample from a Normal Distribution — nv_rnorm","text":"implement covariance structure use Cholesky decomposition.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_rnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a Normal Distribution — nv_rnorm","text":"","code":"jit_eval({   state <- nv_rng_state(42L)   result <- nv_rnorm(c(2, 3), state)   result[[2]] }) #> AnvilTensor #>  -0.0675  0.9489  1.9457 #>  -0.5255  1.2002  0.0008 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_round.html","id":null,"dir":"Reference","previous_headings":"","what":"Round — nv_round","title":"Round — nv_round","text":"Element-wise rounding. can also use round() generic.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_round.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Round — nv_round","text":"","code":"nv_round(operand, method = \"nearest_even\")"},{"path":"https://r-xla.github.io/anvil/reference/nv_round.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Round — nv_round","text":"operand (tensorish) Operand. method (character(1)) Rounding method. Either \"nearest_even\" (default) \"afz\" (away zero).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_round.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Round — nv_round","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_round.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Round — nv_round","text":"","code":"jit_eval({   x <- nv_tensor(c(1.4, 2.5, 3.6))   round(x) }) #> AnvilTensor #>  1 #>  2 #>  4 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_rsqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Reciprocal Square Root — nv_rsqrt","title":"Reciprocal Square Root — nv_rsqrt","text":"Element-wise reciprocal square root, .e. 1 / sqrt(x).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rsqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reciprocal Square Root — nv_rsqrt","text":"","code":"nv_rsqrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_rsqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reciprocal Square Root — nv_rsqrt","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_rsqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reciprocal Square Root — nv_rsqrt","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_rsqrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reciprocal Square Root — nv_rsqrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 4, 9))   nv_rsqrt(x) }) #> AnvilTensor #>  1.0000 #>  0.5000 #>  0.3333 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Uniform Distribution — nv_runif","title":"Sample from a Uniform Distribution — nv_runif","text":"Samples uniform distribution open interval (lower, upper).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Uniform Distribution — nv_runif","text":"","code":"nv_runif(shape, initial_state, dtype = \"f32\", lower = 0, upper = 1)"},{"path":"https://r-xla.github.io/anvil/reference/nv_runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Uniform Distribution — nv_runif","text":"shape (integer()) Shape. initial_state (tensorish) RNG state (ui64[2]). dtype (character(1) | stablehlo::TensorDataType) Data type. lower, upper (numeric(1)) Lower upper bound.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Uniform Distribution — nv_runif","text":"(list() tensorish) List two elements: updated RNG state sampled values.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a Uniform Distribution — nv_runif","text":"","code":"jit_eval({   state <- nv_rng_state(42L)   result <- nv_runif(c(2, 3), state)   result[[2]] }) #> AnvilTensor #>  0.8690 0.1506 0.5203 #>  0.3103 0.9928 0.1065 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Save tensors to a file — nv_save","title":"Save tensors to a file — nv_save","text":"Saves named list tensors file safetensors format.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save tensors to a file — nv_save","text":"","code":"nv_save(tensors, path)"},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save tensors to a file — nv_save","text":"tensors (named list AnvilTensor) Named list tensors save. Names must unique. path (character(1)) File path write .","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save tensors to a file — nv_save","text":"NULL (invisibly).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save tensors to a file — nv_save","text":"convenience wrapper around nv_serialize() opens closes file connection.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_save.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save tensors to a file — nv_save","text":"","code":"x <- nv_tensor(array(1:6, dim = c(2, 3))) x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  path <- tempfile(fileext = \".safetensors\") nv_save(list(x = x), path) nv_read(path) #> $x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequence — nv_seq","title":"Sequence — nv_seq","text":"Creates 1-D tensor integer values start end (inclusive), analogous R's seq(start, end).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequence — nv_seq","text":"","code":"nv_seq(start, end, dtype = \"i32\", ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nv_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequence — nv_seq","text":"start, end (integer(1)) Start end values. Must satisfy start <= end. dtype (character(1) | stablehlo::TensorDataType) Data type. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequence — nv_seq","text":"tensorish 1-D tensor length end - start + 1.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequence — nv_seq","text":"","code":"jit_eval(nv_seq(3, 7)) #> AnvilTensor #>  3 #>  4 #>  5 #>  6 #>  7 #> [ CPUi32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize tensors to raw bytes — nv_serialize","title":"Serialize tensors to raw bytes — nv_serialize","text":"Serializes named list tensors safetensors format.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize tensors to raw bytes — nv_serialize","text":"","code":"nv_serialize(tensors, con = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serialize tensors to raw bytes — nv_serialize","text":"tensors (named list AnvilTensor) Named list tensors serialize. Names must unique. con (NULL | connection) optional connection write . NULL (default), raw vector returned.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serialize tensors to raw bytes — nv_serialize","text":"raw vector con NULL, otherwise NULL (invisibly).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Serialize tensors to raw bytes — nv_serialize","text":"ambiguity tensors stored metadata preserved write-read roundtrips.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_serialize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serialize tensors to raw bytes — nv_serialize","text":"","code":"x <- nv_tensor(array(1:6, dim = c(2, 3))) x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  raw_data <- nv_serialize(list(x = x)) raw_data #>   [1] 0c 01 00 00 00 00 00 00 7b 22 78 22 3a 7b 22 73 68 61 70 65 22 3a 5b 32 2c #>  [26] 33 5d 2c 22 64 74 79 70 65 22 3a 22 49 33 32 22 2c 22 64 61 74 61 5f 6f 66 #>  [51] 66 73 65 74 73 22 3a 5b 30 2c 32 34 5d 7d 2c 22 5f 5f 6d 65 74 61 64 61 74 #>  [76] 61 5f 5f 22 3a 7b 22 5f 5f 61 6d 62 69 67 75 69 74 79 5f 69 6e 66 6f 5f 5f #> [101] 22 3a 22 35 38 30 61 30 30 30 30 30 30 30 33 30 30 30 34 30 35 30 32 30 30 #> [126] 30 33 30 35 30 30 30 30 30 30 30 30 30 35 35 35 35 34 34 36 32 64 33 38 30 #> [151] 30 30 30 30 32 31 33 30 30 30 30 30 30 30 31 30 30 30 30 30 30 30 61 30 30 #> [176] 30 30 30 30 30 31 30 30 30 30 30 30 30 30 30 30 30 30 30 34 30 32 30 30 30 #> [201] 30 30 30 30 31 30 30 30 34 30 30 30 39 30 30 30 30 30 30 30 35 36 65 36 31 #> [226] 36 64 36 35 37 33 30 30 30 30 30 30 31 30 30 30 30 30 30 30 30 31 30 30 30 #> [251] 34 30 30 30 39 30 30 30 30 30 30 30 31 37 38 30 30 30 30 30 30 66 65 22 7d #> [276] 7d 01 00 00 00 03 00 00 00 05 00 00 00 02 00 00 00 04 00 00 00 06 00 00 00 nv_unserialize(raw_data) #> $x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_left.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift Left — nv_shift_left","title":"Shift Left — nv_shift_left","text":"Element-wise left bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift Left — nv_shift_left","text":"","code":"nv_shift_left(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift Left — nv_shift_left","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_left.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift Left — nv_shift_left","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_left.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shift Left — nv_shift_left","text":"","code":"jit_eval({   x <- nv_tensor(c(1L, 2L, 4L))   y <- nv_tensor(c(1L, 2L, 1L))   nv_shift_left(x, y) }) #> AnvilTensor #>  2 #>  8 #>  8 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Shift Right — nv_shift_right_arithmetic","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"Element-wise arithmetic right bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"","code":"nv_shift_right_arithmetic(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_arithmetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"","code":"jit_eval({   x <- nv_tensor(c(8L, -16L, 32L))   y <- nv_tensor(c(1L, 2L, 3L))   nv_shift_right_arithmetic(x, y) }) #> AnvilTensor #>   4 #>  -4 #>   4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Shift Right — nv_shift_right_logical","title":"Logical Shift Right — nv_shift_right_logical","text":"Element-wise logical right bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Shift Right — nv_shift_right_logical","text":"","code":"nv_shift_right_logical(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Shift Right — nv_shift_right_logical","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Shift Right — nv_shift_right_logical","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_shift_right_logical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical Shift Right — nv_shift_right_logical","text":"","code":"jit_eval({   x <- nv_tensor(c(8L, 16L, 32L))   y <- nv_tensor(c(1L, 2L, 3L))   nv_shift_right_logical(x, y) }) #> AnvilTensor #>  4 #>  4 #>  4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_sign.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign — nv_sign","title":"Sign — nv_sign","text":"Element-wise sign function. can also use sign().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign — nv_sign","text":"","code":"nv_sign(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_sign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign — nv_sign","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sign — nv_sign","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_sign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sign — nv_sign","text":"","code":"jit_eval({   x <- nv_tensor(c(-3, 0, 5))   sign(x) }) #> AnvilTensor #>  -1 #>   0 #>   1 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_sine.html","id":null,"dir":"Reference","previous_headings":"","what":"Sine — nv_sine","title":"Sine — nv_sine","text":"Element-wise sine. can also use sin().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sine — nv_sine","text":"","code":"nv_sine(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_sine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sine — nv_sine","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sine — nv_sine","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_sine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sine — nv_sine","text":"","code":"jit_eval({   x <- nv_tensor(c(0, pi / 2, pi))   sin(x) }) #> AnvilTensor #>   0.0000e+00 #>   1.0000e+00 #>  -8.7423e-08 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_sqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Square Root — nv_sqrt","title":"Square Root — nv_sqrt","text":"Element-wise square root. can also use sqrt().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Square Root — nv_sqrt","text":"","code":"nv_sqrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_sqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Square Root — nv_sqrt","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Square Root — nv_sqrt","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_sqrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Square Root — nv_sqrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 4, 9))   sqrt(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_static_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Static Slice — nv_static_slice","title":"Static Slice — nv_static_slice","text":"Extracts slice tensor using static (compile-time) indices. dynamic indexing, use nv_subset() instead.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_static_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Static Slice — nv_static_slice","text":"","code":"nv_static_slice(operand, start_indices, limit_indices, strides)"},{"path":"https://r-xla.github.io/anvil/reference/nv_static_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Static Slice — nv_static_slice","text":"operand (tensorish) Operand. start_indices (integer()) Start indices (inclusive), one per dimension. limit_indices (integer()) End indices (inclusive), one per dimension. strides (integer()) Step sizes, one per dimension. stride 1 selects every element.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_static_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Static Slice — nv_static_slice","text":"tensorish data type operand.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_static_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Static Slice — nv_static_slice","text":"","code":"jit_eval({   x <- nv_tensor(1:10)   nv_static_slice(x, start_indices = 2L, limit_indices = 5L, strides = 1L) }) #> AnvilTensor #>  2 #>  3 #>  4 #>  5 #> [ CPUi32{4} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"Subtraction — nv_sub","title":"Subtraction — nv_sub","text":"Subtracts two tensors element-wise. can also use - operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subtraction — nv_sub","text":"","code":"nv_sub(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_sub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subtraction — nv_sub","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subtraction — nv_sub","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_sub.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subtraction — nv_sub","text":"","code":"jit_eval({   x <- nv_tensor(c(4, 5, 6))   y <- nv_tensor(c(1, 2, 3))   x - y }) #> AnvilTensor #>  3 #>  3 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset a Tensor — [.AnvilBox","title":"Subset a Tensor — [.AnvilBox","text":"Extracts subset tensor. can also use [ operator. Supports R-style indexing including scalar indices (drop dimensions), ranges (:b), list() selecting multiple elements along dimension.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset a Tensor — [.AnvilBox","text":"","code":"# S3 method for class 'AnvilBox' x[...]  # S3 method for class 'AnvilTensor' x[...]  nv_subset(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/nv_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset a Tensor — [.AnvilBox","text":"x (tensorish) Tensor subset. ... Subset specifications, one per dimension. Omitted trailing dimensions select elements. See vignette(\"subsetting\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset a Tensor — [.AnvilBox","text":"tensorish","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset a Tensor — [.AnvilBox","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:12, nrow = 3))   # Select row 2   x[2, ] }) #> AnvilTensor #>   2 #>   5 #>   8 #>  11 #> [ CPUi32{4} ]   jit_eval({   x <- nv_tensor(matrix(1:12, nrow = 3))   # Select rows 1 to 2, all columns   x[1:2, ] }) #> AnvilTensor #>   1  4  7 10 #>   2  5  8 11 #> [ CPUi32{2,4} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_subset_assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Update Subset — [<-.AnvilBox","title":"Update Subset — [<-.AnvilBox","text":"Updates elements tensor specified positions, returning new tensor. can also use [<- operator.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_subset_assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update Subset — [<-.AnvilBox","text":"","code":"# S3 method for class 'AnvilBox' x[...] <- value  # S3 method for class 'AnvilTensor' x[...] <- value  nv_subset_assign(x, ..., value)"},{"path":"https://r-xla.github.io/anvil/reference/nv_subset_assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update Subset — [<-.AnvilBox","text":"x (tensorish) Tensor update. ... Subset specifications, one per dimension. See vignette(\"subsetting\") details. value (tensorish) Replacement values. Scalars broadcast subset shape. Non-scalar values must match subset shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_subset_assign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update Subset — [<-.AnvilBox","text":"tensorish new tensor shape x subset replaced.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_subset_assign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update Subset — [<-.AnvilBox","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:12, nrow = 3))   # Set row 1 to zeros   x[1, ] <- 0L   x }) #> AnvilTensor #>   0  0  0  0 #>   2  5  8 11 #>   3  6  9 12 #> [ CPUi32{3,4} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_tan.html","id":null,"dir":"Reference","previous_headings":"","what":"Tangent — nv_tan","title":"Tangent — nv_tan","text":"Element-wise tangent. can also use tan().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_tan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tangent — nv_tan","text":"","code":"nv_tan(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_tan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tangent — nv_tan","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_tan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tangent — nv_tan","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_tan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tangent — nv_tan","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.5, 1))   tan(x) }) #> AnvilTensor #>  0.0000 #>  0.5463 #>  1.5574 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_tanh.html","id":null,"dir":"Reference","previous_headings":"","what":"Hyperbolic Tangent — nv_tanh","title":"Hyperbolic Tangent — nv_tanh","text":"Element-wise hyperbolic tangent. can also use tanh().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_tanh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hyperbolic Tangent — nv_tanh","text":"","code":"nv_tanh(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nv_tanh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hyperbolic Tangent — nv_tanh","text":"operand (tensorish) Operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_tanh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hyperbolic Tangent — nv_tanh","text":"tensorish shape data type input.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_tanh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hyperbolic Tangent — nv_tanh","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 0, 1))   tanh(x) }) #> AnvilTensor #>  -0.7616 #>   0.0000 #>   0.7616 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose — nv_transpose","title":"Transpose — nv_transpose","text":"Permutes dimensions tensor. can also use t() matrices.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose — nv_transpose","text":"","code":"nv_transpose(x, permutation = NULL)  # S3 method for class 'AnvilBox' t(x)"},{"path":"https://r-xla.github.io/anvil/reference/nv_transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose — nv_transpose","text":"x (tensorish) Tensor transpose. permutation (integer() | NULL) New ordering dimensions. NULL (default), reverses dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose — nv_transpose","text":"tensorish data type x shape nv_shape(x)[permutation].","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transpose — nv_transpose","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   t(x) }) #> AnvilTensor #>  1 2 #>  3 4 #>  5 6 #> [ CPUi32{3,2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize tensors from raw bytes — nv_unserialize","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"Deserializes tensors safetensors format.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"","code":"nv_unserialize(con, device = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"con (connection | raw) connection raw vector read . device (NULL | character(1) | PJRTDevice) device place loaded tensors (\"cpu\", \"cuda\", ...). Default use CPU.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"Named list AnvilTensor objects.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"data type, shape, ambiguity tensor restored serialized data.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_unserialize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deserialize tensors from raw bytes — nv_unserialize","text":"","code":"x <- nv_tensor(array(1:6, dim = c(2, 3))) x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  raw_data <- nv_serialize(list(x = x)) raw_data #>   [1] 0c 01 00 00 00 00 00 00 7b 22 78 22 3a 7b 22 73 68 61 70 65 22 3a 5b 32 2c #>  [26] 33 5d 2c 22 64 74 79 70 65 22 3a 22 49 33 32 22 2c 22 64 61 74 61 5f 6f 66 #>  [51] 66 73 65 74 73 22 3a 5b 30 2c 32 34 5d 7d 2c 22 5f 5f 6d 65 74 61 64 61 74 #>  [76] 61 5f 5f 22 3a 7b 22 5f 5f 61 6d 62 69 67 75 69 74 79 5f 69 6e 66 6f 5f 5f #> [101] 22 3a 22 35 38 30 61 30 30 30 30 30 30 30 33 30 30 30 34 30 35 30 32 30 30 #> [126] 30 33 30 35 30 30 30 30 30 30 30 30 30 35 35 35 35 34 34 36 32 64 33 38 30 #> [151] 30 30 30 30 32 31 33 30 30 30 30 30 30 30 31 30 30 30 30 30 30 30 61 30 30 #> [176] 30 30 30 30 30 31 30 30 30 30 30 30 30 30 30 30 30 30 30 34 30 32 30 30 30 #> [201] 30 30 30 30 31 30 30 30 34 30 30 30 39 30 30 30 30 30 30 30 35 36 65 36 31 #> [226] 36 64 36 35 37 33 30 30 30 30 30 30 31 30 30 30 30 30 30 30 30 31 30 30 30 #> [251] 34 30 30 30 39 30 30 30 30 30 30 30 31 37 38 30 30 30 30 30 30 66 65 22 7d #> [276] 7d 01 00 00 00 03 00 00 00 05 00 00 00 02 00 00 00 04 00 00 00 06 00 00 00 nv_unserialize(raw_data) #> $x #> AnvilTensor #>  1 3 5 #>  2 4 6 #> [ CPUi32{2,3} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_while.html","id":null,"dir":"Reference","previous_headings":"","what":"While Loop — nv_while","title":"While Loop — nv_while","text":"Executes functional loop.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_while.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"While Loop — nv_while","text":"","code":"nv_while(init, cond, body)"},{"path":"https://r-xla.github.io/anvil/reference/nv_while.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"While Loop — nv_while","text":"init (list()) Named list initial state values. cond (function) Condition function returning scalar boolean. Receives state values arguments. body (function) Body function returning updated state named list structure init.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_while.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"While Loop — nv_while","text":"Final state loop terminates (structure init).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_while.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"While Loop — nv_while","text":"","code":"jit_eval({   nv_while(     init = list(i = nv_scalar(0L), total = nv_scalar(0L)),     cond = function(i, total) i < 5L,     body = function(i, total) list(       i = i + 1L,       total = total + i     )   ) }) #> $i #> AnvilTensor #>  5 #> [ CPUi32{} ]  #>  #> $total #> AnvilTensor #>  10 #> [ CPUi32{} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nv_xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Xor — nv_xor","title":"Logical Xor — nv_xor","text":"Element-wise logical XOR.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Xor — nv_xor","text":"","code":"nv_xor(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nv_xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Xor — nv_xor","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nv_xor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Xor — nv_xor","text":"tensorish shape promoted common data type inputs.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nv_xor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical Xor — nv_xor","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   nv_xor(x, y) }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Absolute Value — nvl_abs","title":"Primitive Absolute Value — nvl_abs","text":"Element-wise absolute value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Absolute Value — nvl_abs","text":"","code":"nvl_abs(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Absolute Value — nvl_abs","text":"operand (tensorish) Tensorish value data type signed integer floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Absolute Value — nvl_abs","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Absolute Value — nvl_abs","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Absolute Value — nvl_abs","text":"Lowers stablehlo::hlo_abs().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_abs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Absolute Value — nvl_abs","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 2, -3))   nvl_abs(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Addition — nvl_add","title":"Primitive Addition — nvl_add","text":"Adds two tensors element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Addition — nvl_add","text":"","code":"nvl_add(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Addition — nvl_add","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Addition — nvl_add","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Addition — nvl_add","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Addition — nvl_add","text":"Lowers stablehlo::hlo_add().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Addition — nvl_add","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   nvl_add(x, y) }) #> AnvilTensor #>  5 #>  7 #>  9 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive And — nvl_and","title":"Primitive And — nvl_and","text":"Element-wise logical .","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive And — nvl_and","text":"","code":"nvl_and(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive And — nvl_and","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive And — nvl_and","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive And — nvl_and","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive And — nvl_and","text":"Lowers stablehlo::hlo_and().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_and.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive And — nvl_and","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   nvl_and(x, y) }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Atan2 — nvl_atan2","title":"Primitive Atan2 — nvl_atan2","text":"Element-wise atan2 operation.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Atan2 — nvl_atan2","text":"","code":"nvl_atan2(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Atan2 — nvl_atan2","text":"lhs, rhs (tensorish) Tensorish values data type floating-point. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Atan2 — nvl_atan2","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Atan2 — nvl_atan2","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Atan2 — nvl_atan2","text":"Lowers stablehlo::hlo_atan2().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_atan2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Atan2 — nvl_atan2","text":"","code":"jit_eval({   y <- nv_tensor(c(1, 0, -1))   x <- nv_tensor(c(0, 1, 0))   nvl_atan2(y, x) }) #> AnvilTensor #>   1.5708 #>   0.0000 #>  -1.5708 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Bitcast Convert — nvl_bitcast_convert","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"Reinterprets bits tensor different data type without modifying underlying data.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"","code":"nvl_bitcast_convert(operand, dtype)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"operand (tensorish) Tensorish value data type. dtype (character(1) | stablehlo::TensorDataType) Target data type. bit width input, output shape unchanged. narrower, extra trailing dimension added. wider, last dimension consumed.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"tensorish given dtype.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"Lowers stablehlo::hlo_bitcast_convert().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_bitcast_convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"","code":"jit_eval({   x <- nv_tensor(1L)   nvl_bitcast_convert(x, dtype = \"i8\") }) #> AnvilTensor #>  1 0 0 0 #> [ CPUi8{1,4} ]  jit_eval({   x <- nv_tensor(rep(1L, 4), dtype = \"i8\")   nvl_bitcast_convert(x, dtype = \"i32\") }) #> AnvilTensor #>  1.6843e+07 #> [ CPUi32{} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Broadcast — nvl_broadcast_in_dim","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"Broadcasts tensor new shape replicating data along new size-1 dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"","code":"nvl_broadcast_in_dim(operand, shape, broadcast_dimensions)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"operand (tensorish) Tensorish value data type. shape (integer()) Target shape. mapped dimension must either match corresponding operand dimension operand dimension must 1. broadcast_dimensions (integer()) Maps dimension operand dimension output. Must length equal number dimensions operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"tensorish data type input given shape. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"Lowers stablehlo::hlo_broadcast_in_dim().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_broadcast_in_dim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   nvl_broadcast_in_dim(x, shape = c(2, 3), broadcast_dimensions = 2L) }) #> AnvilTensor #>  1 2 3 #>  1 2 3 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Cube Root — nvl_cbrt","title":"Primitive Cube Root — nvl_cbrt","text":"Element-wise cube root.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Cube Root — nvl_cbrt","text":"","code":"nvl_cbrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Cube Root — nvl_cbrt","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Cube Root — nvl_cbrt","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Cube Root — nvl_cbrt","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Cube Root — nvl_cbrt","text":"Lowers stablehlo::hlo_cbrt().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_cbrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Cube Root — nvl_cbrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 8, 27))   nvl_cbrt(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Ceiling — nvl_ceil","title":"Primitive Ceiling — nvl_ceil","text":"Element-wise ceiling.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Ceiling — nvl_ceil","text":"","code":"nvl_ceil(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Ceiling — nvl_ceil","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Ceiling — nvl_ceil","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Ceiling — nvl_ceil","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Ceiling — nvl_ceil","text":"Lowers stablehlo::hlo_ceil().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_ceil.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Ceiling — nvl_ceil","text":"","code":"jit_eval({   x <- nv_tensor(c(1.2, 2.7, -1.5))   nvl_ceil(x) }) #> AnvilTensor #>   2 #>   3 #>  -1 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Clamp — nvl_clamp","title":"Primitive Clamp — nvl_clamp","text":"Clamps every element operand range [min_val, max_val], .e. max(min_val, min(operand, max_val)).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Clamp — nvl_clamp","text":"","code":"nvl_clamp(min_val, operand, max_val)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Clamp — nvl_clamp","text":"min_val (tensorish) Minimum value. Must scalar shape operand. operand (tensorish) Tensorish value data type. max_val (tensorish) Maximum value. Must scalar shape operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Clamp — nvl_clamp","text":"tensorish data type shape operand. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Clamp — nvl_clamp","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Clamp — nvl_clamp","text":"Lowers stablehlo::hlo_clamp().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_clamp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Clamp — nvl_clamp","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 0.5, 2))   nvl_clamp(nv_scalar(0), x, nv_scalar(1)) }) #> AnvilTensor #>  0.0000 #>  0.5000 #>  1.0000 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Concatenate — nvl_concatenate","title":"Primitive Concatenate — nvl_concatenate","text":"Concatenates tensors along dimension.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Concatenate — nvl_concatenate","text":"","code":"nvl_concatenate(..., dimension)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Concatenate — nvl_concatenate","text":"... (tensorish) Tensors concatenate. Must data type, ndims, shape except along dimension. dimension (integer(1)) Dimension along concatenate (1-indexed).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Concatenate — nvl_concatenate","text":"tensorish data type inputs. output shape matches inputs dimensions except dimension, sum input sizes along dimension. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Concatenate — nvl_concatenate","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Concatenate — nvl_concatenate","text":"Lowers stablehlo::hlo_concatenate().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_concatenate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Concatenate — nvl_concatenate","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   nvl_concatenate(x, y, dimension = 1L) }) #> AnvilTensor #>  1 #>  2 #>  3 #>  4 #>  5 #>  6 #> [ CPUf32{6} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Convert — nvl_convert","title":"Primitive Convert — nvl_convert","text":"Converts elements tensor different data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Convert — nvl_convert","text":"","code":"nvl_convert(operand, dtype, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Convert — nvl_convert","text":"operand (tensorish) Tensorish value data type. dtype (character(1) | stablehlo::TensorDataType) Target data type. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Convert — nvl_convert","text":"tensorish given dtype shape operand. Ambiguity controlled ambiguous parameter.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Convert — nvl_convert","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Convert — nvl_convert","text":"Lowers stablehlo::hlo_convert().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Convert — nvl_convert","text":"","code":"jit_eval({   x <- nv_tensor(c(1L, 2L, 3L))   nvl_convert(x, dtype = \"f32\") }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Cosine — nvl_cosine","title":"Primitive Cosine — nvl_cosine","text":"Element-wise cosine.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Cosine — nvl_cosine","text":"","code":"nvl_cosine(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Cosine — nvl_cosine","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Cosine — nvl_cosine","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Cosine — nvl_cosine","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Cosine — nvl_cosine","text":"Lowers stablehlo::hlo_cosine().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_cosine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Cosine — nvl_cosine","text":"","code":"jit_eval({   x <- nv_tensor(c(0, pi / 2, pi))   nvl_cosine(x) }) #> AnvilTensor #>   1.0000e+00 #>  -4.3711e-08 #>  -1.0000e+00 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Division — nvl_div","title":"Primitive Division — nvl_div","text":"Divides two tensors element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Division — nvl_div","text":"","code":"nvl_div(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Division — nvl_div","text":"lhs, rhs (tensorish) Tensorish values data type integer, unsigned integer, floating-point. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Division — nvl_div","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Division — nvl_div","text":"Lowers stablehlo::hlo_divide().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Division — nvl_div","text":"","code":"jit_eval({   x <- nv_tensor(c(10, 20, 30))   y <- nv_tensor(c(2, 5, 10))   nvl_div(x, y) }) #> AnvilTensor #>  5 #>  4 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Dot General — nvl_dot_general","title":"Primitive Dot General — nvl_dot_general","text":"General dot product two tensors, supporting contraction arbitrary dimensions batching.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Dot General — nvl_dot_general","text":"","code":"nvl_dot_general(lhs, rhs, contracting_dims, batching_dims)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Dot General — nvl_dot_general","text":"lhs, rhs (tensorish) Left right operand. Operands promoted common data type. Scalars broadcast shape operand. contracting_dims (list(integer(), integer())) list two integer vectors specifying dimensions lhs rhs contract . contracted dimensions must matching sizes. batching_dims (list(integer(), integer())) list two integer vectors specifying dimensions lhs rhs batch dimensions. must matching sizes.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Dot General — nvl_dot_general","text":"tensorish output shape batch dimensions followed remaining (non-contracted, non-batched) dimensions lhs, rhs.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Dot General — nvl_dot_general","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Dot General — nvl_dot_general","text":"Lowers stablehlo::hlo_dot_general().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_dot_general.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Dot General — nvl_dot_general","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   y <- nv_tensor(matrix(1:6, nrow = 3))   nvl_dot_general(x, y,     contracting_dims = list(2L, 1L),     batching_dims = list(integer(0), integer(0))   ) }) #> AnvilTensor #>  22 49 #>  28 64 #> [ CPUi32{2,2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Dynamic Slice — nvl_dynamic_slice","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"Extracts slice tensor whose start position determined runtime via tensor-valued indices. slice shape (slice_sizes) fixed R integer vector. Use nvl_static_slice() instead indices known compile time need stride support.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"","code":"nvl_dynamic_slice(operand, ..., slice_sizes)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"operand (tensorish) Tensorish value data type. ... (tensorish integer type) Scalar start indices, one per dimension. must scalar tensor. Pass one scalar per dimension operand. slice_sizes (integer()) Size slice dimension. Must length equal ndims(operand) satisfy 1 <= slice_sizes <= nv_shape(operand) per dimension.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"tensorish data type input shape slice_sizes. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"out-of-bounds-behavior","dir":"Reference","previous_headings":"","what":"Out Of Bounds Behavior","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"Start indices clamped slice extracted: adjusted_start_indices = clamp(1, start_indices, nv_shape(operand) - slice_sizes + 1). means --bounds indices cause error, effective start position may differ requested one.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"Lowers stablehlo::hlo_dynamic_slice().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Dynamic Slice — nvl_dynamic_slice","text":"","code":"# 1-D: extract 3 elements starting at position 3 jit_eval({   x <- nv_tensor(1:10)   start <- nv_scalar(3L)   nvl_dynamic_slice(x, start, slice_sizes = 3L) }) #> AnvilTensor #>  3 #>  4 #>  5 #> [ CPUi32{3} ]   # 2-D: extract a 2x2 block from a matrix jit_eval({   x <- nv_tensor(matrix(1:12, nrow = 3, ncol = 4))   row_start <- nv_scalar(2L)   col_start <- nv_scalar(1L)   nvl_dynamic_slice(x, row_start, col_start, slice_sizes = c(2L, 2L)) }) #> AnvilTensor #>  2 5 #>  3 6 #> [ CPUi32{2,2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"Returns copy operand slice replaced update runtime-determined position. write counterpart nvl_dynamic_slice(): dynamic slice reads block tensor, dynamic update slice writes block tensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"","code":"nvl_dynamic_update_slice(operand, update, ...)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"operand (tensorish) Tensorish value data type. update (tensorish) values write specified position. Must data type number dimensions operand, nv_shape(update) <= nv_shape(operand) per dimension. ... (tensorish integer type) Scalar start indices, one per dimension operand. must scalar tensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"tensorish data type shape operand. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"Lowers stablehlo::hlo_dynamic_update_slice().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"out-of-bounds-behavior","dir":"Reference","previous_headings":"","what":"Out Of Bounds Behavior","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"Start indices clamped slice extracted: adjusted_start_indices = clamp(1, start_indices, nv_shape(operand) - slice_sizes + 1). means --bounds indices cause error, effective start position may differ requested one.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_dynamic_update_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Dynamic Update Slice — nvl_dynamic_update_slice","text":"","code":"# 1-D: overwrite two elements starting at position 2 jit_eval({   x <- nv_tensor(1:5)   update <- nv_tensor(c(10L, 20L))   start <- nv_scalar(2L)   nvl_dynamic_update_slice(x, update, start) }) #> AnvilTensor #>   1 #>  10 #>  20 #>   4 #>   5 #> [ CPUi32{5} ]   # 2-D: write a 2x2 block into a 3x4 matrix jit_eval({   x <- nv_tensor(matrix(0L, nrow = 3, ncol = 4))   update <- nv_tensor(matrix(c(1L, 2L, 3L, 4L), nrow = 2, ncol = 2))   row_start <- nv_scalar(2L)   col_start <- nv_scalar(3L)   nvl_dynamic_update_slice(x, update, row_start, col_start) }) #> AnvilTensor #>  0 0 0 0 #>  0 0 1 3 #>  0 0 2 4 #> [ CPUi32{3,4} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Equal — nvl_eq","title":"Primitive Equal — nvl_eq","text":"Element-wise equality comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Equal — nvl_eq","text":"","code":"nvl_eq(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Equal — nvl_eq","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Equal — nvl_eq","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Equal — nvl_eq","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"EQ\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_eq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Equal — nvl_eq","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(1, 3, 2))   nvl_eq(x, y) }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Exponential — nvl_exp","title":"Primitive Exponential — nvl_exp","text":"Element-wise exponential.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Exponential — nvl_exp","text":"","code":"nvl_exp(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Exponential — nvl_exp","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Exponential — nvl_exp","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Exponential — nvl_exp","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Exponential — nvl_exp","text":"Lowers stablehlo::hlo_exponential().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_exp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Exponential — nvl_exp","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 1, 2))   nvl_exp(x) }) #> AnvilTensor #>  1.0000 #>  2.7183 #>  7.3891 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Exponential Minus One — nvl_expm1","title":"Primitive Exponential Minus One — nvl_expm1","text":"Element-wise exp(x) - 1, accurate small x.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Exponential Minus One — nvl_expm1","text":"","code":"nvl_expm1(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Exponential Minus One — nvl_expm1","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Exponential Minus One — nvl_expm1","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Exponential Minus One — nvl_expm1","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Exponential Minus One — nvl_expm1","text":"Lowers stablehlo::hlo_exponential_minus_one().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_expm1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Exponential Minus One — nvl_expm1","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.001, 1))   nvl_expm1(x) }) #> AnvilTensor #>  0.0000 #>  0.0010 #>  1.7183 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Fill — nvl_fill","title":"Primitive Fill — nvl_fill","text":"Creates tensor given shape data type, filled scalar value. advantage using function instead e.g. nv_tensor(1, shape = c(100, 100)) lowering nvl_fill() efficiently represented compiled program, latter uses 100 * 100 * 4 bytes memory.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Fill — nvl_fill","text":"","code":"nvl_fill(value, shape, dtype, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Fill — nvl_fill","text":"value (numeric(1)) Scalar value fill tensor . shape (integer()) Shape output tensor. dtype (character(1) | stablehlo::TensorDataType) Data type. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Fill — nvl_fill","text":"tensorish given shape dtype.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Fill — nvl_fill","text":"stablehlo","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Fill — nvl_fill","text":"Lowers stablehlo::hlo_tensor().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_fill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Fill — nvl_fill","text":"","code":"jit_eval(nvl_fill(3.14, shape = c(2, 3), dtype = \"f32\")) #> AnvilTensor #>  3.1400 3.1400 3.1400 #>  3.1400 3.1400 3.1400 #> [ CPUf32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Floor — nvl_floor","title":"Primitive Floor — nvl_floor","text":"Element-wise floor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Floor — nvl_floor","text":"","code":"nvl_floor(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Floor — nvl_floor","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Floor — nvl_floor","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Floor — nvl_floor","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Floor — nvl_floor","text":"Lowers stablehlo::hlo_floor().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_floor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Floor — nvl_floor","text":"","code":"jit_eval({   x <- nv_tensor(c(1.2, 2.7, -1.5))   nvl_floor(x) }) #> AnvilTensor #>   1 #>   2 #>  -2 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Gather — nvl_gather","title":"Primitive Gather — nvl_gather","text":"Gathers slices operand tensor positions specified start_indices. index vector start_indices identifies starting position operand, slice size slice_sizes extracted position. gathered slices assembled output tensor. inverse nvl_scatter(): gather reads slices tensor given indices, scatter writes slices tensor given indices.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Gather — nvl_gather","text":"","code":"nvl_gather(   operand,   start_indices,   slice_sizes,   offset_dims,   collapsed_slice_dims,   operand_batching_dims,   start_indices_batching_dims,   start_index_map,   index_vector_dim,   indices_are_sorted = FALSE,   unique_indices = FALSE )"},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Gather — nvl_gather","text":"operand (tensorish) Tensorish value data type. start_indices (tensorish integer type) Tensor starting indices. Contains index vectors map positions operand via start_index_map. dimension specified index_vector_dim holds index vectors. slice_sizes (integer()) Size slice gather operand dimension. Must length equal ndims(operand). offset_dims (integer()) Dimensions output correspond non-collapsed slice dimensions operand. collapsed_slice_dims (integer()) Dimensions operand collapsed (removed) slice. corresponding entries slice_sizes must 1. Together offset_dims operand_batching_dims, must account dimensions operand. operand_batching_dims (integer()) Dimensions operand batch dimensions. Use integer(0) batch dimensions. start_indices_batching_dims (integer()) Dimensions start_indices correspond batch dimensions. Must length operand_batching_dims. start_index_map (integer()) Maps component index vector operand dimension. example, start_index_map = c(1L) means index vector indexes first dimension operand. index_vector_dim (integer(1)) Dimension start_indices contains index vectors. set ndims(start_indices) + 1, scalar element start_indices treated length-1 index vector. indices_are_sorted (logical(1)) Whether indices guaranteed sorted. Setting TRUE may improve performance produces undefined behavior indices actually sorted. Default FALSE. unique_indices (logical(1)) Whether indices guaranteed unique (duplicates). Setting TRUE may improve performance produces undefined behavior indices actually unique. Default FALSE.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Gather — nvl_gather","text":"tensorish data type operand. output shape composed offset dimensions (slice) remaining dimensions start_indices. See underluing stableHLO function details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"out-of-bounds-behavior","dir":"Reference","previous_headings":"","what":"Out Of Bounds Behavior","title":"Primitive Gather — nvl_gather","text":"Start indices clamped slice extracted: clamp(1, start_index, nv_shape(operand) - slice_sizes + 1). means --bounds indices cause error, effective start position may differ requested one.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Gather — nvl_gather","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Gather — nvl_gather","text":"Lowers stablehlo::hlo_gather().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_gather.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Gather — nvl_gather","text":"","code":"# Gather rows 1 and 3 from a 3x3 matrix jit_eval({   operand <- nv_tensor(matrix(1:9, nrow = 3))   indices <- nv_tensor(matrix(c(1L, 3L), ncol = 1))   nvl_gather(     operand, indices,     slice_sizes = c(1L, 3L),     offset_dims = 2L,     collapsed_slice_dims = 1L,     operand_batching_dims = integer(0),     start_indices_batching_dims = integer(0),     start_index_map = 1L,     index_vector_dim = 2L   ) }) #> AnvilTensor #>  1 4 7 #>  3 6 9 #> [ CPUi32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Greater Equal — nvl_ge","title":"Primitive Greater Equal — nvl_ge","text":"Element-wise greater equal comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Greater Equal — nvl_ge","text":"","code":"nvl_ge(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Greater Equal — nvl_ge","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Greater Equal — nvl_ge","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Greater Equal — nvl_ge","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"GE\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_ge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Greater Equal — nvl_ge","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   nvl_ge(x, y) }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Greater Than — nvl_gt","title":"Primitive Greater Than — nvl_gt","text":"Element-wise greater comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Greater Than — nvl_gt","text":"","code":"nvl_gt(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Greater Than — nvl_gt","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Greater Than — nvl_gt","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Greater Than — nvl_gt","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"GT\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Greater Than — nvl_gt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   nvl_gt(x, y) }) #> AnvilTensor #>  0 #>  0 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive If — nvl_if","title":"Primitive If — nvl_if","text":"Conditional execution one two branches based scalar boolean predicate. Unlike nvl_ifelse() operates element-wise, evaluates selected branch.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive If — nvl_if","text":"","code":"nvl_if(pred, true, false)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive If — nvl_if","text":"pred (tensorish) Scalar boolean predicate determines branch execute. true, false (NSE) Expressions true false branches. must return outputs structure, dtypes, shapes.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive If — nvl_if","text":"Result executed branch. output ambiguous ambiguous branches.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive If — nvl_if","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive If — nvl_if","text":"Lowers stablehlo::hlo_if().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_if.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive If — nvl_if","text":"","code":"jit_eval(nvl_if(nv_scalar(TRUE), nv_scalar(1), nv_scalar(2))) #> AnvilTensor #>  1 #> [ CPUf32{} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Ifelse — nvl_ifelse","title":"Primitive Ifelse — nvl_ifelse","text":"Element-wise selection based boolean predicate, like R's ifelse(). element, returns corresponding element true_value pred TRUE false_value pred FALSE.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Ifelse — nvl_ifelse","text":"","code":"nvl_ifelse(pred, true_value, false_value)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Ifelse — nvl_ifelse","text":"pred (tensorish boolean type) Predicate tensor. Must scalar shape true_value. true_value, false_value (tensorish) Values select . Must dtype shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Ifelse — nvl_ifelse","text":"tensorish dtype shape true_value. ambiguous true_value false_value ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Ifelse — nvl_ifelse","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Ifelse — nvl_ifelse","text":"Lowers stablehlo::hlo_select().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_ifelse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Ifelse — nvl_ifelse","text":"","code":"jit_eval({   pred <- nv_tensor(c(TRUE, FALSE, TRUE))   nvl_ifelse(pred, nv_tensor(c(1, 2, 3)), nv_tensor(c(4, 5, 6))) }) #> AnvilTensor #>  1 #>  5 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Iota — nvl_iota","title":"Primitive Iota — nvl_iota","text":"Creates tensor values increasing along specified dimension.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Iota — nvl_iota","text":"","code":"nvl_iota(dim, dtype, shape, start = 1L, ambiguous = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Iota — nvl_iota","text":"dim (integer(1)) Dimension along values increase (1-indexed). dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape output tensor. start (integer(1)) Starting value. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette(\"type-promotion\") details.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Iota — nvl_iota","text":"tensorish given dtype shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Iota — nvl_iota","text":"stablehlo","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Iota — nvl_iota","text":"Lowers stablehlo::hlo_iota().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_iota.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Iota — nvl_iota","text":"","code":"jit_eval(nvl_iota(dim = 1L, dtype = \"i32\", shape = 5L)) #> AnvilTensor #>  1 #>  2 #>  3 #>  4 #>  5 #> [ CPUi32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Is Finite — nvl_is_finite","title":"Primitive Is Finite — nvl_is_finite","text":"Element-wise check values finite (Inf, -Inf, NaN).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Is Finite — nvl_is_finite","text":"","code":"nvl_is_finite(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Is Finite — nvl_is_finite","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Is Finite — nvl_is_finite","text":"tensorish shape input boolean data type. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Is Finite — nvl_is_finite","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Is Finite — nvl_is_finite","text":"Lowers stablehlo::hlo_is_finite().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_is_finite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Is Finite — nvl_is_finite","text":"","code":"jit_eval({   x <- nv_tensor(c(1, Inf, NaN, -Inf, 0))   nvl_is_finite(x) }) #> AnvilTensor #>  1 #>  0 #>  0 #>  0 #>  1 #> [ CPUi1{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Less Equal — nvl_le","title":"Primitive Less Equal — nvl_le","text":"Element-wise less equal comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Less Equal — nvl_le","text":"","code":"nvl_le(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Less Equal — nvl_le","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Less Equal — nvl_le","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Less Equal — nvl_le","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"LE\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_le.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Less Equal — nvl_le","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   nvl_le(x, y) }) #> AnvilTensor #>  1 #>  1 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logarithm — nvl_log","title":"Primitive Logarithm — nvl_log","text":"Element-wise natural logarithm.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logarithm — nvl_log","text":"","code":"nvl_log(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logarithm — nvl_log","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logarithm — nvl_log","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Logarithm — nvl_log","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Logarithm — nvl_log","text":"Lowers stablehlo::hlo_log().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_log.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Logarithm — nvl_log","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2.718, 7.389))   nvl_log(x) }) #> AnvilTensor #>  0.0000 #>  0.9999 #>  2.0000 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Log Plus One — nvl_log1p","title":"Primitive Log Plus One — nvl_log1p","text":"Element-wise log(1 + x), accurate small x.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Log Plus One — nvl_log1p","text":"","code":"nvl_log1p(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Log Plus One — nvl_log1p","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Log Plus One — nvl_log1p","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Log Plus One — nvl_log1p","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Log Plus One — nvl_log1p","text":"Lowers stablehlo::hlo_log_plus_one().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_log1p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Log Plus One — nvl_log1p","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.001, 1))   nvl_log1p(x) }) #> AnvilTensor #>  0.0000 #>  0.0010 #>  0.6931 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logistic (Sigmoid) — nvl_logistic","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"Element-wise logistic sigmoid: 1 / (1 + exp(-x)).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"","code":"nvl_logistic(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"Lowers stablehlo::hlo_logistic().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_logistic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"","code":"jit_eval({   x <- nv_tensor(c(-2, 0, 2))   nvl_logistic(x) }) #> AnvilTensor #>  0.1192 #>  0.5000 #>  0.8808 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Less Than — nvl_lt","title":"Primitive Less Than — nvl_lt","text":"Element-wise less comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Less Than — nvl_lt","text":"","code":"nvl_lt(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Less Than — nvl_lt","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Less Than — nvl_lt","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Less Than — nvl_lt","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"LT\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_lt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Less Than — nvl_lt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(3, 2, 1))   nvl_lt(x, y) }) #> AnvilTensor #>  1 #>  0 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Maximum — nvl_max","title":"Primitive Maximum — nvl_max","text":"Element-wise maximum two tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Maximum — nvl_max","text":"","code":"nvl_max(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Maximum — nvl_max","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Maximum — nvl_max","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Maximum — nvl_max","text":"Lowers stablehlo::hlo_maximum().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_max.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Maximum — nvl_max","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 5, 3))   y <- nv_tensor(c(4, 2, 6))   nvl_max(x, y) }) #> AnvilTensor #>  4 #>  5 #>  6 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Minimum — nvl_min","title":"Primitive Minimum — nvl_min","text":"Element-wise minimum two tensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Minimum — nvl_min","text":"","code":"nvl_min(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Minimum — nvl_min","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Minimum — nvl_min","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Minimum — nvl_min","text":"Lowers stablehlo::hlo_minimum().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Minimum — nvl_min","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 5, 3))   y <- nv_tensor(c(4, 2, 6))   nvl_min(x, y) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Multiplication — nvl_mul","title":"Primitive Multiplication — nvl_mul","text":"Multiplies two tensors element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Multiplication — nvl_mul","text":"","code":"nvl_mul(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Multiplication — nvl_mul","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Multiplication — nvl_mul","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Multiplication — nvl_mul","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Multiplication — nvl_mul","text":"Lowers stablehlo::hlo_multiply().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_mul.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Multiplication — nvl_mul","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   nvl_mul(x, y) }) #> AnvilTensor #>   4 #>  10 #>  18 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Not Equal — nvl_ne","title":"Primitive Not Equal — nvl_ne","text":"Element-wise inequality comparison.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Not Equal — nvl_ne","text":"","code":"nvl_ne(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Not Equal — nvl_ne","text":"lhs, rhs (tensorish) Tensorish values data type. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Not Equal — nvl_ne","text":"tensorish shape inputs boolean data type. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Not Equal — nvl_ne","text":"Lowers stablehlo::hlo_compare() comparison_direction = \"NE\".","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_ne.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Not Equal — nvl_ne","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(1, 3, 2))   nvl_ne(x, y) }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Negation — nvl_negate","title":"Primitive Negation — nvl_negate","text":"Negates tensor element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Negation — nvl_negate","text":"","code":"nvl_negate(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Negation — nvl_negate","text":"operand (tensorish) Tensorish value data type integer floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Negation — nvl_negate","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Negation — nvl_negate","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Negation — nvl_negate","text":"Lowers stablehlo::hlo_negate().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_negate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Negation — nvl_negate","text":"","code":"jit_eval({   x <- nv_tensor(c(1, -2, 3))   nvl_negate(x) }) #> AnvilTensor #>  -1 #>   2 #>  -3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Not — nvl_not","title":"Primitive Not — nvl_not","text":"Element-wise logical .","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Not — nvl_not","text":"","code":"nvl_not(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Not — nvl_not","text":"operand (tensorish) Tensorish value data type boolean, integer, unsigned integer.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Not — nvl_not","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Not — nvl_not","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Not — nvl_not","text":"Lowers stablehlo::hlo_not().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Not — nvl_not","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   nvl_not(x) }) #> AnvilTensor #>  0 #>  1 #>  0 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Or — nvl_or","title":"Primitive Or — nvl_or","text":"Element-wise logical .","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Or — nvl_or","text":"","code":"nvl_or(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Or — nvl_or","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Or — nvl_or","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Or — nvl_or","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Or — nvl_or","text":"Lowers stablehlo::hlo_or().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_or.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Or — nvl_or","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   nvl_or(x, y) }) #> AnvilTensor #>  1 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Pad — nvl_pad","title":"Primitive Pad — nvl_pad","text":"Pads tensor given padding value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Pad — nvl_pad","text":"","code":"nvl_pad(   operand,   padding_value,   edge_padding_low,   edge_padding_high,   interior_padding )"},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Pad — nvl_pad","text":"operand (tensorish) Tensorish value data type. padding_value (tensorish) Scalar value use padding. Must dtype operand. edge_padding_low (integer()) Amount padding add start dimension. edge_padding_high (integer()) Amount padding add end dimension. interior_padding (integer()) Amount padding add elements dimension.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Pad — nvl_pad","text":"tensorish data type operand. output shape see underlying stablehlo documentation (stablehlo::hlo_pad()). ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Pad — nvl_pad","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Pad — nvl_pad","text":"Lowers stablehlo::hlo_pad().","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Pad — nvl_pad","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   nvl_pad(x, nv_scalar(0),     edge_padding_low = 2L, edge_padding_high = 1L, interior_padding = 0L   ) }) #> AnvilTensor #>  0 #>  0 #>  1 #>  2 #>  3 #>  0 #> [ CPUf32{6} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Population Count — nvl_popcnt","title":"Primitive Population Count — nvl_popcnt","text":"Element-wise population count (number set bits).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Population Count — nvl_popcnt","text":"","code":"nvl_popcnt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Population Count — nvl_popcnt","text":"operand (tensorish) Tensorish value data type integer unsigned integer.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Population Count — nvl_popcnt","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Population Count — nvl_popcnt","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Population Count — nvl_popcnt","text":"Lowers stablehlo::hlo_popcnt().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_popcnt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Population Count — nvl_popcnt","text":"","code":"jit_eval({   x <- nv_tensor(c(7L, 3L, 15L))   nvl_popcnt(x) }) #> AnvilTensor #>  3 #>  2 #>  4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Power — nvl_pow","title":"Primitive Power — nvl_pow","text":"Raises lhs power rhs element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Power — nvl_pow","text":"","code":"nvl_pow(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Power — nvl_pow","text":"lhs, rhs (tensorish) Tensorish values data type integer, unsigned integer, floating-point. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Power — nvl_pow","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Power — nvl_pow","text":"Lowers stablehlo::hlo_power().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_pow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Power — nvl_pow","text":"","code":"jit_eval({   x <- nv_tensor(c(2, 3, 4))   y <- nv_tensor(c(3, 2, 1))   nvl_pow(x, y) }) #> AnvilTensor #>  8 #>  9 #>  4 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Print — nvl_print","title":"Primitive Print — nvl_print","text":"Prints tensor value console execution returns input unchanged. useful debugging JIT-compiled code.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Print — nvl_print","text":"","code":"nvl_print(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Print — nvl_print","text":"operand (tensorish) Tensorish value data type.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Print — nvl_print","text":"tensorish Returns operand -.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Primitive Print — nvl_print","text":"Currently works CPU backend.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Print — nvl_print","text":"stablehlo","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Print — nvl_print","text":"Lowers stablehlo::hlo_custom_call().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Print — nvl_print","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3), device = \"cpu\")   nvl_print(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ f32{3} ] #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive All Reduction — nvl_reduce_all","title":"Primitive All Reduction — nvl_reduce_all","text":"Performs logical along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive All Reduction — nvl_reduce_all","text":"","code":"nvl_reduce_all(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive All Reduction — nvl_reduce_all","text":"operand (tensorish) Tensorish value boolean data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive All Reduction — nvl_reduce_all","text":"tensorish Boolean tensor. Never ambiguous. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive All Reduction — nvl_reduce_all","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive All Reduction — nvl_reduce_all","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_and() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive All Reduction — nvl_reduce_all","text":"","code":"jit_eval({   x <- nv_tensor(matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2))   nvl_reduce_all(x, dims = 1L) }) #> AnvilTensor #>  0 #>  1 #> [ CPUi1{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Any Reduction — nvl_reduce_any","title":"Primitive Any Reduction — nvl_reduce_any","text":"Performs logical along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Any Reduction — nvl_reduce_any","text":"","code":"nvl_reduce_any(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Any Reduction — nvl_reduce_any","text":"operand (tensorish) Tensorish value boolean data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Any Reduction — nvl_reduce_any","text":"tensorish Boolean tensor. Never ambiguous. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Any Reduction — nvl_reduce_any","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Any Reduction — nvl_reduce_any","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_or() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_any.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Any Reduction — nvl_reduce_any","text":"","code":"jit_eval({   x <- nv_tensor(matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2))   nvl_reduce_any(x, dims = 1L) }) #> AnvilTensor #>  1 #>  1 #> [ CPUi1{2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Max Reduction — nvl_reduce_max","title":"Primitive Max Reduction — nvl_reduce_max","text":"Finds maximum tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Max Reduction — nvl_reduce_max","text":"","code":"nvl_reduce_max(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Max Reduction — nvl_reduce_max","text":"operand (tensorish) Tensorish value data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Max Reduction — nvl_reduce_max","text":"tensorish data type input. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Max Reduction — nvl_reduce_max","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Max Reduction — nvl_reduce_max","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_maximum() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_max.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Max Reduction — nvl_reduce_max","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nvl_reduce_max(x, dims = 1L) }) #> AnvilTensor #>  2 #>  4 #>  6 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Min Reduction — nvl_reduce_min","title":"Primitive Min Reduction — nvl_reduce_min","text":"Finds minimum tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Min Reduction — nvl_reduce_min","text":"","code":"nvl_reduce_min(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Min Reduction — nvl_reduce_min","text":"operand (tensorish) Tensorish value data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Min Reduction — nvl_reduce_min","text":"tensorish data type input. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Min Reduction — nvl_reduce_min","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Min Reduction — nvl_reduce_min","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_minimum() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Min Reduction — nvl_reduce_min","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nvl_reduce_min(x, dims = 1L) }) #> AnvilTensor #>  1 #>  3 #>  5 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Product Reduction — nvl_reduce_prod","title":"Primitive Product Reduction — nvl_reduce_prod","text":"Multiplies tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Product Reduction — nvl_reduce_prod","text":"","code":"nvl_reduce_prod(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Product Reduction — nvl_reduce_prod","text":"operand (tensorish) Tensorish value data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Product Reduction — nvl_reduce_prod","text":"tensorish data type input. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Product Reduction — nvl_reduce_prod","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Product Reduction — nvl_reduce_prod","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_multiply() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_prod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Product Reduction — nvl_reduce_prod","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nvl_reduce_prod(x, dims = 1L) }) #> AnvilTensor #>   2 #>  12 #>  30 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sum Reduction — nvl_reduce_sum","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"Sums tensor elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"","code":"nvl_reduce_sum(operand, dims, drop = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"operand (tensorish) Tensorish value data type. dims (integer()) Dimensions reduce . drop (logical(1)) Whether drop reduced dimensions output shape. TRUE, reduced dimensions removed. FALSE, reduced dimensions set 1.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"tensorish data type input. drop = TRUE, shape operand dims removed. drop = FALSE, shape operand dims set 1. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"Lowers stablehlo::hlo_reduce() stablehlo::hlo_add() reducer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reduce_sum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nvl_reduce_sum(x, dims = 1L) }) #> AnvilTensor #>   3 #>   7 #>  11 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Remainder — nvl_remainder","title":"Primitive Remainder — nvl_remainder","text":"Element-wise remainder division.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Remainder — nvl_remainder","text":"","code":"nvl_remainder(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Remainder — nvl_remainder","text":"lhs, rhs (tensorish) Tensorish values data type integer, unsigned integer, floating-point. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Remainder — nvl_remainder","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Remainder — nvl_remainder","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Remainder — nvl_remainder","text":"Lowers stablehlo::hlo_remainder().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_remainder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Remainder — nvl_remainder","text":"","code":"jit_eval({   x <- nv_tensor(c(7, 10, 15))   y <- nv_tensor(c(3, 4, 6))   nvl_remainder(x, y) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reshape — nvl_reshape","title":"Primitive Reshape — nvl_reshape","text":"Reshapes tensor new shape without changing underlying data. Note row-major order used, differs R's column-major order.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reshape — nvl_reshape","text":"","code":"nvl_reshape(operand, shape)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reshape — nvl_reshape","text":"operand (tensorish) Tensorish value data type. shape (integer()) Target shape. Must number elements operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reshape — nvl_reshape","text":"tensorish data type input given shape. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Reshape — nvl_reshape","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Reshape — nvl_reshape","text":"Lowers stablehlo::hlo_reshape().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reshape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Reshape — nvl_reshape","text":"","code":"jit_eval({   x <- nv_tensor(1:6)   nvl_reshape(x, shape = c(2, 3)) }) #> AnvilTensor #>  1 2 3 #>  4 5 6 #> [ CPUi32{2,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reverse — nvl_reverse","title":"Primitive Reverse — nvl_reverse","text":"Reverses order elements along specified dimensions.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reverse — nvl_reverse","text":"","code":"nvl_reverse(operand, dims)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reverse — nvl_reverse","text":"operand (tensorish) Tensorish value data type. dims (integer()) Dimensions reverse (1-indexed).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reverse — nvl_reverse","text":"tensorish data type shape operand. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Reverse — nvl_reverse","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Reverse — nvl_reverse","text":"Lowers stablehlo::hlo_reverse().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_reverse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Reverse — nvl_reverse","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3, 4, 5))   nvl_reverse(x, dims = 1L) }) #> AnvilTensor #>  5 #>  4 #>  3 #>  2 #>  1 #> [ CPUf32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive RNG Bit Generator — nvl_rng_bit_generator","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"Generates pseudo-random numbers using specified algorithm returns updated RNG state together generated values.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"","code":"nvl_rng_bit_generator(initial_state, rng_algorithm = \"THREE_FRY\", dtype, shape)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"initial_state (tensorish) RNG state (ui64[2]). rng_algorithm (character(1)) RNG algorithm name. Default \"THREE_FRY\". dtype (character(1) | stablehlo::TensorDataType) Data type generated random values. shape (integer()) Shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"list two tensorish values: first element updated RNG state dtype shape initial_state. second element tensor random values given dtype shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"stablehlo","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"Lowers stablehlo::hlo_rng_bit_generator().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_rng_bit_generator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"","code":"jit_eval({   state <- nv_tensor(c(0L, 0L), dtype = \"ui64\")   nvl_rng_bit_generator(state, dtype = \"f32\", shape = c(3, 2)) }) #> [[1]] #> AnvilTensor #>  0 #>  3 #> [ CPUui64{2} ]  #>  #> [[2]] #> AnvilTensor #>  1.7973e+09 2.5791e+09 #>  1.3515e+09 3.2358e+09 #>  1.6886e+09 4.2293e+09 #> [ CPUui32{3,2} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Round — nvl_round","title":"Primitive Round — nvl_round","text":"Rounds elements tensor nearest integer.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Round — nvl_round","text":"","code":"nvl_round(operand, method = \"nearest_even\")"},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Round — nvl_round","text":"operand (tensorish) Tensorish value data type floating-point. method (character(1)) Rounding method. \"nearest_even\" (default) rounds nearest even integer tie, \"afz\" rounds away zero tie.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Round — nvl_round","text":"tensorish dtype shape operand. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Round — nvl_round","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Round — nvl_round","text":"Lowers stablehlo::hlo_round_nearest_even() stablehlo::hlo_round_nearest_afz() depending method parameter.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_round.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Round — nvl_round","text":"","code":"jit_eval({   x <- nv_tensor(c(1.4, 2.5, 3.6))   nvl_round(x) }) #> AnvilTensor #>  1 #>  2 #>  4 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reciprocal Square Root — nvl_rsqrt","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"Element-wise reciprocal square root.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"","code":"nvl_rsqrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"Lowers stablehlo::hlo_rsqrt().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_rsqrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 4, 9))   nvl_rsqrt(x) }) #> AnvilTensor #>  1.0000 #>  0.5000 #>  0.3333 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Scatter — nvl_scatter","title":"Primitive Scatter — nvl_scatter","text":"Produces result tensor identical input except slices positions specified scatter_indices updated values update tensor. multiple indices point location, update_computation function determines combine values (default new value replaces old one). inverse nvl_gather(): gather reads slices tensor given indices, scatter writes slices tensor given indices.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Scatter — nvl_scatter","text":"","code":"nvl_scatter(   input,   scatter_indices,   update,   update_window_dims,   inserted_window_dims,   input_batching_dims,   scatter_indices_batching_dims,   scatter_dims_to_operand_dims,   index_vector_dim,   indices_are_sorted = FALSE,   unique_indices = FALSE,   update_computation = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Scatter — nvl_scatter","text":"input (tensorish) Tensorish value data type. base tensor scatter . scatter_indices (tensorish integer type) Tensor indices. Contains index vectors map positions input via scatter_dims_to_operand_dims. dimension specified index_vector_dim holds index vectors. update (tensorish) Update values tensor. Must data type input. update_window_dims (integer()) Dimensions update window dimensions, .e. correspond slice written input. inserted_window_dims (integer()) Dimensions input whose slices size 1 inserted (present) update window. Together update_window_dims input_batching_dims, must account dimensions input. input_batching_dims (integer()) Dimensions input batch dimensions. Use integer(0) batch dimensions. scatter_indices_batching_dims (integer()) Dimensions scatter_indices correspond batch dimensions. Must length input_batching_dims. scatter_dims_to_operand_dims (integer()) Maps component index vector input dimension. example, scatter_dims_to_operand_dims = c(1L) means index vector indexes first dimension input. index_vector_dim (integer(1)) Dimension scatter_indices contains index vectors. set ndims(scatter_indices) + 1, scalar element scatter_indices treated length-1 index vector. indices_are_sorted (logical(1)) Whether indices guaranteed sorted. Setting TRUE may improve performance produces undefined behavior indices actually sorted. Default FALSE. unique_indices (logical(1)) Whether indices guaranteed unique (duplicates). Setting TRUE may improve performance produces undefined behavior indices actually unique. Default FALSE. update_computation (function) Binary function f(old, new) combines existing value input value update. default (NULL) uses function(old, new) new, replaces old value.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Scatter — nvl_scatter","text":"tensorish data type shape input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"out-of-bounds-behavior","dir":"Reference","previous_headings":"","what":"Out Of Bounds Behavior","title":"Primitive Scatter — nvl_scatter","text":"computed result index falls outside bounds input, update index silently ignored.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"update-order","dir":"Reference","previous_headings":"","what":"Update Order","title":"Primitive Scatter — nvl_scatter","text":"multiple indices scatter_indices map element input, order update_computation applied implementation-defined may vary plugins (\"cpu\", \"cuda\").","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Scatter — nvl_scatter","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Scatter — nvl_scatter","text":"Lowers stablehlo::hlo_scatter().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_scatter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Scatter — nvl_scatter","text":"","code":"# Scatter values 10 and 30 into positions 1 and 3 of a zero vector jit_eval({   input <- nv_tensor(c(0, 0, 0, 0, 0))   indices <- nv_tensor(matrix(c(1L, 3L), ncol = 1))   updates <- nv_tensor(c(10, 30))   nvl_scatter(     input, indices, updates,     update_window_dims = integer(0),     inserted_window_dims = 1L,     input_batching_dims = integer(0),     scatter_indices_batching_dims = integer(0),     scatter_dims_to_operand_dims = 1L,     index_vector_dim = 2L   ) }) #> AnvilTensor #>  10 #>   0 #>  30 #>   0 #>   0 #> [ CPUf32{5} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Shift Left — nvl_shift_left","title":"Primitive Shift Left — nvl_shift_left","text":"Element-wise left bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Shift Left — nvl_shift_left","text":"","code":"nvl_shift_left(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Shift Left — nvl_shift_left","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Shift Left — nvl_shift_left","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Shift Left — nvl_shift_left","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Shift Left — nvl_shift_left","text":"Lowers stablehlo::hlo_shift_left().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_left.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Shift Left — nvl_shift_left","text":"","code":"jit_eval({   x <- nv_tensor(c(1L, 2L, 4L))   y <- nv_tensor(c(1L, 2L, 1L))   nvl_shift_left(x, y) }) #> AnvilTensor #>  2 #>  8 #>  8 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"Element-wise arithmetic right bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"","code":"nvl_shift_right_arithmetic(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"Lowers stablehlo::hlo_shift_right_arithmetic().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_arithmetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"","code":"jit_eval({   x <- nv_tensor(c(8L, -16L, 32L))   y <- nv_tensor(c(1L, 2L, 3L))   nvl_shift_right_arithmetic(x, y) }) #> AnvilTensor #>   4 #>  -4 #>   4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logical Shift Right — nvl_shift_right_logical","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"Element-wise logical right bit shift.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"","code":"nvl_shift_right_logical(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"Lowers stablehlo::hlo_shift_right_logical().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_shift_right_logical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"","code":"jit_eval({   x <- nv_tensor(c(8L, 16L, 32L))   y <- nv_tensor(c(1L, 2L, 3L))   nvl_shift_right_logical(x, y) }) #> AnvilTensor #>  4 #>  4 #>  4 #> [ CPUi32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sign — nvl_sign","title":"Primitive Sign — nvl_sign","text":"Element-wise sign.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sign — nvl_sign","text":"","code":"nvl_sign(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sign — nvl_sign","text":"operand (tensorish) Tensorish value data type signed integer floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sign — nvl_sign","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Sign — nvl_sign","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Sign — nvl_sign","text":"Lowers stablehlo::hlo_sign().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_sign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Sign — nvl_sign","text":"","code":"jit_eval({   x <- nv_tensor(c(-3, 0, 5))   nvl_sign(x) }) #> AnvilTensor #>  -1 #>   0 #>   1 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sine — nvl_sine","title":"Primitive Sine — nvl_sine","text":"Element-wise sine.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sine — nvl_sine","text":"","code":"nvl_sine(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sine — nvl_sine","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sine — nvl_sine","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Sine — nvl_sine","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Sine — nvl_sine","text":"Lowers stablehlo::hlo_sine().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_sine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Sine — nvl_sine","text":"","code":"jit_eval({   x <- nv_tensor(c(0, pi / 2, pi))   nvl_sine(x) }) #> AnvilTensor #>   0.0000e+00 #>   1.0000e+00 #>  -8.7423e-08 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Square Root — nvl_sqrt","title":"Primitive Square Root — nvl_sqrt","text":"Element-wise square root.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Square Root — nvl_sqrt","text":"","code":"nvl_sqrt(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Square Root — nvl_sqrt","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Square Root — nvl_sqrt","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Square Root — nvl_sqrt","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Square Root — nvl_sqrt","text":"Lowers stablehlo::hlo_sqrt().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_sqrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Square Root — nvl_sqrt","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 4, 9))   nvl_sqrt(x) }) #> AnvilTensor #>  1 #>  2 #>  3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Static Slice — nvl_static_slice","title":"Primitive Static Slice — nvl_static_slice","text":"Extracts slice tensor using static (compile-time) indices. indices, limits, strides fixed R integers. Use nvl_dynamic_slice() instead start position must computed runtime (e.g. depends tensor values).","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Static Slice — nvl_static_slice","text":"","code":"nvl_static_slice(operand, start_indices, limit_indices, strides)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Static Slice — nvl_static_slice","text":"operand (tensorish) Tensorish value data type. start_indices (integer()) Start indices (inclusive), one per dimension. Must satisfy 1 <= start_indices <= limit_indices per dimension. limit_indices (integer()) End indices (inclusive), one per dimension. Must satisfy limit_indices <= nv_shape(operand) per dimension. strides (integer()) Step sizes, one per dimension. Must >= 1. stride 1 selects every element; stride 2 selects every element, etc.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Static Slice — nvl_static_slice","text":"tensorish data type input shape ceiling((limit_indices - start_indices + 1) / strides). ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Static Slice — nvl_static_slice","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Static Slice — nvl_static_slice","text":"Lowers stablehlo::hlo_slice().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_static_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Static Slice — nvl_static_slice","text":"","code":"# 1-D: extract elements 2 through 4 (limit is exclusive) jit_eval({   x <- nv_tensor(1:10)   nvl_static_slice(x, start_indices = 2L, limit_indices = 5L, strides = 1L) }) #> AnvilTensor #>  2 #>  3 #>  4 #>  5 #> [ CPUi32{4} ]   # 1-D: every other element using strides jit_eval({   x <- nv_tensor(1:10)   nvl_static_slice(x, start_indices = 1L, limit_indices = 10L, strides = 2L) }) #> AnvilTensor #>  1 #>  3 #>  5 #>  7 #>  9 #> [ CPUi32{5} ]   # 2-D: extract a submatrix (rows 1-2, columns 2-3) jit_eval({   x <- nv_tensor(matrix(1:12, nrow = 3, ncol = 4))   nvl_static_slice(x,     start_indices = c(1L, 2L),     limit_indices = c(3L, 4L),     strides       = c(1L, 1L)   ) }) #> AnvilTensor #>   4  7 10 #>   5  8 11 #>   6  9 12 #> [ CPUi32{3,3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Subtraction — nvl_sub","title":"Primitive Subtraction — nvl_sub","text":"Subtracts two tensors element-wise.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Subtraction — nvl_sub","text":"","code":"nvl_sub(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Subtraction — nvl_sub","text":"lhs, rhs (tensorish) Tensorish values data type integer, unsigned integer, floating-point. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Subtraction — nvl_sub","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Subtraction — nvl_sub","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Subtraction — nvl_sub","text":"Lowers stablehlo::hlo_subtract().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_sub.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Subtraction — nvl_sub","text":"","code":"jit_eval({   x <- nv_tensor(c(1, 2, 3))   y <- nv_tensor(c(4, 5, 6))   nvl_sub(x, y) }) #> AnvilTensor #>  -3 #>  -3 #>  -3 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Tangent — nvl_tan","title":"Primitive Tangent — nvl_tan","text":"Element-wise tangent.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Tangent — nvl_tan","text":"","code":"nvl_tan(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Tangent — nvl_tan","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Tangent — nvl_tan","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Tangent — nvl_tan","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Tangent — nvl_tan","text":"Lowers stablehlo::hlo_tan().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_tan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Tangent — nvl_tan","text":"","code":"jit_eval({   x <- nv_tensor(c(0, 0.5, 1))   nvl_tan(x) }) #> AnvilTensor #>  0.0000 #>  0.5463 #>  1.5574 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Hyperbolic Tangent — nvl_tanh","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"Element-wise hyperbolic tangent.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"","code":"nvl_tanh(operand)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"operand (tensorish) Tensorish value data type floating-point.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"tensorish shape data type input. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"Lowers stablehlo::hlo_tanh().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_tanh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"","code":"jit_eval({   x <- nv_tensor(c(-1, 0, 1))   nvl_tanh(x) }) #> AnvilTensor #>  -0.7616 #>   0.0000 #>   0.7616 #> [ CPUf32{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Transpose — nvl_transpose","title":"Primitive Transpose — nvl_transpose","text":"Permutes dimensions tensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Transpose — nvl_transpose","text":"","code":"nvl_transpose(operand, permutation)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Transpose — nvl_transpose","text":"operand (tensorish) Tensorish value data type. permutation (integer()) Specifies new ordering dimensions. Must permutation seq_len(ndims) ndims number dimensions operand.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Transpose — nvl_transpose","text":"tensorish data type input shape nv_shape(operand)[permutation]. ambiguous input ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Transpose — nvl_transpose","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Transpose — nvl_transpose","text":"Lowers stablehlo::hlo_transpose().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Transpose — nvl_transpose","text":"","code":"jit_eval({   x <- nv_tensor(matrix(1:6, nrow = 2))   nvl_transpose(x, permutation = c(2L, 1L)) }) #> AnvilTensor #>  1 2 #>  3 4 #>  5 6 #> [ CPUi32{3,2} ]"},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive While Loop — nvl_while","title":"Primitive While Loop — nvl_while","text":"Repeatedly executes body cond returns TRUE, like R's loop. loop state initialized init passed iteration. Otherwise, state maintained iterations.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive While Loop — nvl_while","text":"","code":"nvl_while(init, cond, body)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive While Loop — nvl_while","text":"init (named list()) Named list initial state values. cond (function) Condition function receives current state arguments outputs whether continue loop. body (function) Body function receives current state arguments returns named list structure, dtypes, shapes init.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive While Loop — nvl_while","text":"Named list structure init containing final state loop terminates.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive While Loop — nvl_while","text":"stablehlo","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive While Loop — nvl_while","text":"Lowers stablehlo::hlo_while().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_while.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive While Loop — nvl_while","text":"","code":"jit_eval({   nvl_while(     init = list(i = 0L, total = 0L),     cond = function(i, total) i <= 5L,     body = function(i, total) list(       i = i + 1L,       total = total + i     )   ) }) #> $i #> AnvilTensor #>  6 #> [ CPUi32?{} ]  #>  #> $total #> AnvilTensor #>  15 #> [ CPUi32?{} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Xor — nvl_xor","title":"Primitive Xor — nvl_xor","text":"Element-wise logical XOR.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Xor — nvl_xor","text":"","code":"nvl_xor(lhs, rhs)"},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Xor — nvl_xor","text":"lhs, rhs (tensorish) Tensorish values data type boolean, integer, unsigned integer. Must shape.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Xor — nvl_xor","text":"tensorish shape data type inputs. ambiguous inputs ambiguous.","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"implemented-rules","dir":"Reference","previous_headings":"","what":"Implemented Rules","title":"Primitive Xor — nvl_xor","text":"stablehlo backward","code":""},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"stablehlo","dir":"Reference","previous_headings":"","what":"StableHLO","title":"Primitive Xor — nvl_xor","text":"Lowers stablehlo::hlo_xor().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/nvl_xor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primitive Xor — nvl_xor","text":"","code":"jit_eval({   x <- nv_tensor(c(TRUE, FALSE, TRUE))   y <- nv_tensor(c(TRUE, TRUE, FALSE))   nvl_xor(x, y) }) #> AnvilTensor #>  0 #>  1 #>  1 #> [ CPUi1{3} ]"},{"path":"https://r-xla.github.io/anvil/reference/platform.AbstractTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Platform for AbstractTensor — platform.AbstractTensor","title":"Platform for AbstractTensor — platform.AbstractTensor","text":"Get platform AbstractTensor. Always errors since platform accessible tracing.","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.AbstractTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Platform for AbstractTensor — platform.AbstractTensor","text":"","code":"# S3 method for class 'AbstractTensor' platform(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/platform.AbstractTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Platform for AbstractTensor — platform.AbstractTensor","text":"x AbstractTensor. ... Additional arguments (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.AbstractTensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Platform for AbstractTensor — platform.AbstractTensor","text":"Never returns; always errors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the platform of a tensor or buffer — platform","title":"Get the platform of a tensor or buffer — platform","text":"Returns platform name (e.g. \"cpu\", \"cuda\") identifying compute backend.","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the platform of a tensor or buffer — platform","text":"","code":"platform(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the platform of a tensor or buffer — platform","text":"x (tensorish) tensor-like object. ... Additional arguments passed methods (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the platform of a tensor or buffer — platform","text":"character(1)","code":""},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the platform of a tensor or buffer — platform","text":"Implemented via generic pjrt::platform().","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/platform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the platform of a tensor or buffer — platform","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") platform(x) #> [1] \"cpu\""},{"path":"https://r-xla.github.io/anvil/reference/prim.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Primitive — prim","title":"Get a Primitive — prim","text":"Get primitive name.","code":""},{"path":"https://r-xla.github.io/anvil/reference/prim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Primitive — prim","text":"","code":"prim(name = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/prim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Primitive — prim","text":"name (character() | NULL) name primitive. NULL, returns list primitives.","code":""},{"path":"https://r-xla.github.io/anvil/reference/prim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Primitive — prim","text":"(AnvilPrimitive)","code":""},{"path":"https://r-xla.github.io/anvil/reference/register_primitive.html","id":null,"dir":"Reference","previous_headings":"","what":"Register a Primitive — register_primitive","title":"Register a Primitive — register_primitive","text":"Register primitive.","code":""},{"path":"https://r-xla.github.io/anvil/reference/register_primitive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register a Primitive — register_primitive","text":"","code":"register_primitive(name, primitive, overwrite = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/register_primitive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register a Primitive — register_primitive","text":"name (character()) name primitive. primitive (AnvilPrimitive) primitive register. overwrite (logical(1)) Whether overwrite primitive already registered.","code":""},{"path":"https://r-xla.github.io/anvil/reference/reindex_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Reindex Tree — reindex_tree","title":"Reindex Tree — reindex_tree","text":"Reassigns leaf indices form contiguous sequence starting current counter value. used internally filtering nodes tree (e.g. via filter_list_node()) ensure leaf indices still map correctly positions flat list. intended direct use.","code":""},{"path":"https://r-xla.github.io/anvil/reference/reindex_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reindex Tree — reindex_tree","text":"","code":"reindex_tree(x, counter)"},{"path":"https://r-xla.github.io/anvil/reference/reindex_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reindex Tree — reindex_tree","text":"x (Node) tree node reindex. counter (environment) mutable counter created new_counter().","code":""},{"path":"https://r-xla.github.io/anvil/reference/reindex_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reindex Tree — reindex_tree","text":"new Node updated leaf indices.","code":""},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the shape of a tensor — shape","title":"Get the shape of a tensor — shape","text":"Returns shape tensor integer() vector.","code":""},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the shape of a tensor — shape","text":"","code":"shape(x, ...)"},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the shape of a tensor — shape","text":"x (tensorish) tensor-like object. ... Additional arguments passed methods (unused).","code":""},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the shape of a tensor — shape","text":"integer()","code":""},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the shape of a tensor — shape","text":"implemented via generic tengen::shape().","code":""},{"path":"https://r-xla.github.io/anvil/reference/shape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the shape of a tensor — shape","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") shape(x) #> [1] 4"},{"path":"https://r-xla.github.io/anvil/reference/stablehlo.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower a graph to StableHLO — stablehlo","title":"Lower a graph to StableHLO — stablehlo","text":"Converts traced AnvilGraph StableHLO intermediate representation (IR). graph operation translated corresponding StableHLO op. result can serialized MLIR text via stablehlo::repr() subsequently compiled XLA executable pjrt::pjrt_compile(). rules translating stablehlo stored $rules[[\"stablehlo\"]] primitives. low-level function; users use jit() xla() instead.","code":""},{"path":"https://r-xla.github.io/anvil/reference/stablehlo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower a graph to StableHLO — stablehlo","text":"","code":"stablehlo(graph, constants_as_inputs = TRUE, env = NULL, donate = character())"},{"path":"https://r-xla.github.io/anvil/reference/stablehlo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower a graph to StableHLO — stablehlo","text":"graph (AnvilGraph) graph lower (e.g. produced trace_fn()). constants_as_inputs (logical(1)) TRUE (default), constants registered inputs StableHLO function can passed execution time. FALSE, added inputs. Set FALSE closures. Note GraphLiterals always inlined StableHLO function. env (HloEnv | NULL) Optional environment reusing variable mappings across nested function lowerings (e.g. higher-order primitives like nv_while). donate (character()) Names arguments whose buffers donated. Donated buffers can aliased outputs type, enabling -place operations.","code":""},{"path":"https://r-xla.github.io/anvil/reference/stablehlo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower a graph to StableHLO — stablehlo","text":"list length 2: stablehlo::Func list GraphValues holding ConcreteTensors.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/stablehlo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lower a graph to StableHLO — stablehlo","text":"","code":"x <- nv_tensor(c(1, 2)) graph <- trace_fn(function(y) y + x, list(y = nv_aten(\"f32\", shape = c()))) graph #> <AnvilGraph> #>   Inputs: #>     %x1: f32[] #>   Constants: #>     %c1: f32[2] #>   Body: #>     %1: f32[2] = broadcast_in_dim [shape = 2, broadcast_dimensions = <any>] (%x1) #>     %2: f32[2] = add(%1, %c1) #>   Outputs: #>     %2: f32[2]  stablehlo(graph) #> [[1]] #> func.func @main (%0: tensor<2xf32>, %1: tensor<f32>) -> tensor<2xf32> { #> %2 = \"stablehlo.broadcast_in_dim\" (%1) { #> broadcast_dimensions = array<i64> #> }: (tensor<f32>) -> (tensor<2xf32>) #> %3 = \"stablehlo.add\" (%2, %0): (tensor<2xf32>, tensor<2xf32>) -> (tensor<2xf32>) #> \"func.return\"(%3): (tensor<2xf32>) -> () #> } #>  #> [[2]] #> [[2]][[1]] #> GraphValue(ConcreteTensor(f32, (2)))  #>  #>"},{"path":"https://r-xla.github.io/anvil/reference/subgraphs.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Subgraphs from Higher-Order Primitive — subgraphs","title":"Get Subgraphs from Higher-Order Primitive — subgraphs","text":"Extracts subgraphs parameters higher-order primitive call.","code":""},{"path":"https://r-xla.github.io/anvil/reference/subgraphs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Subgraphs from Higher-Order Primitive — subgraphs","text":"","code":"subgraphs(call)"},{"path":"https://r-xla.github.io/anvil/reference/subgraphs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Subgraphs from Higher-Order Primitive — subgraphs","text":"call (PrimitiveCall) primitive call.","code":""},{"path":"https://r-xla.github.io/anvil/reference/subgraphs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Subgraphs from Higher-Order Primitive — subgraphs","text":"(list(AnvilGraph)) List subgraphs found parameters.","code":""},{"path":"https://r-xla.github.io/anvil/reference/tensorish.html","id":null,"dir":"Reference","previous_headings":"","what":"Tensor-like Objects — tensorish","title":"Tensor-like Objects — tensorish","text":"tensorish value object can passed input anvil primitive functions nvl_add output function. runtime, AnvilTensor objects. following types tensorish (compile-time): AnvilTensor: concrete tensor holding data device. GraphBox: boxed abstract tensor representing value graph. Literals: numeric(1), integer(1), logical(1): promoted scalar tensors. Use is_tensorish() check whether value tensorish.","code":""},{"path":"https://r-xla.github.io/anvil/reference/tensorish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tensor-like Objects — tensorish","text":"","code":"is_tensorish(x, literal = TRUE)"},{"path":"https://r-xla.github.io/anvil/reference/tensorish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tensor-like Objects — tensorish","text":"x () Object check. literal (logical(1)) Whether accept R literals tensorish.","code":""},{"path":"https://r-xla.github.io/anvil/reference/tensorish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tensor-like Objects — tensorish","text":"logical(1)","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/tensorish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tensor-like Objects — tensorish","text":"","code":"# AnvilTensors are tensorish is_tensorish(nv_tensor(1:4)) #> [1] TRUE  # Scalar R literals are tensorish by default is_tensorish(1.5) #> [1] TRUE  # Non-scalar vectors are not tensorish is_tensorish(1:4) #> [1] FALSE  is_tensorish(DebugBox(nv_aten(\"f32\", c(2L, 3L)))) #> [1] TRUE  # Disable literal promotion is_tensorish(1.5, literal = FALSE) #> [1] FALSE"},{"path":"https://r-xla.github.io/anvil/reference/to_abstract.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to Abstract Tensor — to_abstract","title":"Convert to Abstract Tensor — to_abstract","text":"Convert object abstract tensor representation (AbstractTensor).","code":""},{"path":"https://r-xla.github.io/anvil/reference/to_abstract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to Abstract Tensor — to_abstract","text":"","code":"to_abstract(x, pure = FALSE)"},{"path":"https://r-xla.github.io/anvil/reference/to_abstract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to Abstract Tensor — to_abstract","text":"x () Object convert. pure (logical(1)) Whether convert pure AbstractTensor e.g. LiteralTensor ConcreteTensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/to_abstract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to Abstract Tensor — to_abstract","text":"AbstractTensor","code":""},{"path":"https://r-xla.github.io/anvil/reference/to_abstract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to Abstract Tensor — to_abstract","text":"","code":"# R literals become LiteralTensors (ambiguous by default, except logicals) to_abstract(1.5) #> LiteralTensor(1.5, f32?, ())  to_abstract(1L) #> LiteralTensor(1, i32?, ())  to_abstract(TRUE) #> LiteralTensor(TRUE, i1, ())   # AnvilTensors become ConcreteTensors to_abstract(nv_tensor(1:4)) #> ConcreteTensor #>  1 #>  2 #>  3 #>  4 #> [ CPUi32{4} ]   # Use pure = TRUE to strip subclass info to_abstract(nv_tensor(1:4), pure = TRUE) #> AbstractTensor(dtype=i32, shape=4)"},{"path":"https://r-xla.github.io/anvil/reference/trace_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace an R function into a Graph — trace_fn","title":"Trace an R function into a Graph — trace_fn","text":"Executes f abstract tensor arguments records every primitive operation AnvilGraph. resulting graph can lowered StableHLO (via stablehlo()) transformed (e.g. via transform_gradient()).","code":""},{"path":"https://r-xla.github.io/anvil/reference/trace_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace an R function into a Graph — trace_fn","text":"","code":"trace_fn(   f,   args = NULL,   desc = NULL,   toplevel = FALSE,   lit_to_tensor = FALSE,   args_flat = NULL,   in_tree = NULL )"},{"path":"https://r-xla.github.io/anvil/reference/trace_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace an R function into a Graph — trace_fn","text":"f (function) function trace. Must JitFunction (.e. already jitted). args (list (AnvilTensor | AbstractTensor)) (unflattened) arguments function. Mutually exclusive args_flat/in_tree pair. desc (NULL | GraphDescriptor) Optional descriptor. NULL (default), new descriptor created. toplevel (logical(1)) TRUE, concrete AnvilTensor inputs treated unknown (traced) values. FALSE (default), treated known constants. lit_to_tensor (logical(1)) Whether convert literal inputs tensors. Used internally higher-order primitives nv_if nv_while. args_flat (list) Flattened arguments. Must accompanied in_tree. in_tree (Node) Tree structure describing args_flat maps back f's arguments.","code":""},{"path":"https://r-xla.github.io/anvil/reference/trace_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace an R function into a Graph — trace_fn","text":"AnvilGraph containing traced operations.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/trace_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trace an R function into a Graph — trace_fn","text":"","code":"graph <- trace_fn(function(x, y) x + y,   args = list(x = nv_tensor(1, dtype = \"f32\"), y = nv_tensor(2, dtype = \"f32\")) ) graph #> <AnvilGraph> #>   Inputs: #>     %x1: f32[1] #>     %x2: f32[1] #>   Body: #>     %1: f32[1] = add(%x1, %x2) #>   Outputs: #>     %1: f32[1]"},{"path":"https://r-xla.github.io/anvil/reference/transform_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a graph to its gradient — transform_gradient","title":"Transform a graph to its gradient — transform_gradient","text":"Low-level graph transformation appends backward pass traced AnvilGraph. function f represented graph must return single float scalar. resulting graph computes gradients scalar respect inputs specified wrt. backward rules stored $rules[[\"backward\"]] primitives. building block used gradient() value_and_gradient(); prefer higher-level wrappers unless need operate graphs directly.","code":""},{"path":"https://r-xla.github.io/anvil/reference/transform_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a graph to its gradient — transform_gradient","text":"","code":"transform_gradient(graph, wrt)"},{"path":"https://r-xla.github.io/anvil/reference/transform_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a graph to its gradient — transform_gradient","text":"graph (AnvilGraph) graph transform. Must produce single scalar float output. wrt (character) Names graph inputs differentiate respect .","code":""},{"path":"https://r-xla.github.io/anvil/reference/transform_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a graph to its gradient — transform_gradient","text":"AnvilGraph whose outputs requested gradients.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/transform_gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a graph to its gradient — transform_gradient","text":"","code":"graph <- trace_fn(nvl_mul, list(nv_aten(\"f32\", c()), nv_aten(\"f32\", c()))) graph #> <AnvilGraph> #>   Inputs: #>     %x1: f32[] #>     %x2: f32[] #>   Body: #>     %1: f32[] = mul(%x1, %x2) #>   Outputs: #>     %1: f32[]  transform_gradient(graph, \"lhs\") #> <AnvilGraph> #>   Inputs: #>     %x1: f32[] #>     %x2: f32[] #>   Constants: #>     %c1: f32[] #>   Body: #>     %1: f32[] = mul(%x1, %x2) #>     %2: f32[] = mul(%c1, %x2) #>   Outputs: #>     %2: f32[]"},{"path":"https://r-xla.github.io/anvil/reference/tree_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree Size — tree_size","title":"Tree Size — tree_size","text":"Counts number leaf nodes tree. equals length flat list produced flatten() original structure.","code":""},{"path":"https://r-xla.github.io/anvil/reference/tree_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree Size — tree_size","text":"","code":"tree_size(x)"},{"path":"https://r-xla.github.io/anvil/reference/tree_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree Size — tree_size","text":"x (Node) tree node returned build_tree().","code":""},{"path":"https://r-xla.github.io/anvil/reference/tree_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree Size — tree_size","text":"scalar integer.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/tree_size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree Size — tree_size","text":"","code":"tree <- build_tree(list(a = 1, b = list(c = 2, d = 3))) tree_size(tree) #> [1] 3  tree_size(build_tree(list(1))) #> [1] 1"},{"path":"https://r-xla.github.io/anvil/reference/unflatten.html","id":null,"dir":"Reference","previous_headings":"","what":"Unflatten — unflatten","title":"Unflatten — unflatten","text":"Reconstructs nested structure flat list using tree previously created build_tree(). LeafNode tree selects corresponding element x index, ListNodes restore original nesting names.","code":""},{"path":"https://r-xla.github.io/anvil/reference/unflatten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unflatten — unflatten","text":"","code":"unflatten(node, x)"},{"path":"https://r-xla.github.io/anvil/reference/unflatten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unflatten — unflatten","text":"node (Node) Tree describing target structure, returned build_tree(). x (list) Flat list leaf values, typically produced flatten().","code":""},{"path":"https://r-xla.github.io/anvil/reference/unflatten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unflatten — unflatten","text":"reconstructed nested structure (list single value).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/unflatten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unflatten — unflatten","text":"","code":"x <- list(a = 1, b = list(c = 2, d = 3)) tree <- build_tree(x) flat <- flatten(x)  unflatten(tree, flat) #> $a #> [1] 1 #>  #> $b #> $b$c #> [1] 2 #>  #> $b$d #> [1] 3 #>  #>   unflatten(tree, list(10, 20, 30)) #> $a #> [1] 10 #>  #> $b #> $b$c #> [1] 20 #>  #> $b$d #> [1] 30 #>  #>"},{"path":"https://r-xla.github.io/anvil/reference/unwrap_if_tensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the underlying PJRT buffer from an AnvilTensor or pass through other values — unwrap_if_tensor","title":"Get the underlying PJRT buffer from an AnvilTensor or pass through other values — unwrap_if_tensor","text":"Get underlying PJRT buffer AnvilTensor pass values","code":""},{"path":"https://r-xla.github.io/anvil/reference/unwrap_if_tensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the underlying PJRT buffer from an AnvilTensor or pass through other values — unwrap_if_tensor","text":"","code":"unwrap_if_tensor(x)"},{"path":"https://r-xla.github.io/anvil/reference/unwrap_if_tensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the underlying PJRT buffer from an AnvilTensor or pass through other values — unwrap_if_tensor","text":"x AnvilTensor value","code":""},{"path":"https://r-xla.github.io/anvil/reference/unwrap_if_tensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the underlying PJRT buffer from an AnvilTensor or pass through other values — unwrap_if_tensor","text":"underlying PJRT buffer x AnvilTensor, otherwise x unchanged","code":""},{"path":"https://r-xla.github.io/anvil/reference/value_and_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Value and Gradient — value_and_gradient","title":"Value and Gradient — value_and_gradient","text":"Returns new function computes output f gradient single forward+backward pass. result named list elements value (original return value f) grad (gradients, structured like inputs wrt subset).","code":""},{"path":"https://r-xla.github.io/anvil/reference/value_and_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Value and Gradient — value_and_gradient","text":"","code":"value_and_gradient(f, wrt = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/value_and_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Value and Gradient — value_and_gradient","text":"f (function) Function differentiate. Arguments can tensorish (AnvilTensor) static (non-tensor) values. Must return single scalar float tensor. wrt (character NULL) Names arguments compute gradient respect . tensorish (float tensor) arguments can included; static arguments must appear wrt. NULL (default), gradient computed respect arguments (must tensorish case).","code":""},{"path":"https://r-xla.github.io/anvil/reference/value_and_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Value and Gradient — value_and_gradient","text":"function formals f returns list(value = ..., grad = ...).","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/value_and_gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Value and Gradient — value_and_gradient","text":"","code":"loss_fn <- function(x) sum(x^2L) vg <- jit(value_and_gradient(loss_fn)) result <- vg(nv_tensor(c(3, 4), dtype = \"f32\")) result$value #> AnvilTensor #>  25 #> [ CPUf32{} ]  result$grad #> $x #> AnvilTensor #>  6 #>  8 #> [ CPUf32{2} ]  #>"},{"path":"https://r-xla.github.io/anvil/reference/vt2at.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert ValueType to AbstractTensor — vt2at","title":"Convert ValueType to AbstractTensor — vt2at","text":"Convert ValueType AbstractTensor.","code":""},{"path":"https://r-xla.github.io/anvil/reference/vt2at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert ValueType to AbstractTensor — vt2at","text":"","code":"vt2at(x)"},{"path":"https://r-xla.github.io/anvil/reference/vt2at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert ValueType to AbstractTensor — vt2at","text":"x (ValueType)","code":""},{"path":"https://r-xla.github.io/anvil/reference/vt2at.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert ValueType to AbstractTensor — vt2at","text":"(AbstractTensor)","code":""},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":null,"dir":"Reference","previous_headings":"","what":"Ahead-of-time compile a function to XLA — xla","title":"Ahead-of-time compile a function to XLA — xla","text":"Compiles function XLA executable via tracing. Returns callable R function executes compiled binary. Unlike jit(), compilation happens eagerly definition time rather first call, input shapes dtypes must specified upfront via abstract tensors (see nv_aten()).","code":""},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ahead-of-time compile a function to XLA — xla","text":"","code":"xla(f, args, donate = character(), device = NULL)"},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ahead-of-time compile a function to XLA — xla","text":"f (function) Function compile. Must accept return AnvilTensors. args (list) List abstract tensor specifications (e.g. nv_aten()) describing expected shapes dtypes f's arguments. donate (character()) Names arguments whose buffers donated. device (character(1)) Target device \"cpu\" (default) \"cuda\".","code":""},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ahead-of-time compile a function to XLA — xla","text":"(function) function accepts AnvilTensor arguments (matching flat inputs) returns result AnvilTensors.","code":""},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ahead-of-time compile a function to XLA — xla","text":"Traces f given abstract args (via trace_fn()), lowers resulting graph via stablehlo() compiles XLA executable via pjrt::pjrt_compile(). compiles XLA executable immediately.","code":""},{"path":[]},{"path":"https://r-xla.github.io/anvil/reference/xla.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ahead-of-time compile a function to XLA — xla","text":"","code":"f_compiled <- xla(function(x, y) x + y,   args = list(x = nv_aten(\"f32\", c(2, 2)), y = nv_aten(\"f32\", c(2, 2))) ) a <- nv_tensor(array(1:4, c(2, 2)), dtype = \"f32\") b <- nv_tensor(array(5:8, c(2, 2)), dtype = \"f32\") f_compiled(a, b) #> AnvilTensor #>   6 10 #>   8 12 #> [ CPUf32{2,2} ]"}]
