<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Autodiff Modes • anvil</title>
<!-- mathjax math --><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    chtml: {
      fontURL: "https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/output/chtml/fonts/woff-v2"
    }
  };
</script><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Autodiff Modes">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">anvil</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-xla/anvil/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Autodiff Modes</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/r-xla/anvil/blob/feat-comp/vignettes/autodiff-modes.Rmd" class="external-link"><code>vignettes/autodiff-modes.Rmd</code></a></small>
      <div class="d-none name"><code>autodiff-modes.Rmd</code></div>
    </div>

    
    
<p>In this vignette, we will explore the different modes of
autodiff.</p>
<p>Let’s say, we have a function</p>
<p><span class="math display">\[
\newcommand{\R}{\mathbb{R}}
\]</span></p>
<p><span class="math display">\[ f(b) = a \times b^\top \times x
\]</span></p>
<p>where <span class="math inline">\(a \, \in \, \R^{m \times 1},\, b \,
\in \, \R^{1 \times p},\, x \, \in \, \R^{p \times 1}\)</span></p>
<p>We can write this as:</p>
<p><span class="math display">\[
\begin{bmatrix}
y_1 \\
\vdots \\
y_m
\end{bmatrix}
= \begin{bmatrix}
a_1 \\
\vdots \\
a_m
\end{bmatrix} \times
\begin{bmatrix}
b_1, \ldots, b_p
\end{bmatrix} \times
\begin{bmatrix}
x_1 \\
\vdots \\
x_p
\end{bmatrix}
\]</span></p>
<p>Note that the specific form of the function <span class="math inline">\(f\)</span> is not important. The dimensions are
chosen in such a way, that it’s apparent what the advantage and
disadvantage of forward and reverse mode autodiff is.</p>
<p>The jacobian of <span class="math inline">\(f\)</span> with respect
to <span class="math inline">\(b\)</span> is:</p>
<p><span class="math display">\[
\begin{bmatrix}
\frac{\partial y_1}{\partial b_1} &amp; \cdots &amp; \frac{\partial
y_1}{\partial b_p} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_m}{\partial b_1} &amp; \cdots &amp; \frac{\partial
y_m}{\partial b_p}
\end{bmatrix}
\]</span></p>
<p>If we denote the temporary variables of <span class="math inline">\(b^\top \times x\)</span> as <span class="math inline">\(z\)</span>, we can use the chain rule to obtain
the formula:</p>
<p><span class="math display">\[
\frac{\partial f}{\partial b} = \frac{\partial f}{\partial z} \times
\frac{\partial z}{\partial b}
\]</span></p>
<p>Writing out the matrices, we get:</p>
<p><span class="math display">\[
\begin{bmatrix}
\frac{\partial y_1}{\partial b_1} &amp; \cdots &amp; \frac{\partial
y_1}{\partial b_p} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_m}{\partial b_1} &amp; \cdots &amp; \frac{\partial
y_m}{\partial b_p}
\end{bmatrix}
= \begin{bmatrix}
\frac{\partial y_1}{\partial z_1} &amp; \cdots &amp; \frac{\partial
y_1}{\partial z_l} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_m}{\partial z_1} &amp; \cdots &amp; \frac{\partial
y_m}{\partial z_l}
\end{bmatrix} \times
\begin{bmatrix}
\frac{\partial z_1}{\partial b_1} &amp; \cdots &amp; \frac{\partial
z_1}{\partial b_p} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial z_l}{\partial b_1} &amp; \cdots &amp; \frac{\partial
z_l}{\partial b_p}
\end{bmatrix}
\]</span></p>
<p>The question is now, how we can actually <strong>calculate</strong>
this computationally. For computational feasibility, we want to avoid
calculating the full intermediate matrices, as these can be very
large.</p>
<p>To ways to do this are:</p>
<ul>
<li>Forward mode autodiff</li>
<li>Reverse mode autodiff</li>
</ul>
<div class="section level3">
<h3 id="forward-mode-autodiff">Forward mode autodiff<a class="anchor" aria-label="anchor" href="#forward-mode-autodiff"></a>
</h3>
<p>In this case, we build up the jacobian column by column. I.e., we
calculate the partial derivative of <span class="math inline">\(f\)</span> with respect to <span class="math inline">\(b_1\)</span>, then <span class="math inline">\(b_2\)</span>, etc.</p>
<p>In practice, we start by multiplying <span class="math inline">\(\frac{\partial z}{\partial b}\)</span> with the
one hot vector <span class="math inline">\(e_1\)</span> (i.e., the first
column of the identity matrix). Writing this out with matrices, we
get:</p>
<p><span class="math display">\[
\begin{bmatrix}
\frac{\partial z_1}{\partial b_1} &amp; \cdots &amp; \frac{\partial
z_1}{\partial b_p} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial z_l}{\partial b_1} &amp; \cdots &amp; \frac{\partial
z_l}{\partial b_p}
\end{bmatrix}\times
\begin{bmatrix}
1 \\
\vdots \\
0
\end{bmatrix}=
\begin{bmatrix}
\frac{\partial z_1}{\partial b_1} \\
\vdots \\
\frac{\partial z_l}{\partial b_1}
\end{bmatrix}
\]</span></p>
<p>This will give us an intermediate matrix <span class="math inline">\(u \in \R^{l \times 1}\)</span>.</p>
<p>To get the final result, we need to multiply the jacobian of <span class="math inline">\(y\)</span> with respect to <span class="math inline">\(z\)</span> with <span class="math inline">\(u\)</span>.</p>
<p><span class="math display">\[
\begin{bmatrix}
\frac{\partial y_1}{\partial b_1} \\
\vdots \\
\frac{\partial y_m}{\partial b_1}
\end{bmatrix}
=
\begin{bmatrix}
\frac{\partial y_1}{\partial z_1} &amp; \cdots &amp; \frac{\partial
y_1}{\partial z_l} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_m}{\partial z_1} &amp; \cdots &amp; \frac{\partial
y_m}{\partial z_l}
\end{bmatrix} \times \begin{bmatrix}
u_1 \\ \vdots \\ u_l
\end{bmatrix}
\]</span></p>
<p>Note that we could – mathematically – of course multiply not only
with a single unity vector, but with the whole identity matrix. The
reason this is not done, is because of the memory costs and
computational complexity.</p>
<p>In the first step of the forward mode AD we multiply a matrix of size
<span class="math inline">\(l \times p\)</span> with a matrix of size
<span class="math inline">\(p \times 1\)</span>. and the result is a
matrix of size <span class="math inline">\(l \times 1\)</span>. But if
we would multiply with the identity matrix, we would start out with a
matrix of size <span class="math inline">\(p \times p\)</span> and the
first intermediate result would be a matrix of size <span class="math inline">\(l \times p\)</span>.</p>
<p>So, we is this an issue, even with a single unity vector we have an
intermediate jacobian of size <span class="math inline">\(l \times
p\)</span>, so why is another one of size <span class="math inline">\(p
\times p\)</span> an issue?</p>
<p>The reason is, that the jacobian of size <span class="math inline">\(l \times p\)</span> is never stored in memory,
whereas the intermediate value of size <span class="math inline">\(p
\times p\)</span> would have to be stored.</p>
</div>
<div class="section level3">
<h3 id="reverse-mode-autodiff">Reverse mode autodiff<a class="anchor" aria-label="anchor" href="#reverse-mode-autodiff"></a>
</h3>
<p>Instead of building up the jacobian column by column, we build up the
jacobian row by row. I.e., we calculate the partial derivative of <span class="math inline">\(f\)</span> with respect to <span class="math inline">\(b_1\)</span>, then <span class="math inline">\(b_2\)</span>, etc.</p>
<p>We go from forward mode to reverse mode by transposing the jacobian
of <span class="math inline">\(f\)</span> with respect to <span class="math inline">\(z\)</span>.</p>
<p><span class="math display">\[
\frac{\partial f}{\partial b}^\top =
\big[\frac{\partial f}{\partial z} \times \frac{\partial z}{\partial
b}\big]^\top=
\frac{\partial z}{\partial b}^\top \times \frac{\partial f}{\partial
z}^\top
\]</span></p>
<p>If we now multiply this with a unity vector <span class="math inline">\(r_i \in \R^{1 \times m}\)</span>, which determines
with respect to which output variable we calculate the jacobian, we
get:</p>
<p><span class="math display">\[
\frac{\partial f}{\partial b_1}^\top \times r_1 = \frac{\partial
z}{\partial b_1}^\top \times \frac{\partial f}{\partial z}^\top \times
r_1
\]</span></p>
<p>In full matrix notation, we get:</p>
<p><span class="math display">\[
\begin{bmatrix}
\frac{\partial y_1}{\partial b_1} \\
\vdots \\
\frac{\partial y_1}{\partial b_p}
\end{bmatrix} =
\begin{bmatrix}
\frac{\partial z_1}{\partial b_1} &amp; \cdots &amp; \frac{\partial
z_l}{\partial b_1} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial z_1}{\partial b_p} &amp; \cdots &amp; \frac{\partial
z_l}{\partial b_p}
\end{bmatrix} \times
\begin{bmatrix}
\frac{\partial y_1}{\partial z_1} &amp; \cdots &amp; \frac{\partial
y_m}{\partial z_1} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_1}{\partial z_l} &amp; \cdots &amp; \frac{\partial
y_m}{\partial z_l}
\end{bmatrix} \times
\begin{bmatrix}
1 \\
0 \\
\vdots \\
0
\end{bmatrix}
\]</span></p>
<p>If we look closely at the last equation, we see now, that this
requires us to first calculate a forward pass, before we calculate the
backward pass. This is, because we want to start with the rightmost
multiplication, as this reduces the computational complexity. But the
rightmost multiplication involves the derivative of <span class="math inline">\(f\)</span> with respect to the temporary variables
<span class="math inline">\(z\)</span>. Therefore, we first need to
obtain these values using a forward pass.</p>
<p>Now, for the first step, we have computational complexity <span class="math inline">\(O(m \times l)\)</span> and for the second one
<span class="math inline">\(O(p \times l)\)</span>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Sebastian Fischer, Daniel Falbel.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
