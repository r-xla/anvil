---
title: "Design"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Design}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Just like a real anvil, the {anvil} package is a tool that allows to reshape objects.
While a the former is used to shape metal, our {anvil} package can be used to shape code into other code.
In this vignette we will first give a high-level overview of the main concepts and then dive into the details.

## Bird's Eye View

We will demonstrate the package's main functionality by means of an example.
We start by creating a simple R function that adds two objects using the {anvil} function `nv_add`.

```{r, eval = FALSE}
library(anvil)
f <- function(x, y) {
  nv_add(x, y)
}
```

The {anvil} package allows to transform such R functions in various ways.
However, all these transformations don't operate directly on the R function, but rather on a **graph** representation of the function.
Before we continue with explaining the transformations, we will show how such a graph is created from an R function via **tracing**.

### Tracing R functions into Graphs

All functionality in the {anvil} package is centered around the `Graph` class, and such `Graph`s are created by tracing R functions.
In general, when we want to convert some code into another form, there are two approaches:

1. Static analaysis, which would require operating on the abstract syntax tree (AST) of the code.
2. Dynamic analysis (aka "tracing"), which executes the code and records (selected) operations.

In {anvil}, we take the dynamic approach, which we will now explain.

Let's say, we want to convert out function `f` into a `anvil::Graph` object (which we also call our Intermediate Representation, IR) that represents the function.

To do so, we first initialize an empty `Graph` object with reference semantics (it can be mutated in-place):

```{r}
graph <- local_graph()
```

Such a graph contains:

- `inputs`: (`list<GraphValue>`) The function inputs.
- `outputs`: (`list<GraphValue>`) The function outputs.
- `calls`: (`list<PrimitiveCall>`) A list of `PrimitiveCall` objects that represent the body of the function.
  A primitive call takes the values from some input `GraphValue`s (plus some, optional, static parameters) and assigns the results to some output `GraphValue`s.
- ... (other fields we ignore for now)

Our goal is now to evaluate the function `f` and to populate the empty `Graph` from above to represent the structur of `f`.
To do so, we need to create some input values that we pass as arguments `x` and `y`.
This is necessary, because the intermediate graph representation is strongly typed the above R function `f` does not have any types.
All subsequent types within the function `f` will be derived from these input types.

```{r}
x_gval <- GraphValue(ShapedTensor(dt_i32, Shape(c(2, 2))))
y_gval <- GraphValue(ShapedTensor(dt_i32, Shape(c(2, 2))))
```

However, we cannot execute `grad` directly with these input types.
Instead, we will create another thin wrapper, a `GraphBox` object, which also contains a reference to the `Graph` object.
This is necessary, because `Graph`-buiding can initiate another nested `Graph`-building process and we need to be able to tell whether an object is a variable in the outer or inner graph.

```{r}
x_box <- GraphBox(x_aval, graph)
y_box <- GraphBox(y_aval, graph)
```

Using these boxes, we can execute our function `f`:

```{r}
z_box <- f(x_box, y_box)
graph@inputs
graph@calls
```

Awesome, our graph `@inputs` and `@calls` are now populated with what we wanted.
The `@outputs` field is still empty, however:

```{r}
graph@outputs
```

This is

The result is a `GraphBox` object that contains the output value of the function `f`.


have to create `GraphBox` objects.
A `GraphBox` is essentially a wrapper around a type, with some other internal data that will allow building up the `Graph` as we execute the function `grad`.


In general, there are two different types of transformations:

1. Non-lowering transformations (currently only `gradient()`).
   They change the structure of the function, possibly including the signature and body of a function.
2. Lowering transformations (currently only `stablehlo()`).
   They are responsible for translating the `R` function into another language for accelerated execution.
   {anvil} is designed to be multi-backend, so while we currently only offer a stableHLO/XLA backend,
   this can be extended, even by external packages.

We will now illustrate both types of transformations.

### Non-lowering transformations

A non-lowering transformation takes as input a function and outputs another function.

```{r}
grad <- gradient(f)
grad
```

Rather than returning the actual gradient of the function `f`, it contains a **recipe** for creating the gradient.
This is, because {anvil} works via **tracing**, which needs example inputs for creating a computational **graph**.




Then, we transform this function using the `gradient()` transformation.
This will create another function

, which creates a `GradientTransformation` object that inherits from `Transformation`.
Such a `Transformation` object is created by a transformation function like `gradient()` (others will follow later).
In this case, we have to specify with respect to which argument we want to compute the gradient.

```{r, eval = FALSE}
f1 <- gradient(f, wrt = "x")
```

The signature of transformation functions like `gradient` essentially have the signature:

```
Graph -> ((...,) -> list(Graph, list(<any>)))
```

where `(..., )` represents a variable number of arguments.
Therefore, `f1` is now a function that returns a transformed `Graph` object for given example inputs, as well as transformed input values for given example inputs.
If a an R function is passed to a transformation (like above), then the transformation step will implicitly create the `Graph` from the R-`Function` by passing the example inputs (`(...,)`) to `anvil::graphify()`.
`graphify` works by tracing the R function, see section TODO for more details.

```{r, eval = FALSE}
x <- nv_scalar(1.0)
y <- nv_scalar(2.0)
g1 <- apply_transform(f1, x, y)[[1L]]

# is the same as:
apply_transform(gradient(graphify(f, x, y)))(x, y)[[1L]]
```

We can also build up chained transformations.
Note that `gradient` works currently only for scalar-valued functions, so the example we are showing here is a bit artificial, but it demonstrates the chaining of transformations.

```{r, eval = FALSE}
f2 <- gradient(f1)
```

The type of `f2` is now essentially:

```
((..., ) -> ((..., ) -> list(Graph, list(<any>))))
```

In order to obtain the transformed `Graph`, we therefore need to reduce the transformations using `apply_transform()`.

In order to obtain the actual transformed graph, we therefore need to recursively apply the transformations to the input graph, which is done by the `apply_transform()` function.

```{r, eval = FALSE}
g2 <- apply_transform(f2, x, y)
# is the same as
g21 <- apply_transform(f2@input, x, y)
g22 <- apply_transform(g21[[1]], g21$inputs[[1]], g21$inputs[[2]])[[2]]
g22
```

This `Graph` object can now be compiled to an executable using the `pjrt` package.
To do so, we first lower it to `stablehlo::Func` objects via `stablehlo()`.

```{r, eval = FALSE}
func <- stablehlo(g22, x, y)
func
```

We can now compile this `Func` object to an `XLA` executable via `pjrt_compile()`.

```{r, eval = FALSE}
library(pjrt)
exec <- pjrt_compile(stablehlo::repr(func))
```

And execute it on the example inputs:

```{r, eval = FALSE}
pjrt_execute(exec, x, y)
```

In order to allow for a more convenient user interface, `jit()` (or `xla()` ???) wraps this and also handles the caching of the compiled functions.

TO CONTINNUE

## Close Up View

* Primitives
* Tracing and Graph-building
* Flattening
