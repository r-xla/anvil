---
title: "Design"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Design}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Just like a real anvil, the {anvil} package is a tool that allows to reshape objects.
While a the former is used to shape metal, our {anvil} package can be used to shape code into other code.
In this vignette we will first give a high-level overview of the main concepts and then dive into the details.

## Bird's Eye View

We will demonstrate the package's main functionality by means of an example.
We start by creating a simple R function that adds two objects using the {anvil} function `nv_add`.

```{r, eval = FALSE}
library(anvil)
f <- function(x, y) {
  nv_add(x, y)
}
```

Then, we transform this function using the `gradient()` transformation, which creates a `GradientTransformation` object that inherits from `Transformation`.
Such a `Transformation` object is created by a transformation function like `gradient()` (others will follow later).
In this case, we have to specify with respect to which argument we want to compute the gradient.

```{r, eval = FALSE}
f1 <- gradient(f, wrt = "x")
```

The signature of transformation functions like `gradient` essentially have the signature:

```
Graph -> ((...,) -> list(Graph, list(<any>)))
```

where `(..., )` represents a variable number of arguments.
Therefore, `f1` is now a function that returns a transformed `Graph` object for given example inputs, as well as transformed input values for given example inputs.
If a an R function is passed to a transformation (like above), then the transformation step will implicitly create the `Graph` from the R-`Function` by passing the example inputs (`(...,)`) to `anvil::graphify()`.
`graphify` works by tracing the R function, see section TODO for more details.

```{r, eval = FALSE}
x <- nv_scalar(1.0)
y <- nv_scalar(2.0)
g1 <- apply_transform(f1, x, y)[[1L]]

# is the same as:
apply_transform(gradient(graphify(f, x, y)))(x, y)[[1L]]
```

We can also build up chained transformations.
Note that `gradient` works currently only for scalar-valued functions, so the example we are showing here is a bit artificial, but it demonstrates the chaining of transformations.

```{r, eval = FALSE}
f2 <- gradient(f1)
```

The type of `f2` is now essentially:

```
((..., ) -> ((..., ) -> list(Graph, list(<any>))))
```

In order to obtain the transformed `Graph`, we therefore need to reduce the transformations using `apply_transform()`.

In order to obtain the actual transformed graph, we therefore need to recursively apply the transformations to the input graph, which is done by the `apply_transform()` function.

```{r, eval = FALSE}
g2 <- apply_transform(f2, x, y)
# is the same as
g21 <- apply_transform(f2@input, x, y)
g22 <- apply_transform(g21[[1]], g21$inputs[[1]], g21$inputs[[2]])[[2]]
g22
```

This `Graph` object can now be compiled to an executable using the `pjrt` package.
To do so, we first lower it to `stablehlo::Func` objects via `stablehlo()`.

```{r, eval = FALSE}
func <- stablehlo(g22, x, y)
func
```

We can now compile this `Func` object to an `XLA` executable via `pjrt_compile()`.

```{r, eval = FALSE}
library(pjrt)
exec <- pjrt_compile(stablehlo::repr(func))
```

And execute it on the example inputs:

```{r, eval = FALSE}
pjrt_execute(exec, x, y)
```

In order to allow for a more convenient user interface, `jit()` (or `xla()` ???) wraps this and also handles the caching of the compiled functions.

TO CONTINNUE

## Close Up View

* Primitives
* Tracing and Graph-building
* Flattening
