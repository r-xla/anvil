---
title: "Random Number Generation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Random Number Generation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, you will learn how to generate random numbers in {anvil}.
If you're familiar with R's built-in random number generation, you'll notice that {anvil} handles things a bit differently.

## The RNG State

In base R, random number generation uses a global state (`.Random.seed`) that is automatically updated after each call:

```{r}
set.seed(42)
.Random.seed[2:4]
rnorm(3)
.Random.seed[2:4]
rnorm(3)
.Random.seed[2:4]
```

In {anvil}, we take a different approach: the random number generator state must be explicitly passed around.
This is because {anvil} follows a functional programming paradigm where functions are pure and don't have side effects.

**Note:** This explicit state-passing behavior might change in the future to provide a more R-like experience, but for now you need to manage the state yourself.

## Creating an Initial State

To generate random numbers, you first need to create an initial RNG state, which is simply a `ui64[2]`.
For convenience, you can convert an R seed into a state using `nv_rng_state()`:

```{r}
library(anvil)
state <- nv_rng_state(seed = 42L)
state
```

## Generating Random Numbers

The main functions for generating random numbers are `nv_runif()` for uniform distributions and `nv_rnorm()` for normal distributions.
Both functions return a list with two elements:

1. The **new** RNG state (to be used for subsequent random number generation)
2. The generated random numbers

Let's generate some uniform random numbers:

```{r}
f <- jit(function(state) {
  nv_runif(state, dtype = "f32", shape_out = c(2, 3))
})

result <- f(state)
result[[1]]  # new state
result[[2]]  # random numbers
```

For normally distributed random numbers:

```{r}
g <- jit(function(state) {
  nv_rnorm(state, dtype = "f32", shape_out = c(2, 3), mu = 0, sigma = 1)
})

result <- g(state)
result[[2]]
```

## What Happens When You Reuse the State?

Here's the key insight: if you use the same state twice, you get the same random numbers.

```{r}
h <- jit(function(state) {
  result1 <- nv_runif(state, dtype = "f32", shape_out = 3L)
  result2 <- nv_runif(state, dtype = "f32", shape_out = 3L)
  list(first = result1[[2]], second = result2[[2]])
})

output <- h()
as_array(output$first)
as_array(output$second)  # identical to first!
```

As you can see, both calls produced identical random numbers because we used the same state for both.

## Properly Chaining Random Number Generation

To get different random numbers in subsequent calls, you need to pass the **new** state returned by the previous call:

```{r}
proper_rng <- jit(function(state) {
  result1 <- nv_runif(state, dtype = "f32", shape_out = c(3))
  new_state <- result1[[1]]  # extract the new state
  result2 <- nv_runif(new_state, dtype = "f32", shape_out = c(3))
  list(first = result1[[2]], second = result2[[2]])
})

output <- proper_rng(state)
as_array(output$first)
as_array(output$second)  # different from first!
```

Now we get different random numbers because we properly propagated the state.
